Валидация полей

HTML
<input type="text" class="form-control" id="password">
<input type="text" class="form-control" id="password_1">
<input type="text" class="form-control" id="password_2">

PHP
$this->form_validation->set_rules('password', ' ', 'trim|required|xss_clean|min_length[1]|callback_check_password');
$this->form_validation->set_rules('password_1', ' ', 'trim|required|xss_clean|min_length[1]');
$this->form_validation->set_rules('password_2', ' ', 'trim|required|xss_clean|min_length[1]|matches[password_1]');

проверка что старый пароль введен верно
public function check_password($password) {

получаем юзера из базы
$this->db->select('password_hash, password_code');
$this->db->where('id', $this->user->item('id'));
$query = $this->db->get('users');
$user = $query->row();

старый пароль введен верно
if ($user->password_hash == md5($user->password_code . $password . $user->password_code)) {
return true;
}

$this->form_validation->set_message('check_password', 'Старый пароль введен неверно');
return false;
}
-----------------------------------------------------

QueryBuilder

$this->db->select('field');
$this->db->select('field as field');
$this->db->select('field1, field2');
$this->db->select_sum('field');
$this->db->select(sum('field'));

$this->db->where('field', 0);
$this->db->where('field = 0');
$this->db->where(['field' => 0]);

$this->db->where_in('field', ['one', 'two']);
$this->db->where_not_in('field', ['one', 'two']);

$this->db->join('table2', 'table.id = table2.id');

$this->db->order_by('field');
$this->db->order_by('field', 'DESC');

$this->db->group_by('field');

$this->db->limit($count); - аналог LIMIT $count;
$this->db->limit($count, $offset); - аналог LIMIT $offset, $count;

$this->db->escape($var);

$query = $this->db->get('table');

$result = $query->result(); // вся выборка
$result = $query->row(); // 1 строка
$result = $query->row()->field; // 1 строка 1 столбец
$result = $query->num_rows(); // колво строк (аналог count(*))


UPDATE
$this->db
->where('id', 100)
->update('table', ['field' => 0]);

UPDATE increment field
$this->db->where('id', 100);
$this->db->set('field', 'field+1', FALSE);
$this->db->update('table');
ИЛИ
"UPDATE `table` SET `field` = (`field` + " . $this->db->escape($field) . ") WHERE `id` = " . $this->db->escape($field);

для UPDATE запросов, сколько рядов затронуло
$this->db->affected_rows();

INSERT
$this->db->insert('addresses', $post);

INSERT IGNORE
$str = $this->db->insert_string('addresses', $data);
$str = preg_replace("~(INSERT INTO)~isu", 'INSERT IGNORE INTO', $str);
$this->db->query($str);
return $this->db->insert_id();

DELETE
$this->db->delete('addresses', [
'id' => $id,
'users_id' => $this->user->item('id'),
]);


ОТЛАДКА
$this->db->last_query();
-----------------------------------------------------

Залогиненность

администратор залогинен $this->administrator->is_login();
юзер залогинен $this->user->is_login();
-----------------------------------------------------

Сессии

положить в сессию
$this->session->userdata('property');

удалить из сессии
$this->session->unset_userdata('property');

всё что есть в сессии
$this->session->all_userdata();
-----------------------------------------------------

ОТЛАДКА КУК И СЕССИЙ

$aaa = $this->session->all_userdata();
var_dump('База ' . $aaa['session_id']);
print_r(!empty($aaa['basket']) ? $aaa['basket'] : '');


$bbb = unserialize($this->input->cookie('ci_session'));
var_dump('Кука ' . $bbb['session_id']);
print_r(!empty($bbb['basket']) ? $bbb['basket'] : '');
-----------------------------------------------------

Хелпер

Хелпер - небольшие функции, позволяющие избежать дублирования кода, вспомогательный файл с набором функций в определенной группе. Использование в моделях, представлениях, контроллерах, везде.

$this->load->helper('name_helper');
хелперы автозагружаются тут application/config/autoload.php:49

Библиотека

Библиотека - содержит классы и файлы, общение с БД. Библиотека это класс, который нужно сделать экземпляром класса CI и использовать как $this->...для вызова методов.

$this->load->library('name_library');
библиотеки автозагружаются тут application/config/autoload.php:27

$this->name_library->function();

Модель

$this->load->model('model_faq');
загрузка модели
-----------------------------------------------------

Кеширование

Включить кеширование
$this->db->cache_on();
$query = $this->db->query("SELECT * FROM mytable");

Выключите кеширование для этого одного запроса
$this->db->cache_off();
$query = $this->db->query("SELECT * FROM members WHERE member_id = '$current_user'");

Включите кеширование обратно
$this->db->cache_on();
$query = $this->db->query("SELECT * FROM another_table");

$this->db->cache_delete()
Удаляет кеш-файлы связанные с конкретной страницей.
-----------------------------------------------------

Ресайз картинок

Есть 3 библиотеки изображений: GD/GD2, NetPBM, ImageMagick. Ватермарки работают только с GD/GD2. И GD/GD2 нужна для остальных библиотек, чтобы вычислять параметры картинки.

Инициализация
$this->load->library('image_lib');

Вызов функций
$this->image_lib->resize()
$this->image_lib->crop()
$this->image_lib->rotate()
$this->image_lib->watermark()
$this->image_lib->clear()

Проверять отработку функций так
if ($this->image_lib->resize()) {
    echo 'ok';
} else {
    echo $this->image_lib->display_errors();
}

Сброс всех параметров обработки. Вызывать если проходим картинки в цикле
$this->image_lib->clear();

Создание тумбинашки
$config['image_library'] = 'gd2';

//путь до картинки
$config['source_image'] = '/path/to/image/mypic.jpg';

{
//сохранить оригинал, и создать копию сюда
$config['new_image'] = '/path/to/new_image.jpg';

//сохранить оригинал, и создать миниатюру с именем файла с постфиксом оригинал_thumb.jpg
$config['create_thumb'] = TRUE;
}

//сохранять пропорции
$config['maintain_ratio'] = TRUE;

//размер картинки
$config['width'] = 100;
$config['height'] = 100;

$this->load->library('image_lib', $config);
$this->image_lib->resize();
-----------------------------------------------------

Защита от XSS

Будет заменить грязь на [removed]
$this->load->library('security');
$data = $this->security->xss_clean($data);

Проверка файлов
if ($this->security->xss_clean($file, TRUE)) { good file! }

Будет заменять всё на спецсимволы
$data = html_escape($data);

Указать в конфиге application/config/config.php глобально
$config ['global_xss_filtering'] = TRUE;

Автоматически используется xss_clean, если второй параметр true
$this->input->post('some_data', TRUE);
-----------------------------------------------------

CSRF

Указать в конфиге application/config/config.php глобально
$config['csrf_protection'] = TRUE;

Автоматически работает с form_open(). Если не работаем с form_open() то можно вручную:
$csrf = [
        'name' => $this->security->get_csrf_token_name(),
        'hash' => $this->security->get_csrf_hash()
];
<input type="hidden" name="<?=$csrf['name'];?>" value="<?=$csrf['hash'];?>">

По-умолчанию токены регенерируются каждый раз при отправке. Но могут регенерироваться по истечению cookie CSRF. Изменить можно в конфиге $config[ 'csrf_regenerate' ]  =  TRUE;
-----------------------------------------------------

Security Helper

загрузка хелпера
$this->load->helper('security');

xss_clean() - Обеспечивает фильтрацию взлома межсайтовых скриптов.
sanitize_filename() - Обеспечивает защиту от обхода каталога.
strip_image_tags() - Удаляет теги изображений из строки. Он оставляет URL изображения в виде обычного текста.
encode_php_tags() - Преобразует теги PHP в сущности. Примечание. Если вы используете функцию фильтрации XSS, она делает это автоматически.

Security Class

$this->security->xss_clean() - Для фильтрации данных через фильтр XSS (обычно фильтруются POST и COOKIE).
Если вы хотите, чтобы фильтр запускался автоматически каждый раз, когда он встречает данные POST или COOKIE:
application/config/config.php
$config['global_xss_filtering'] = TRUE;

$this->security->xss_clean($file, TRUE) - Необязательный второй параметр позволяет использовать эту функцию для проверки изображений на предмет возможных атак XSS.

$this->security->sanitize_filename() - Принимая имена файлов от пользовательского ввода, лучше всего их санировать, чтобы предотвратить обход каталога. Если для пользовательского ввода допустимо включать относительные пути, вы можете установить второй необязательный параметр в true.

Вы можете включить защиту csrf:
application/config/config.php
$config['csrf_protection'] = TRUE;

Если вы используете помощник по формам, функция form_open () автоматически вставит скрытое поле csrf в ваши формы.
------------------------------------------------------------------------------------------------------------------------
register_globals = off - отключить глобальные переменные
error_reporting = 0 (или ENVIRONMENT = production) - отключить отображение ошибок
magic_quotes_runtime - отключить