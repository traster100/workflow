Концепт


СервисКонтейнер (СК)
это app, хранилище СервисПровайдеров

СервисПровайдер (СП)
это поставщик услуг
добавляем в config/app.php в массив providers
лежат в /app/Providers

Фасад (Ф)
это посредник, добавляет статический интерфейс доступа к классам в СервисКонтейнере
лежат в /app/Facades


СервисПровайдер

class NameServiceProvider extends ServiceProvider {

  добавим СП в СК
  public function register() {

  bind связывает СП с СК. dateCheck это ключ по которому будет доступен класс в СК
  $this->app->bind('dateCheck', 'Полный путь к классу');

  }
}

положим СП в СК
в config/app.php в массив providers:
App\Providers\NameServiceProvider::class;


Фасад
class NameService extends Facade {

  вернуть ключ привязки объекта к СК
  protected static function getFacadeAccessor() {
    return 'dateCheck';
  }
}

регаем Ф
в config/app.php в массив aliases:
'NameService' => App\Facades\NameService::class;

Ф можно вызывать в Контроллерах и Шаблонах.


В роутах не должно быть логики приложения.
Нельзя вызывать модели в шаблонах.
Операции с данными и логику переносить в модель.
Не встраивать css и js во вьюхи.
Использовать модели, а не сырые запросы.
Каждая модель связана со своей таблицей БД.
Миграции нужны для переносимости между разными типами баз данных.
-------------------------------------------------

Ман

https://laravel.com/docs/7.x
-------------------------------------------------

Prologue -> Upgrade Guide

Требования: Symfony 5, PHP 7.2.5, до PSR-7, PHPDoc

Coding standard      PSR-2
Autoloading standard PSR-4
Code styling         StyleCI
-------------------------------------------------

Prologue -> Contribution Guide

Гит     https://github.com/laravel
Форум   https://laracasts.com/discuss
Форум   https://laravel.io/forum
SO      https://stackoverflow.com/questions/tagged/laravel
Discord https://discord.com/invite/KxwQuKb
Job     https://larachat.co
-------------------------------------------------

PhpStorm plugins

https://plugins.jetbrains.com/plugin/7532-laravel
https://github.com/barryvdh/laravel-ide-helper
https://github.com/barryvdh/laravel-debugbar
-------------------------------------------------

Prologue -> API Documentation

https://laravel.com/api/7.x
-------------------------------------------------

Getting Started -> Installation

Для локальной разработки использовать вирт.машину Homestead.

Требуются расширения PHP
BCMath, Ctype, Fileinfo, JSON, Mbstring, OpenSSL, PDO, Tokenizer, XML.

1. Установка через Laravel Installer
composer global require laravel/installer

Composer должен быть в $PATH AppData/Roaming/Composer/vendor/bin
Посмотреть путь composer global about
Запустить laravel new /path/to/myproject

2. Установка через Composer
composer create-project --prefer-dist laravel/laravel /path/to/myproject

Настройки хоста
Webroot должен смотреть на папку public
Все конфиги в папке config
Папки storage, bootstrap/cache доступны для записи
В config/app.php настроить timezone и locale

Установить Application Key
Строка 32 символа. Ставим через Laravel installer или Composer - ключи стоят
Ставятся командой php artisan key:generate
Переименовать .env.example в .env и вбить ключ руками
Ключ нужен для шифрования sessions и encrypted data

Убрать index.php в урлах
Настройка Apache и Nginx как в мане
-------------------------------------------------

Getting Started -> Configuration

Все конфиги лежат в /config

Для управления переменными среды используется либа DotEnv
В корне есть .env.example который переименовать в .env
Создать .env.testing для запуска PHPUnit или Artisan команд с параметром --env=testing

Типы переменных среды
Все переменные string. Строка с пробелами 'в кавычках'
Все переменные среды загружаются в глобальный массив $_ENV

Еще
true,(true) - как (bool) true
false,(false) - как (bool) false
empty,(empty) - как (string) ''
null,(null) - как (null) null

Получить переменые среды
env('APP_DEBUG', false);
env - хелпер
false - значение по-умолчанию если нет ключа

Определение текущей среды
$environment = App::environment();
if (App::environment('local')) {}
if (App::environment(['local', 'staging'])) {}

Скрытие переменных среды
Когда исключение не перехвачено, и APP_DEBUG = true, можно скрыть важные переменные в config/app.php
'debug_hide' => [
  '_ENV' => ['APP_KEY', 'DB_PASSWORD'],
  '_SERVER' => ['APP_KEY', 'DB_PASSWORD'],
  '_POST' => ['password'],
];

Получить значение из конфига
config('app.timezone');
config('app.timezone', 'default');

config - хелпер
app - файл
timezone - ключ
default - значение по-умолчанию если нет ключа

Установить значение в конфиг
config(['app.timezone' => 'America']);

На проде все файлы конфигов кешируются в 1 файл командой php artisan config:cache

Выключить приложение
php artisan down
php artisan down --message='Upgrading...' --retry=60
php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16

Включить приложение
php artisan up

Шаблон заглушки
resources/views/errors/503.blade.php

Очереди задач (Queues) будут выключены
Envoyer - продвинутая выключалка приложения
-------------------------------------------------

Getting Started -> Directory Structure

Папка Root

App - код приложения.
Bootstrap - начальная загрузка app.php, папка cache кешей.
Config - конфиги.
Database - миграции, посевы, sql базы.
Public - главный index.php, assets (картинки, js, css).
Resources - сырые less, sass, js.
Routes - роуты web.php, api.php, console.php, channels.php.
Storage - шаблоны blade, файлы сессий, кешей, логи, сгенерированные файлы.
Tests - тесты PHPUnit.
Vendor - зависимости Composer.

Папка App

Broadcasting - вещание. make:channel.
Console - API консольных Artisan команд, задач по расписанию. make:command.
Events - события. event:generate, make:event.
Exceptions - исключения.
Http - API для веб контроллеров, мидлваре, обработка запросов.
Jobs - задачи в очереди. make:job.
Listeners - обработка событий. event:generate, make:listener.
Mail - почта. make:mail.
Notifications - уведомления. make:notification.
Policies - политики. make:policy.
Providers - СП.
Rules - валидация. make:rule.
-------------------------------------------------

Getting Started -> Homestead

Vagrant + VirtualBox.
Для Windows в BIOS включить hardware virtualization (VT-x).

Состав
Ubuntu, Git, Nginx, PHP, MySQL, PostgreSQL, Redis, Memcached, Node, MariaDB, Sqlite3, Composer, Bower, Grunt, Gulp, Xdebug, Apache, Elasticsearch, Gearman, RabbitMQ, Neo4j, Cassandra, MongoDB, Ngrok итд.

Установка как Vagrant box
vagrant box add laravel/homestead
или
vagrant init laravel/homestead
vagrant up

Установка из репозитария
git clone https://github.com/laravel/homestead.git ~/Homestead
bash init.sh/init.bat
это создаст homestead.yaml

Настройка homestead.yaml
После изменения, применить
vagrant reload --provision
или
vagrant provision

провайдер
provider: virtualbox

монтируем проекты
folders:

  - map: C:/Users/project1
  to: /home/vagrant/project1

  - map: C:/Users/project2
  to: /home/vagrant/project2

настраиваем nginx
sites:

  - map: homestead1.loc
  to: /home/vagrant/project1/public
  php: '7.4' версия php

  - map: homestead2.loc
  to: /home/vagrant/project2/public

включить/выключить сервисы
services:

    - enabled:
        - 'postgresql@12-main'

    - disabled:
        - 'mysql'

поставить дополнительное ПО
- cassandra: true
- gearman: true
- mysql8: true

делать бекапы БД при выключении
backup: true

включить cron
schedule: true


Добавить хост C:/Windows/System32/drivers/etc/hosts
192.168.10.10 homestead1.loc
192.168.10.10 homestead2.loc

Прописать cron в /etc/cron.d

Включение/выключение Vargant
vagrant up
vagrant destroy

Установка Homestead через Composer
composer require laravel/homestead --dev
vendor\\bin\\homestead make

Настройка Mailhog для локальной отправки писем.

Расшарить проект клиенту
vagrant ssh
share homestead1.loc

Установить версию PHP для CLI
php74

Отладка xDebug
Закладки https://www.jetbrains.com/phpstorm/marklets
Настройки /etc/php/7.x/fpm/conf.d/20-xdebug.ini

Профилирование Blackfire

Профилирование XHGui
sites:
  xhgui: 'true'


Обновление Homestead
vagrant destroy
git fetch
git pull origin release
vagrant box update
bash init.sh/init.bat
vagrant up
-------------------------------------------------

Getting Started -> Valet

Виртуальная машина для Homebrew и MacOs
-------------------------------------------------

Getting Started -> Deployment

Выкладка в продакшен

1. Настроить Nginx как в мане.

2. Оптимизация автозагрузки composer. composer.lock положить в гит.
composer install --optimize-autoloader --no-dev

3. Оптимизация конфигов. Это создаст 1 файл конфига и положит в кеш.
php artisan config:cache

4. Оптимизация роутов.
php artisan route:cache

5. Оптимизация шаблонов. Это скомпилирует blade-шаблоны.
php artisan view:cache
-------------------------------------------------

Architecture Concepts -> Request Lifecycle

1. Точка входа public/index.php.
В public/index.php загружается автозагрузчик сomposer
В bootstrap/app.php создается инстанс приложения

2. Запрос передаётся в HTTP Kernel или Console Kernel, взависимости от типа запроса.
HTTP Kernel в /app/Http/Kernel.php, массив bootstrappers запускается до обработки запроса. В bootstrappers определяется обработка ошибок, логи, среда выполнения, список МВ, через которые проходит запрос.
Метод handle принимает Request (HTTP запросы) и отдаёт Response (HTTP ответы).

3. Загрузка СП. Список лежит в config/app.php в массиве providers. У СП сначала вызывается метод register, а после регистрации всех СП, вызывается метод boot. СП отвечают за загрузку всех компонентов фреймворка database, queue, validation, routing, итд.

4. Request передаётся на роут. Роут отправляет Request на другой роут, или на контроллер, запускает МВ роута.
-------------------------------------------------

Architecture Concepts -> Service Container

Сервис контейнер (СК) - это хранилище, инструмент для внедрения зависимостей. Способ подтянуть другие классы для использования. СК реализует PSR-11.

В контроллере UserController, в конструкторе, в СК, внедряем СП UserRepository, который работает с БД.

class UserController extends Controller {

  public function __construct(UserRepository $users) {
    $this->users = $users;
  }

  public function show($id) {
    $user = $this->users->find($id);
  }

}

Виды привязок СП к СК

Простая привязка

$this->app->bind('HelpSpot\API', function ($app) {
  return new \HelpSpot\API($app->make('HttpClient'));
});

$this->app - СК
в bind() передаём класс или интерфейс
в make() получим объект класса HttpClient

Привязка как синглтон 1 раз

$this->app->singleton('HelpSpot\API', function ($app) {
  return new \HelpSpot\API($app->make('HttpClient'));
});

Привязка существующего объекта

$api = new \HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\API', $api);

Привязка интерфейса и реализации

$this->app->bind(
  'App\Contracts\EventPusher', интерфейс EventPusher
  'App\Services\RedisEventPusher' реализация RedisEventPusher
);

Контекстная привязка на лету. 2 класса, 1 интерфейс, 2 реализации.

$this->app->when(PhotoController::class)
  ->needs(Filesystem::class)
  ->give(function () {
    return Storage::disk('local');
});

$this->app->when([VideoController::class, UploadController::class])
  ->needs(Filesystem::class)
  ->give(function () {
    return Storage::disk('s3');
});

Привязка примитивов

$this->app->when('App\Http\Controllers\UserController')
  ->needs('$variableName')
  ->give($value);

Привязка массива объектов

$this->app->when(ReportAggregator::class)
  ->needs('$reports')
  ->giveTagged('reports');

Привязка типизированных объектов

$this->app->when(Firewall::class)
  ->needs(Filter::class)
  ->give(function ($app) {
    return [
      $app->make(NullFilter::class),
      $app->make(ProfanityFilter::class),
      $app->make(TooLongFilter::class),
      ];
});

$this->app->when(Firewall::class)
  ->needs(Filter::class)
  ->give([
    NullFilter::class,
    ProfanityFilter::class,
    TooLongFilter::class,
]);

Вариативная зависимость

$this->app->when(ReportAggregator::class)
  ->needs(Report::class)
  ->giveTagged('reports');

Теги и категории для подмножеств связывания

Регистрация
$this->app->bind('SpeedReport', function () {});
$this->app->bind('MemoryReport', function () {});

Помечаем тегом
$this->app->tag(['SpeedReport', 'MemoryReport'], 'reports');

Привязываем пачку
$this->app->bind('ReportAggregator', function ($app) {
  return new ReportAggregator($app->tagged('reports'));
});

Расширенные привязки. Когда служба уже привязана, но требует изменения на лету.

$this->app->extend(Service::class, function ($service, $app) {
  return new DecoratedService($service);
});

Разрешение и использование класса вне СК
$api = $this->app->make('HelpSpot\API');
или
$api = resolve('HelpSpot\API');
$api = $this->app->makeWith('HelpSpot\API', ['id' => 1]);

Автоматическое внедрение
В конструктор класса таким образом можно внедрять controllers, event listeners, middleware.

События СК
Генерируются при каждом разрешении объекта. Разрешаемый объект передается в калбек, там его можно изменить.

Прослушать так

$this->app->resolving(function ($object, $app) {резолвинг объекта любого типа});
$this->app->resolving(\HelpSpot\API::class, function ($api, $app) {резолвинг объекта 'HelpSpot\API'});
-------------------------------------------------

Architecture Concepts -> Service Providers

Сервис провайдеры (СП) - лежат в config/app.php в массиве providers.
Загружаются не каждый раз, и не все, а по требованию.
Регистрация СП это добавление в массив providers.

Создать СП
php artisan make:provider RiakServiceProvider

Метод register
только привязываем что-то к СК. Не пишем роуты, прослушиватели событий итд.

В любом методе есть доступ к СК через $app.
В СП только регистрации привязки к СК.

В массивы bindings и singletons сложить привязки для регистрации
public $bindings = [];
public $singletons = [];

Метод boot
Метод вызывается как все СП будут зареганы.
В этом методе есть доступ ко всем СП.
Тут можно указать зависимости, и СК автоматических их загрузит.

Обычные СП
расширяют Illuminate\Support\ServiceProvider

Отложенные СП
расширяют \Illuminate\Contracts\Support\DeferrableProvider
имеют метод provides который возвращает массив СК
-------------------------------------------------

Architecture Concepts -> Facades

Фасад (Ф) - статический интерфейс к классам в СК. Дают краткий синтаксис.

Ф и зависимости

Фасады кратки, удобны, не требуется инжектить. Опасность фасадов в разрастании размера ответственности.

Зависимости требуется инжектить. Зависимости утолщают конструктор и дают визуальную обратную связь.

Ф и хелперы
Многие хелперы выполняют теже функции что и Ф. Между ними нет разницы.
View::make('profile'); Ф
view('profile'); хелпер

Все фасады
https://laravel.com/docs/7.x/facades#facade-class-reference
46 шт
-------------------------------------------------

Architecture Concepts -> Contracts

Контракты (К) - это набор интерфейсов, которые определяют набор СП.
Каждый К имеет реализацию.

К очередей Illuminate\Contracts\Queue\Queue
К почты Illuminate\Contracts\Mail\Mailer

К и Ф

Ф и хелперы дают использовать сервисы без разрешения из СК.

Ф не нужно декларировать в конструкторе.
К позволяют определять явные зависимости в конструкторе.

Каждый Ф имеет эквивалентный К.
К и Ф почти не отличаются.

Репоз контрактов
https://github.com/illuminate/contracts

Все контракты
https://laravel.com/docs/7.x/contracts#contract-reference
79 шт
-------------------------------------------------

The Basics -> Routing

Роуты в папке /routes.
Роуты web.php для веба, МВ группа 'web'.
Роуты api.php без состояния, МВ группа 'api'.
Все роуты в группе RouteServiceProvider.
Все роуты с префиксом /api обрабатываются автоматически.
Внутри роута не размещать логику.

HTTP методы (глаголы verb)
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

Создать роут
Route::get('foo', function () {return 'Hello';}); http://domain.loc/foo
Route::get('/user', 'UserController@index'); http://domain.loc/user

Роут на несколько методов
Route::match(['get', 'post'], '/', function () {});

Роут на любой метод
Route::any('/', function () {});

Роуты редиректов
Route::redirect('/here', '/there'); по умолчанию код 302
Route::redirect('/here', '/there', 301); свой код
Route::permanentRedirect('/here', '/there'); всегда код 301

Роуты возвращающие вью
Route::view('/welcome', 'welcome');
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

Параметры роутов
Route::get('user/{id}', function ($id) {});
Route::get('posts/{p}/comments/{c}', function ($p, $c) {});
Route::get('user/{name?}', function ($name = null) {}); для необязательных параметров

Ограничения параметров регулярками
Route::get('user/{name}', function ($name) {})->where('name', '[A-Za-z]+');
Route::get('user/{id}', function ($id) {})->where('id', '[0-9]+');
Route::get('user/{id}/{name}', function ($id, $name) {})->where(['id' => '[0-9]+', 'name' => '[A-Za-z]+']);

Ограничения параметров регулярками, на глобальном уровне
RouteServiceProvider.php:
public function boot() {
  Route::pattern('id', '[0-9]+');
  Route::pattern('name', '[A-Za-z]+');
  parent::boot();
}

Позволить косую черту / в роутах. Работает только для последнего сегмента
Route::get('search/{search}', function ($search) {})->where('search', '.*');

Именованные роуты
Route::get('user/profile', function () {})->name('profile1');
Route::get('user/{id}/profile', function ($id) {})->name('profile1');
Route::get('user/profile', 'UserProfileController@show')->name('profile1');

Создание урлов и редиректов на именованные роуты
$url = route('profile1');
$url = route('profile1', ['id' => 1]);
$url = route('profile1', ['id' => 1, 'photos' => 'yes']); сгенерит /user/1/profile?photos=yes

redirect()->route('profile1');

Группы роутов
Группировка роутов для задания им одного набора МВ или неймспейсов.
Метод Route::group

МВ для группы роутов
Route::middleware(['first', 'second'])->group(function () {
  Route::get('/', function () {});
  Route::get('user/profile', function () {});
});

Пространство имен (неймспейсы, namespaces) для группы контроллеров
Route::namespace('Admin')->group(function () {});
По умолчанию у контроллеров пространство App\Http\Controllers

Роуты субдоменов
Route::domain('{account}.myapp.com')->group(function () {
  Route::get('user/{id}', function ($account, $id) {});
});

Префиксы роутов
Например для роутов админки /admin/users, /admin/models

Route::prefix('admin')->group(function () {
  Route::get('users', function () {});
  Route::get('models', function () {});
});

Префиксы роутов /admin.users, /admin.models

Route::name('admin.')->group(function () {
  Route::get('users', function () {})->name('users');
  Route::get('models', function () {})->name('models');
});

Привязка роута и Eloquent модели
Route::get('api/users/{user}', function (App\User $user) {$user->email;}); неявная привязка (по столбцу ID). если модель не найдена то вернет 404 HTTP.

Route::get('api/posts/{post:slug}', function (App\Post $post) {$post;}); явная привязка по столбцу slug.

Route::get('api/users/{user}/posts/{post:slug}', function (User $user, Post $post) {$post;}); для связанных моделей

Задать столбец по умолчанию, отличный от ID
В модели Eloquent написать:
public function getRouteKeyName() {
  return 'slug';
}

Явная привязка роута и Eloquent модели
RouteServiceProvider.php:
public function boot() {
  parent::boot();
  Route::model('user', App\User::class);
}

Route::get('profile/{user}', function (App\User $user) {$user->email;}); явная привязка по столбцу ID. если модель не найдена то вернет 404 HTTP.

Настройка логики разрешения для привязки
public function boot() {
  parent::boot();
  Route::bind('user', function ($value) {
    return App\User::where('name', $value)->firstOrFail();
  });
}

ИЛИ

Изменить метод resolveRouteBinding в Eloquent модели
public function resolveRouteBinding($value, $field = null) {
  return $this->where('name', $value)->firstOrFail();
}

Резервные роуты
Указать роут, когда не совпал ни один роут. Обычно это 404. Его написать в конце.
Route::fallback(function () {});

Лимиты скорости на роутах
Специальное МВ throttle для ограничения скорости. Назначить на роут или группу роутов.

Route::middleware('auth:api', 'throttle:60,1')->group(function () {
  Route::get('/user', function () {});
});
60 - колво запросов
1 - минута

Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () {
  Route::get('/user', function () {});
});
rate_limit - атрибут в модели User в БД

Route::middleware('throttle:10|60,1')->group(function () {});
10 - для гостя
60 - для авторизованного

Route::middleware('auth:api', 'throttle:10|rate_limit,1')->group(function () {
  Route::get('/user', function () {});
});
10 - для гостя
rate_limit - для авторизованного

Для разных сегментов урла (default и deletes) разные ограничения
Route::middleware('auth:api')->group(function () {

  Route::middleware('throttle:60,1,default')->group(function () {
    Route::get('/servers', function () {});
  });

  Route::middleware('throttle:60,1,deletes')->group(function () {
    Route::delete('/servers/{id}', function () {});
  });
});

HTML форма
Не имеет методов PUT, PATCH, DELETE.
Когда задаём роуты с методами PUT, PATCH, DELETE, то добавить скрытое поле _method

<form>
  <input type='hidden' name='_method' value='PUT'>
  ИЛИ
  @method('PUT')
</form>

Получить текущий роут
$route = Route::current();
$name = Route::currentRouteName();
$action = Route::currentRouteAction();
if ($request->route()->named('profile')) {}

Cross-Origin Resource Sharing (CORS)
-------------------------------------------------

The Basics -> Middleware

Мидлваре (МВ) - это механизм фильтрации HTTP запросов.
Например аутентификации юзеров, чтобы пропустить дальше или редирект на страницу логина.
МВ есть для CORS, логирования.
МВ лежат в app/Http/Middleware.
МВ как серия слоёв через которые проходит HTTP запрос, до попадания в приложение.
МВ разрешаются через СК, зависимости писать в конструкторе МВ.

Создать МВ
php artisan make:middleware CheckAge

class CheckAge {
  public function handle($request, Closure $next) {

    if (условие) {
      return redirect('home'); редирект
    }

	return $next($request); пропуск далее в приложение

  }
}

Выполнение МВ ДО или ПОСЛЕ запроса

public function handle($request, Closure $next) {

  тут действия МВ будут выполняться ДО обработки запроса
  return $next($request);

}

public function handle($request, Closure $next) {

  $response = $next($request);

  тут действия МВ будут выполняться ПОСЛЕ обработки запроса
  return $response;

}

Глобальные МВ для всех запросов
в app/Http/Kernel.php в массиве $middleware

МВ для отдельных роутов

Сначала регистрация в app/Http/Kernel.php в массиве $routeMiddleware
protected $routeMiddleware = ['auth1' => \App\Http\Middleware\Authenticate::class];

Затем в роуте пишем ключ
Route::get('admin/profile', function () {})->middleware('auth1');


Установка нескольких МВ на роут
Route::get('admin/profile', function () {})->middleware('first', 'second');

В роут можно передать не ключ, а имя класса
Route::get('admin/profile', function () {})->middleware(CheckAge::class);

Назначим МВ группе роутов, но отменим для одного роута из группы
Этот метод не применим к глобальным МВ.

Route::middleware([CheckAge::class])->group(function () {
  Route::get('/', function () {});
  Route::get('admin/profile', function () {})->withoutMiddleware([CheckAge::class]);
});

Группировка много МВ под одним ключом
в app/Http/Kernel.php в массиве $middlewareGroups.
Там уже есть ключи web и api.

Группы МВ можно назначать роутам или контроллерам
Route::get('/', function () {})->middleware('web');
Route::group(['middleware' => ['web']], function () {});
Route::middleware(['web', 'subscribed'])->group(function () {});

Сортировка порядка выполнения МВ
в app/Http/Kernel.php в массиве $middlewarePriority

Передача дополнительных параметров в МВ
Передать роль $rolename в аутентификацию, чтобы проверить доступы юзера.
Дополнительные параметры передаются после аргумента $next.

public function handle($request, Closure $next, $rolename) {

  if (!$request->user()->hasRole($rolename)) {
    редирект
  }

  return $next($request);
}

Дополнительные параметры можно указать в роуте, разделяя их двоеточием
Route::put('post/{id}', function ($id) {})->middleware('middlewarename:rolename');

Оконечное МВ
МВ которое должно выполнить работу, после посылки HTTP браузеру.
Сервер должен исполнять FastCGI. Добавить МВ в роут или глобально в массив app/Http/Kernel.php.

public function terminate($request, $response) {
  тут код
}

При вызове terminate, будет новый инстанс МВ из СК. Если хотим этот же - регистрируем МВ в СК как singleton в методе register в AppServiceProvider

public function register() {
  $this->app->singleton(TerminableMiddleware::class);
}
-------------------------------------------------

The Basics -> CSRF Protection

CSRF - это Cross Site Request Forgery, подделка межсайтового запроса.
Когда запросы отправляются из левого места, а не из авторизованной админки.
CSRF токен автоматически генерируется на основе сессий и кладётся в куку и сессию.
МВ VerifyCsrfToken входит в группу 'web', проверяет токен.
CSRF отключается на тестах.

HTML форма

<form>
  @csrf
</form>

JavaScript приложения
Яваскрипт HTTP-библиотека должна аттачить токен к запросам.
Axios в resources/js/bootstrap.js, автоматически отправляет заголовок X-XSRF-TOKEN из куки с именем XSRF-TOKEN.

Исключить урлы из проверки CSRF
Обычно такие роуты исключаются из МВ группы 'web' в RouteServiceProvider в routes/web.php.
Можно исключить, добавив такие роуты в массив $except в МВ VerifyCsrfToken.

protected $except = [
  'stripe/*',
  'http://example.com/foo/bar',
  'http://example.com/foo/*'
];

X-CSRF-TOKEN
Дополнительная защита
<meta name='csrf-token' content='{{ csrf_token() }}'>

При использовании jQuery для AJAX запросов, руками добавлять заголовок
$.ajaxSetup({
  headers: {
    'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content');
  }
});

X-XSRF-TOKEN
CSRF токен сохраняется в куке XSRF-TOKEN.
Axios и Angular автоматически помещают своё значение в заголовок X-XSRF-TOKEN.
-------------------------------------------------

The Basics -> Controllers

Логику писать в контроллерах.
Контроллеры это группа связанных запросов.
Лежат в app/Http/Controllers.
Если нет extends Controller, то нет методов МВ, validate, dispatch.

Неймспейсы
Если контроллер такой App\Http\Controllers\Photos\AdminController
То роут такой Route::get('foo', 'Photos\AdminController@method');
Указать только что после App\Http\Controllers до папки Controllers.

Контроллер
class UserController extends Controller {
  public function show($id) {}
}

Роут
Route::get('user/{id}', 'UserController@show');

Контроллер с 1 методом
class UserController extends Controller {
  public function __invoke($id) {}
}

Роут
Route::get('user/{id}', 'UserController');

Создать контроллер с 1 методом
php artisan make:controller UserController --invokable


МВ на Контроллер

Назначить в роуте
Route::get('profile', 'UserController@show')->middleware('auth');

Лучше назначить в конструкторе Контроллера
public function __construct() {
  $this->middleware('auth');
  $this->middleware('log')->only('index');
  $this->middleware('subscribed')->except('store');
}

В конструкторе можно создать МВ на лету, не создавая отдельный класс МВ
$this->middleware(function ($request, $next) {
  return $next($request);
});


Ресурсный контроллер
Например контроллер для обработки запросов связанных с фотко.

Создать
php artisan make:controller PhotoController --resource

Будет сгенерен app/Http/Controllers/PhotoController.php с методами CRUD

Роут
Route::resource('photos', 'PhotoController');

Будут сгенерены роуты CRUD (index, create, store, show, edit, update, destroy).

Роуты пачкой
Route::resources([
  'photos' => 'PhotoController',
  'posts' => 'PostController'
]);

Ресурсный контроллер с привязкой к модели
php artisan make:controller PhotoController --resource --model=Photo

Частичные роуты для ресурсных контроллеров. Указать только нужные методы контроллера.

Route::resource('photos', 'PhotoController')->only(['index', 'show']);
Route::resource('photos', 'PhotoController')->except(['create', 'store', 'update', 'destroy']);

Роуты для ресурсных Контроллеров API. не будет роутов create и edit.
Route::apiResource('photos', 'PhotoController');

Роуты пачкой
Route::apiResources([
  'photos' => 'PhotoController',
  'posts' => 'PostController'
]);

Создать ресурсный контроллер для API
не будет роутов create и edit.

php artisan make:controller API/PhotoController --api

Роуты для вложенных ресурсов. фото + комменты
Route::resource('photos.comments', 'PhotoCommentController'); /photos/{photo}/comments/{comment}

Роуты для ресурсов вложенных неглубоко
В урле не нужен ID родителя а только ID потомка
Route::resource('photos.comments', 'CommentController')->shallow();
Будут созданы методы index, create, store, show, edit, update, destroy.

Именованные роуты для ресурсных Контроллеров
Route::resource('photos', 'PhotoController')->names(['create' => 'photos.build']);

Именованные роуты для ресурсных Контроллеров, с параметрами
Route::resource('users', 'AdminUserController')->parameters(['users' => 'admin_user']); /users/{admin_user}

Область видимости роутов для ресурсных Контроллеров
Route::resource('users.posts', PostsController::class)->scoped();
Route::resource('users.posts', PostsController::class)->scoped(['post' => 'slug']);

Локализация ресурсных урлов с English на другой язык
методы index, create, store, show, edit, update, destroy

AppServiceProvider.php:
public function boot() {
  Route::resourceVerbs([
    'create' => 'crear',
    'edit' => 'editar'
  ]);
}

Регаем роут
Route::resource('fotos', 'PhotoController');

Это даст урлы
/fotos/crear
/fotos/{foto}/editar

Дополнительные контроллеры ресурсов
Когда хотим добавить еще роутов на ресурсный контроллер, за пределами набора роутов по умолчанию. Их лучше объявлять до вызова Route::resource. В таком порядке:
Route::get('photos/popular', 'PhotoController@method');
Route::resource('photos', 'PhotoController');

Внедрение зависимостей в Контроллер

В конструктор
СК используется для разрешения всех Контроллеров, любые зависимости можно в конструктор.
public function __construct(UserRepository $users) {
  $this->users = $users;
}

В другие методы
public function store(Request $request, $id) {
  $name = $request->name;
}

Роут
Route::put('user/{id}', 'UserController@update');

Кеширование роутов
Роуты на основе замыканий (Closure) не кешируются. Все роуты конвертить в классы. Кеширование даёт прибавку в скорости в 100 раз.

Кеширование роутов
php artisan route:cache

Очистить кеш роутов
php artisan route:clear
-------------------------------------------------

The Basics -> HTTP Requests

Получить объект Запроса в контроллере
class UserController extends Controller {
  public function store(Request $request) {}
}

Получить объект Запроса в роуте
Route::get('/', function (Request $request) {});


Роут с параметром
Route::put('user/{id}', 'UserController@update');

Метод контроллера с параметром
public function update(Request $request, $id) {}


Путь
$request->path();
для http://domain.com/foo/bar вернет foo/bar

Проверка на путь
Паттерн * на совпадение
if ($request->is('admin/*')) {}

Урл
$request->url(); без query string
$request->fullUrl(); с query string

Метод
$request->method();
if ($request->isMethod('post')) {}

Запросы и Ответы стандарта PSR-7

Поставить либы
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7

Получить Запрос стандарта PSR-7
use Psr\Http\Message\ServerRequestInterface;
Route::get('/', function (ServerRequestInterface $request) {});

Обрезка и нормализация ввода

В глобальном стеке МВ стоят TrimStrings и ConvertEmptyStringsToNull в App\Http\Kernel.
Обрезают пробелы строк, пустые строки выставляют в NULL.
Можно убрать это, закоментив классы в App\Http\Kernel в массиве $middleware.

Данные
$request->all(); все данные
$request->input('name'); неважно гет или пост или query string
$request->input('name', 'defaultvalue');
$request->input();

Доступ к массивам
$request->input('products.0.name');
$request->input('products.*.name');

Параметры из Query String
$request->query('name');
$request->query('name', 'defaultvalue');
$request->query();

Динамические свойства
$request->name;
сначала ищет в теле запроса, потом в параметрах роута

Получить JSON
Для запросов Content-Type application/json
$request->input('user.name');

Получить boolean на чекбоксы и радиобуттоны
$request->boolean('archived');
вернёт true для 1, "1", true, "true", "on", "yes"

Получить части данных
$request->only(['username', 'password']);
$request->only('username', 'password');
$request->except(['credit_card']);
$request->except('credit_card');

Проверка на наличие
if ($request->has('name')) {}
if ($request->has(['name', 'email'])) {} должны быть все
if ($request->hasAny(['name', 'email'])) {} должен быть любой из
if ($request->filled('name')) {} есть и не равно пустоте
if ($request->missing('name')) {} нет

Старый ввод в форму

Ввод в форму сохраняется после сабмита, в сессию, чтобы заполнить опять поля формы, если на форме ошибки.
Это автоматический механизм, если используем встроенную валидацию Validation.

Сохранение текущего ввода

$request->flash();
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');

Сохранение текущего ввода и редирект

redirect('form')->withInput();
redirect('form')->withInput(
  $request->except('password')
);

Получить старый ввод
$request->old('username');

Вставка старого ввода на форму
хелпер old()
<input type='text' name='username' value='{{ old('username') }}'>

Получить куки
Куки зашифрованы и подписаны кодом аутентификации.
Их не может изменить клиент.

$request->cookie('name');
Cookie::get('name'); используя Ф

Добавить куки
response('HelloWorld')->cookie('name', 'value', $minutes);
response('HelloWorld')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);

Добавить куки в очередь
Куки будут прикреплены к Ответу перед отправкой в ​​браузер.
Cookie::queue(Cookie::make('name', 'value', $minutes));
Cookie::queue('name', 'value', $minutes);

Создание куки
$cookie = cookie('name', 'value', $minutes);
response('Hello World')->cookie($cookie); прикрепляем к ответу

Удалить истёкшую куку
Cookie::queue(Cookie::forget('name'));

Прикрепить к Ответу истёкшую куку
$cookie = Cookie::forget('name');
return response('Hello World')->withCookie($cookie);

Получить загруженные файлы
$request->file('photo');
$request->photo;

Проверка на наличие файла
if ($request->hasFile('photo')) {}

Проверка что файл корректно загружен
if ($request->file('photo')->isValid()) {}

Путь и расширение файла
$request->photo->path();
$request->photo->extension(); угадывает расширение по контенту

Сохранение загруженных файлов
Уникальное имя файла генерится автоматически.

$request->photo->store('pathtofolder'); переносит файл в папку
$request->photo->store('pathtofolder', 'dickname'); укажем диск

Задать имя файла
$request->photo->storeAs('pathtofolder', 'filename.jpg');
$request->photo->storeAs('pathtofolder', 'filename.jpg', 'dickname');

Настройка доверенных прокси для балансировщиков нагрузки типа AWS Elastic Load
МВ TrustProxies массив прокси в $proxies.
protected $proxies = ['192.168.1.1', '192.168.1.2'];
protected $headers = Request::HEADER_X_FORWARDED_AWS_ELB;

Для других балансировщиков нагрузки типа Amazon AWS где нет IP адресов
protected $proxies = '*'; доверять всем прокси
-------------------------------------------------

The Basics -> HTTP Responses

Роуты и контроллеры возвращают Ответ в браузер.
Возвращается полный инстанс Ответа Response, или вьюха.
Полный Response позволяет задать свои коды ответа и заголовки.
Хелпер Response.

Route::get('/', function () {return 'Hello World';}); строка
Route::get('/', function () {return [1, 2, 3];}); массив как json

Route::get('home', function () {

  return response('Hello World', 200)
    ->header('Content-Type', 'text/plain');

  return response($content)
    ->header('Content-Type', $type)
    ->header('X-Header-One', 'Header Value')
    ->header('X-Header-Two', 'Header Value');

  return response($content)
    ->withHeaders([
      'Content-Type' => $type,
      'X-Header-One' => 'Header Value',
      'X-Header-Two' => 'Header Value'
    ]);

});

Кеширование МВ Cache-Control
Можно кеширование сразу группы роутов.
Если задан etag, то MD5 хеш содержимого будет автоматически установлен в ETag.

Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
  Route::get('privacy', function () {});
  Route::get('terms', function () {});
});

Прикрепление кук к Ответу

response($content)
  ->cookie('name', 'value', $minutes);

response($content)
  ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly);

Прикрепление кук к Ответу, используя Ф Cookie для установки в очередь

Cookie::queue(Cookie::make('name', 'value', $minutes));
Cookie::queue('name', 'value', $minutes);

Шифрование кук
Куки зашифрованы и подписаны соответствующим МВ.

Защиту можно отключить, добавив куку в массив в App\Http\Middleware\EncryptCookies
protected $except = ['cookie_name'];

Редиректы

Route::get('dashboard', function () {

  return redirect('home/dashboard');

  return back()->withInput(); на предыдущую страницу

  return redirect()->route('login'); на именованный роут

  return redirect()->route('profile', ['id' => 1]); на именованный роут с параметром. выдаст profile/{id}

});

Заполнение параметров роута моделями Eloquent
редирект на роут с ID юзера и привязкой к модели $user. выдаст profile/{id}

redirect()->route('profile', [$user]);

Указать свой столбик вместо ID
redirect()->route('profile/{id:slug}', [$user]);

В модели Eloquent написать
public function getRouteKey() {
  return $this->slug;
}

Редирект на метод контроллера
redirect()->action('HomeController@index');
redirect()->action('UserController@profile', ['id' => 1]);

Редирект на другой домен
redirect()->away('https://www.google.com');

Редирект со старым вводом
Редирект на новый урл, и запись данных в сессию.

Route::post('user/profile', function () {
  return redirect('dashboard')->with('message1', 'Profile updated!');
});

Потом на другой странице вывести
@if (session('message1'))
  <div class='alert alert-success'>
    {{ session('message1') }}
  </div>
@endif

Вернуть вьюху
Использовать хелпер View, если не нужно задавать заголовки и коды ответа.
response()->view('hello', $data, 200);

Вернуть JSON
Автоматически вернёт Ответ Content-Type application/json.
response()->json(['name' => 'Abigail', 'state' => 'CA']);

JSON метод можно комбинировать с колбеком
response()
  ->json(['name' => 'Abigail', 'state' => 'CA'])
  ->withCallback($request->input('callback'));

Скачать файл
Создание Ответа который заставит браузер скачать файл.

response()->download($pathToFile);
response()->download($pathToFile, $customfilename, $customheaders);
response()->download($pathToFile)->deleteFileAfterSend();

Потоковые загрузки
Отправить строковый ответ, как загружаемый ответ, без записи на диск

response()->streamDownload(function () {
  echo GitHub::api('repo')
    ->contents()
    ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');

Файловый ответ (PDF, image) без скачивания
Просто отобразит в браузере.

response()->file($pathToFile);
response()->file($pathToFile, $headers);

Макросы для Ответа
Написать макрос Ответа и аттачить его к роутам и контроллерам.

ResponseMacroServiceProvider
public function boot() {
  Response::macro('macroname1', function ($value) {
    return Response::make(strtoupper($value));
  });
}

Вызвать так
response()->macroname1('foo');
-------------------------------------------------

The Basics -> Views

Вьюхи содержат HTML код.
Вьюхи лежат в resources/views.
Хелпер View и Ф View.

Вьюха
resources/views/greeting.blade.php

<h1>Hello {{ $name }}</h1>

Вывод вьюхи

Route::get('/', function () {
  return view('greeting', ['name' => 'James']);
});

Пути до вьюх
Вьюха в resources/views/admin/profile.blade.php
Путь до папки view('admin.profile', $data);

Проверка наличия вьюхи
if (View::exists('admin.profile')) {}

Создать первую вьюху в массиве вьюх
view()->first(['custom.admin', 'admin'], $data);
или
View::first(['custom.admin', 'admin'], $data);

Передача данных во вьюху
view('greetings', $dataarray); массив
view('greeting')->with('name', 'Victoria'); поштучно

Передача данных всем вьюхам

AppServiceProvider.php
public function boot() {
  View::share('key', 'value');
}

Композиторы Вьюх - это колбеки класса или метода, которые вызываются когда рендерится вьюха.
Когда нужно вставлять данные при каждом рендеринге вьюхи.
Композиторы лежат в app/Http/View/Composers.

Композитор

class ViewServiceProvider extends ServiceProvider {

  public function boot() {
    View::composer('profile', 'App\Http\View\Composers\ProfileComposer'); на основе класса
    View::composer('dashboard', function ($view) {}); на основе замыкания
  }

}

Добавить этот СП в config/app.php в массив providers.

class ProfileComposer {
  public function compose(View $view) {
    $view->with('count', $this->users->count());
  }
}

Метод ProfileComposer@compose будет исполняться при рендере вьюхи profile.

Композиторы разрешаются через СК, можно указать любые зависимости в конструкторе Композитора.

Прикрепить композитор к нескольким вьюхам
View::composer(['profile', 'dashboard'], 'App\Http\View\Composers\MyViewComposer');

Прикрепить композитор ко всем вьюхам
View::composer('*', function ($view) {});


Создатели Вьюх - похожи на композиторов вьюх.

Композиторы исполняются после отображения вьюхи.
Создатели исполняются после создания вьюхи.

Создать
View::creator('profile', 'App\Http\View\Creators\ProfileCreator');

Оптимизация
Вьюхи компилируются по требованию, когда происходит Запрос.
Если скомпилированная версия есть, покажет ее. Иначе скомпилирует.

Скомпилировать все вьюхи
php artisan view:cache

Очистить кеш скомпилированных вьюх
php artisan view:clear
-------------------------------------------------

The Basics -> URL Generation

Генерация урлов для ссылок в шаблонах, ответах API, редиректов.
Хелпер Url.
Ф URL.

Создать урл
$post = App\Post::find(1);
url('/posts/{$post->id}'); выдаст http://domain.com/posts/1

Текущий урл
url()->current(); без query string
url()->full(); с query string
url()->previous(); предыдущий урл

Текущий урл через Ф URL
URL::current();
URL::full();
URL::previous();

Урлы на именованные роуты
Хелпер Route.

Роут
Route::get('/post/{post}', function () {})->name('post.show');

Урл
route('post.show', ['post' => 1]); http://example.com/post/1

Урл на основе модели Eloquent по ID
route('post.show', ['post' => $post]);

Роут на основе модели Eloquent по ID с дополнительными параметрами

Route::get('/post/{p}/comment/{c}', function () {})->name('comment.show');

route('comment.show', ['p' => 1, 'c' => 3]); http://example.com/post/1/comment/3

Подписанные урлы (с хешем) на именованные роуты
URL::signedRoute('unsubscribe', ['user' => 1]);

Подписанные временые урлы (с хешем) на именованные роуты
URL::temporarySignedRoute(
  'unsubscribe', now()->addMinutes(30), ['user' => 1]
);

Проверка подписанных урлов

Route::get('/unsubscribe/{user}', function (Request $request) {
  if (! $request->hasValidSignature()) {
    abort(401);
  }
})->name('unsubscribe');

Проверку подписанных урлов через МВ

Регистрируем МВ
$routeMiddleware = ['signed' => \Illuminate\Routing\Middleware\ValidateSignature::class];

Аттачим к роуту
Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed');
если проверка не прошла то вернет 403

Урлы на методы Контроллера
action('HomeController@index');
action([HomeController::class, 'index']);
action('UserController@profile', ['id' => 1]);

Глобальные параметры для роутов
Например параметр locale

Route::get('/{locale}/posts', function () {})->name('post.index');

Чтобы не передавать locale в хелпер Route, а указать его в МВ

public function handle($request, Closure $next) {
  URL::defaults(['locale' => $request->user()->locale]);
}
-------------------------------------------------

The Basics -> HTTP Session

HTTP приложения не сохраняют состояние между запросами.
Сессии обеспечивают это сохранение.
Конфиг config/session.php
Можно свои драйверы сессий.

Драйверы (хранилища сессий. т.е. данных)

file (по умолчанию) - в storage/framework/sessions
cookie - в зашифрованных куках
database - в базе
memcached
redis
array - хранятся в php массиве и не сохраняются (этот драйвер для тестирования)

Драйвер database

Таблица
Schema::create('sessions', function ($table) {
  $table->string('id')->unique();
  $table->foreignId('user_id')->nullable();
  $table->string('ip_address', 45)->nullable();
  $table->text('user_agent')->nullable();
  $table->text('payload');
  $table->integer('last_activity');
});

Запустить миграцию
php artisan session:table
php artisan migrate

Драйвер redis
composer predis/predis
В конфиге в параметре connection указать тип соединения.


Работа с сессиями через 2 метода.
Хелпер Session, объект Запроса Request. Они не отличаются.

Получить данные через Request

public function show(Request $request, $id) {

  $value = $request->session()->get('key');

  $value = $request->session()->get('key', 'defaultvalue'); если ключа нет вернет defaultvalue

  $value = $request->session()->get('key', function () {
    return 'defaultvalue'; через замыкание чтобы вернуть что-то, исходя из логики написанной тут в функции
  });

}

Получить данные через Session

Route::get('home', function () {

  $value = session('key'); получить

  $value = session('key', 'defaultvalue');

  session(['key' => 'value']); сохранить

});

Получить все данные
$request->session()->all();

Проверка наличия данных
if ($request->session()->has('users')) {} данные есть, и не NULL
if ($request->session()->exists('users')) {} ключ есть, даже если данные NULL

Сохранить в сессию
$request->session()->put('key', 'value'); Request
session(['key' => 'value']); хелпер

Сохранить массив
$request->session()->push('user.teams', 'developers');
добавит в массив user.teams значение 'developers'

Получить и удалить данные
$request->session()->pull('key', 'defaultvalue');

Сохранить в сессию до следующего запроса
$request->session()->flash('status', 'Temporary');

Сохранить в сессию для нескольких запросов
$request->session()->reflash(); пересохранит данные дальше на следующий запрос
$request->session()->keep(['username', 'email']); сохранит только определенные данные дальше на следующий запрос

Удалить данные
$request->session()->forget('key');
$request->session()->forget(['key1', 'key2']);
$request->session()->flush(); удалит всё

Пересоздать Session ID
Для предотвращения атаки session fixation.
Если используем LoginController, то пересоздание Session ID автоматически.

Пересоздать Session ID вручную
$request->session()->regenerate();

Блокировка сессии
В пределах 1 сеанса не допускать паралельной записи в сессию с разных мест.

Для драйверов atomic locks
memcached, dynamodb, redis, database.

На роуты блокировку

Route::post('/profile', function () {})->block($lockSeconds = 10, $waitSeconds = 10)

Route::post('/order', function () {})->block($lockSeconds = 10, $waitSeconds = 10)

Запросы к роутам будут строго последовательны.
$lockSeconds - максимальная длительность блокировки.
$waitSeconds - сколько секунд ждать, после попытки получить блокировку.
-------------------------------------------------

The Basics -> Validation

Базовый класс ValidatesRequests.
Метод validate в классе Illuminate\Http\Request.
Если валидация не прошла, будет исключение и сформирован Ответ.
Для html формы редирект, для AJAX ответ JSON массив.
Ф Validator.


public function store(Request $request) {

  правила валидации через разделитель |
  $validatedData = $request->validate([
    'title' => 'required|unique:posts|max:255'
  ]);

  правила валидации массивом
  $validatedData = $request->validate([
    'title' => ['required', 'unique:posts', 'max:255']
  ]);

  сохранить все сообщения об ошибках в именованном пакете ошибок
  $validatedData = $request->validateWithBag('post', [
    'title' => ['required', 'unique:posts', 'max:255']
  ]);

  bail остановит на первом правиле которое не прошло. остальные не проверяются. порядок строго как записано
  $request->validate([
    'title' => 'bail|required|unique:posts|max:255',
  ]);

  для вложенных полей
  $request->validate([
    'author.name' => 'required',
    'author.description' => 'required',
]);

  тут далее код после валидации
}

Отображение ошибок
Если валидация не прошла, то редирект назад и сохранение ошибок в Flash Session (FS).
Ошибки в $errors инстанса Illuminate\Support\MessageBag.
$errors связана с вьюхами через МВ ShareErrorsFromSession, доступна в вьюхах.

Все ошибки
@if ($errors->any())
  @foreach ($errors->all() as $error)
    {{ $error }}
  @endforeach
@endif

Ошибка для поля
@error('title')
  {{ $message }}
@enderror

Необязательные поля
МВ TrimStrings и ConvertEmptyStringsToNull всегда включены в классе App\Http\Kernel

Правило nullable
publish_at может быть null или корректной датой

$request->validate([
  'publish_at' => 'nullable|date',
]);

AJAX запросы
Метод validate отдаст массив JSON с ошибками и кодом ответа 422.

Форма Запроса - это отдельный класс с правилами валидации.
Форма Запроса запускается ДО запуска метода Контроллера store. В остальном всё также.
Если валидация не прошла, то редирект назад или массив JSON с кодом 422, сохранение ошибок во FS.

Создать
php artisan make:request StoreBlogPost
будет создан класс в app/Http/Requests

Добавим правила
public function rules() {
  return [
    'title' => 'required|unique:posts|max:255'
  ];
  тут добавить любые зависимости, разрешается через СК
}

Добавляем Форму Запроса в метод сохранения данных в Контроллер
public function store(StoreBlogPost $request) {

  тут валидация уже прошла
  $validated = $request->validated(); получим валидированные данные
}

Хук after
В классе Формы Запроса в методе withValidator.
Он получает инстанс Validator со всеми методами, до валидации правил.

public function withValidator($validator) {
  $validator->after(function ($validator) {

    if ($this->somethingElseIsInvalid()) {
      $validator->errors()->add('field', 'Something is wrong with this field!');
    }

  });
}

Метод authorize
Авторизация Формы Запросов. Добавить логику проверки что авторизованный юзер имеет право на действия с ресурсами.

public function authorize() {

  $comment = Comment::find($this->route('comment'));

  если вернулся false то вернется код HTTP 403 и метод Контроллера не будет выполнен
  return $comment && $this->user()->can('update', $comment);

  тут добавить любые зависимости, ибо разрешается через СК
}

Route::post('comment/{comment}');

Метод messages
Настройка сообщений об ошибках Формы Запросов.

public function messages() {
  return [
    'title.required' => 'A title is required :title1', title поле, required правило валидации, сама мессага об ошибке, :title1 заполнитель
  ];
}

Заполнители полей

public function attributes() {
  return [
    'title1' => 'Заголовок',
  ];
}

Подготовка данных для проверки
Очистить, подготовить, изменить данные перед валидацией.

protected function prepareForValidation() {
  $this->merge([
    'slug' => Str::slug($this->slug),
  ]);
}

Создание валидатора вручную
Можно не использовать метод validate, а создать инстанс валидатора, через Ф Validator.

public function store(Request $request) {

  передаем данные и правила валидации
  $validator = Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
  ]);

  проверяем
  if ($validator->fails()) {
    return redirect('post/create')
      ->withErrors($validator) кладем ошибки во FS. метод принимает $validator, MessageBag, массив
      ->withInput();
  }
}

Автоматический редирект на вручную созданном валидаторе

Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255'
])->validate(); validate и даёт редирект

Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255'
])->validateWithBag('post'); validateWithBag сохранит ошибки в именованный пакет ошибок

Именованные пакеты ошибок
Когда много форм на 1 странице.
Разложить ошибки на подмассивы каждый для своей формы.

redirect('register')->withErrors($validator, 'bagname1');

Получить доступ к пакету
{{ $errors->bagname1->first('email') }}

Добавление хуков
После валидации хук after.
Позволяет дописать следующую проверку или добавить сообщения об ошибках в массив.

$validator->after(function ($validator) {
  if ($this->somethingElseIsInvalid()) {
    $validator->errors()->add('field', 'Something is wrong with this field!');
  }
});

Работа с сообщениями об ошибках

После вызова инстанса Validator метода errors, получаем инстанс MessageBag.
MessageBag содержит много методов для работы с ошибками.
$errors доступна во вьюхах и является инстансом MessageBag.

Получить 1е сообщение об ошибках для Поля
Потому что ошибок может быть несколько для одного поля.

$errors = $validator->errors();
$errors->first('email');

Получить все сообщения об ошибках, для Поля
foreach ($errors->get('email') as $message) {}

Получить все сообщения об ошибках, для Поля которое является массивом
foreach ($errors->get('emails.*') as $message) {}

Получить все сообщения об ошибках, для всех Полей
foreach ($errors->all() as $message) {}

Проверка на наличие сообщениЙ для Поля
if ($errors->has('email')) {}

Изменение сообщений

Заполнитель :attribute будет заменен именем Поля
$messages = ['required' => 'The :attribute field is required.'];
$validator = Validator::make($input, $rules, $messages);

Другие заполнители
$messages = [
  'same' => 'The :attribute and :other must match.',
  'size' => 'The :attribute must be exactly :size.',
  'between' => 'The :attribute value :input is not between :min - :max.',
  'in' => 'The :attribute must be one of the following types: :values',
];

Установка сообщения для поля
$messages = [

  Формат "имя.правило"
  'email.required' => 'We need to know your e-mail address'

];

Установка сообщения в языковых файлах
В языковой файл resources/lang/xx/validation.php добавить сообщение в массив custom

'custom' => [
  'email' => [
    'required' => 'We need to know your e-mail address'
  ]
];

Установка заполнителей в языковых файлах
В языковой файл resources/lang/xx/validation.php добавить заполнители в массив attributes

'attributes' => [
  'email' => 'email address'
];

или

$customAttributes = ['email' => 'email address'];
$validator = Validator::make($input, $rules, $messages, $customAttributes);

Установка Значений в языковых файлах

$request->validate([

  credit_card_number обязателен если payment_type установлен в cc
  'credit_card_number' => 'required_if:payment_type,cc',
]);


Заполнитель для cc
В языковой файл resources/lang/xx/validation.php добавить в массив values

'values' => [
  'payment_type' => [
    'cc' => 'credit card'
  ],
];

Правила валидации

accepted - yes, on, 1, true
active_url - A, AAAA запись dns_get_record
after:date - после даты N
after_or_equal:date - после или равно дате N
alpha - только буквы
alpha_dash - букво-цифры, знаки - и _
alpha_num - букво-цифры
array - PHP array

bail - остановка валидации после первой же ошибки
before:date - до даты N
before_or_equal:date - до или равно дате N
between:min,max -
boolean - true, false, 1, 0, "1", "0"

confirmed - совпадения для двух полей password и password_confirmation

date - должно быть датой
date_equals:date - должно быть равно дате N
date_format:format - дата должна быть нужного формата
different:field - поле должно иметь другое значение, чем поле field
digits:value - должно быть числовым
digits_between:min,max - должно быть числовым и от min до max
dimensions:min_width,max_width,min_height,max_height,width,height,ratio - файл должен быть картинкой с заданными параметрами. есть метод Rule::dimensions
distinct - массив без дублей значений

email - должно быть почтой. email:rfc,dns - валидаторы RFCValidation и DNSCheckValidation. всего 5 валидаторов
ends_with:foo,bar - должно заканчиваться одним из значений
exclude_if:anotherfield,value - поле будет исключено из данных Запроса, если поле anotherfield равно value
exclude_unless:anotherfield,value - поле будет исключено из данных Запроса, если поле anotherfield НЕравно value
exists:table[,column] - поле должно существовать в таблице БД. Можно указать свой столбец. Можно указать тип соединения. Можно указать Eloquent модель. Есть метод Rule::exists

file - поле должно быть успешно загруженным файлом
filled - поле не должно быть пустым, если оно присутствует

gt:field - поле должно быть больше чем поле field
gte:field - поле должно быть больше или равно чем поле field

image - поле должно быть картинкой jpeg, png, bmp, gif, svg, webp
in:foo,bar - поле должно быть одним из значений. Есть метод Rule::in
in_array:anotherfield.* - поле должно существовать в значениях другого поля
integer - целое число
ip - IP адрес
ipv4 - IPv4 адрес
ipv6 - IPv6 адрес

json - JSON строка

lt:field - поле должно быть меньше поля field
lte:field - поле должно быть меньше или равно полю field

max:value - поле должно быть меньше или равно значению value
mimetypes:image/png,video/mpeg - файл должен быть MIME типом. угадывание по контенту внутри файла
mimes:png,mpeg - файл должен быть MIME типом. угадывание по контенту внутри файла
min:value - поле должно быть равно value

not_in:foo,bar - поле НЕдолжно быть одним из значений. Есть метод Rule::notIn
not_regex:pattern - поле не должно совпадать регулярке. под капотом preg_match. Если внутри будет | то правила валидации указывать массивом
nullable - поле может быть NULL
numeric - поле должно быть цифровым

password - поле должно быть аутентификационным паролем юзера
present - поле должно быть во входных данных и оно не пустое

regex:pattern - поле должно совпадать регулярке. под капотом preg_match. Если внутри будет | то правила валидации указывать массивом

required - поле должно быть во входных данных и оно не пустое (не NULL, '', [])

required_if:anotherfield,value - поле должно быть во входных данных и оно не пустое, если поле anotherfield равно значению value. Есть метод Rule::requiredIf

required_unless:anotherfield,value - поле должно быть во входных данных и оно не пустое, если поле anotherfield НЕравно значению value.

required_with:foo,bar - поле должно быть во входных данных и оно не пустое, если присутствует любое из других указанных полей

required_with_all:foo,bar -
поле должно быть во входных данных и оно не пустое, если присутствуют ВСЕ другие указанные поля

required_without:foo,bar - поле должно быть во входных данных и оно не пустое, если отсутствует любое из других указанных полей

required_without_all:foo,bar - поле должно быть во входных данных и оно не пустое, если отсутствуют ВСЕ другие указанные поля

same:field - поле должно быть равно полю field

size:value - поле должно иметь указанный размер. для строк это колво букв. для чисел это число. для массива это колво элементов. для файлов это размер в Кб.

starts_with:foo,bar - поле должно начинаться с одного из заданных значений

string - поле должно быть строкой

sometimes - если поле есть в выходных данных

timezone - поле должно быть таймзоной из php timezone_identifiers_list

unique:table,column,except,idColumn - поле не должно существовать в БД. можно указать Eloquent модель. можно указать тип соединения. есть метод Rule::unique

url - поле должно быть урлом

uuid - поле должно быть валидным UUID по RFC 4122


Условное добавление правил валидации

Пропуск валидации для поля, когда другие поля имеют значения

Метод exclude_if

Validator::make($data, [
  'has_appointment' => 'required|bool',
  'appointment_date' => 'exclude_if:has_appointment,false|required|date',
  'doctor_name' => 'exclude_if:has_appointment,false|required|string',
]);

appointment_date и doctor_name не будут валидироваться, если поле has_appointment false


Метод exclude_unless

Validator::make($data, [
  'has_appointment' => 'required|bool',
  'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
  'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
]);

Валидация поля если оно присутствует

Validator::make($data, [
  'email' => 'sometimes|required|email',
]);

sometimes - если поле есть в выходных данных

Комплексная условная проверка

Cложные проверки. Например required для поля, если другое поле > 100.
Два поля должны иметь значение, если другое поле присутствует.

$v = Validator::make($data, [
  'email' => 'required|email',
  'games' => 'required|numeric',
]);

$v->sometimes('reason', 'required|max:500', function ($input) {
  return $input->games >= 100;
});

В sometimes передаем условно-проверяемое поле 'reason' и его правила валидации.
Если в замыкании возвращается true, то правила валидации будут добавлены.

Для нескольких полей

$v->sometimes(['reason', 'cost'], 'required', function ($input) {
  return $input->games >= 100;
});

$input - инстанс класса Illuminate\Support\Fluent, там есть доступ к вводу и файлам.


Валидация массивов

На форме массив инпутов. Валидация 1 элемента

$validator = Validator::make($request->all(), [
  'photos.profile' => 'required|image',
]);

На форме массив инпутов. Валидация всех элементов

$validator = Validator::make($request->all(), [
  'person.*.email' => 'email|unique:users',
  'person.*.first_name' => 'required_with:person.*.last_name',
]);

Задать сообщение об ошибке при проверке всех элементов массива
'custom' => [
  'person.*.email' => [
    'unique' => 'Each person must have a unique e-mail address',
  ]
];


Свои правила валидации

1. Класс Rule

php artisan make:rule Rulename1
будет в /app/Rules

Метод passes
логика проверки, возвращает true или false.

Метод message
сообщения об ошибках, хелпер trans даст локализованное сообщение об ошибке.

Прикрепляем класс
$request->validate([
  'name' => ['required', 'string', new Rulename1],
]);

2. Замыкания

Если правило валидации нужно 1 раз

$validator = Validator::make($request->all(), [
  'title' => [
    'required',
    function ($attribute, $value, $fail) {
      if ($value === 'foo') {
        $fail($attribute.' is invalid.');
      }
    },
  ],
]);

3. Расширения

Метод extend Ф Validator использовать в СП.

public function boot() {

  Validator::extend('foo', function ($attribute, $value, $parameters, $validator) {
    return $value == 'foo';
  });

  в метод extend кинем класс и метод, вместо замыкания
  Validator::extend('foo', 'FooValidator@validate');
}

Добавить массив сообщений об ошибках, заполнители в методе replacer. Вызвав его в методе boot у СП.

public function boot() {

  Validator::extend(...);

  Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) {
    return str_replace(...);
  });

}

4. Неявные Расширения

Когда поля нет или значение пустое, валидация не запускаются.

$rules = ['name' => 'unique:users,name'];
$input = ['name' => ''];
Validator::make($input, $rules)->passes(); отдаст true

Чтобы валидация запускалась на пустом поле, должно быть правило обязательности поля. Для этого использовать метод

Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {
  return $value == 'foo';
});

Неявные объекты правил

Чтобы валидация вида Объект Rule запускался на пустых полях, реализовать интерфейс
Illuminate\Contracts\Validation\ImplicitRule
-------------------------------------------------

The Basics -> Error Handling

Обработка и логирование, ошибок и исключений.

App\Exceptions\Handler

В config/app.php параметр debug - сколько ошибок показать юзеру, берет значение из APP_DEBUG в .env.
Локально APP_DEBUG = true, для продакшена false

Метод Report
Для логирования исключений и отправки в сторонние сервисы Flare, Bugsnag, Sentry.

public function report(Throwable $exception) {
  if ($exception instanceof CustomException) {свой ответ}
  parent::report($exception);
}

Контекст журнала
Дополнительная контекстная инфа типа ID юзера.
В методе context добавить свой набор. Эта инфа будет включена в логи.

protected function context() {
  return array_merge(parent::context(), [
    'foo' => 'bar'
  ]);
}

Хелпер Report
Логировать исключение, но продолжить приложение дальше, не отображая страницу ошибки.

try {
  валидация данных
} catch (Throwable $e) {
  report($e);
  return false;
}

Игнорирование исключений по типу
В массиве $dontReport сложить эти исключения. Они не будут логироваться.
Исключение 404 не логируется. Можно добавить свои типы исключений.

Метод Render
Конверт исключения в HTTP Ответ для браузера.

public function render($request, Throwable $exception) {

  проверяем тип исключения и отдаём свой Ответ
  if ($exception instanceof CustomException) {
    return response()->view('errors.custom', [], 500);
  }

  return parent::render($request, $exception);
}

Отчетные и отображаемые исключения

Можно свой класс Исключений. Все зависимости разрешаются через СК.

HTTP Исключения

Хелпер Abort поднимает исключение (HttpException) с указанным кодом ответа.
abort(404);
abort(401);
abort(403, 'кастомная мессага');
abort(500);

Свои страницы ошибок для HTTP Исключений
лежат в resources/views/errors/404.blade.php

Создать шаблоны для всех кодов ошибок
php artisan vendor:publish --tag=laravel-errors

Внутри доступна переменная $exception как инстанс HttpException
<h2>{{ $exception->getMessage() }}</h2>
-------------------------------------------------

The Basics -> Logging

Ведение логов на файлах.
На основе библиотеки Monolog.
Конфиг в config/logging.php.
По умолчанию канал stack.
Ф Log.

Имя канала
По умолчанию имя канала равно значению среды - local, production. Зададим своё.

'stack' => [
  'driver' => 'stack',
  'name' => 'channel-name', своё имя
  'channels' => ['single', 'slack']
];

Драйверы
stack, single, daily, slack, papertrail, syslog, errorlog, monolog, custom

Настройка каналов Single и Daily
Параметры bubble, permission, locking.

Настройка канала Papertrail
Параметры url, port.

Настройка канала Slack
Параметры url.

Построение логов Stacks
Драйвер stack позволяет комбинировать много каналов в один канал. Пример

'channels' => [

  'stack' => [
    'driver' => 'stack',
    'channels' => ['syslog', 'slack'] канал stack агреггирует 2 канала: syslog и slack
  ],

  'syslog' => [
    'driver' => 'syslog',
    'level' => 'debug'
  ],

  'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => 'Laravel Log',
    'emoji' => ':boom:',
    'level' => 'critical'
    ]
];

Уровень логов
level - минимальный уровень.
Все уровни: emergency, alert, critical, error, warning, notice, info, debug.

Пишем в лог
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

Все мессаги будут записаны в дефолтовый канал который указан в config/logging.php

Контекстная инфа
Передать дополнительную инфу.
Log::info('User failed to login.', ['id' => $user->id]);

Запись в нужный канал
Записать мессагу в канал отличный от канала по умолчанию.

Log::channel('slack')->info('Something happened');
Log::stack(['single', 'slack'])->info('Something happened'); в несколько каналов

Свои каналы Monolog

Создать свою реализацию FormatterInterface.
Создать каналы обработчика Monolog
Создать каналы через Фабрику
-------------------------------------------------

Frontend -> Blade Templates

Blade  - это движок PHP шаблонов, можно писать внутри PHP код.
Шаблоны компилируются в PHP, кешируются.
Вьюхи лежат в resources/views, расширение файлов .blade.php.
Шаблоны основаны на регулярных выражениях.

Создание макета (лайота)
resources/views/layouts/app.blade.php

<html>
  <head>
    <title>AppName - @yield('title')</title>
  </head>
  <body>

    @section('sidebar')
      это сайдбар
    @show

    @yield('content')

    </body>
</html>

@section - раздел
@yield - вставка раздела

Расширение макета
Дочерний шаблон который наследует лайот

resources/views/child.blade.php

@extends('layouts.app') шаблон child расширяет лайот app
@section('title', 'Page Title')
@section('sidebar') это будет добавлено к сайдбару в лайоте
  @parent
@endsection
@section('content') контент в body
@endsection

Шаблон вставляет данные в лайот через @section
В лайоте это будет отображаться через @yield

@yield('content', View::make('view.name'));
второй параметр значение по умолчанию если раздела нет

хелпер View в роутах
Route::get('blade', function () {
  return view('child');
});

Отображение данных
Hello {{ $name }} автоматически экранирует (пропускает через htmlspecialchars  для предотвращения XSS атак)
Hello {{!! $name !!}} без экранирования

Отобразить JSON
<script>
  var app = @json($array);
  var app = @json($array, JSON_PRETTY_PRINT);
</script>

@json принимает теже аргументы что и PHP json_encode

HTML Entity кодирование
Blade и хелпер E автоматически делают двойное кодирование double encode HTML entities.

Это можно отключить в AppServiceProvider

public function boot() {
  Blade::withoutDoubleEncoding();
}

Blade и JavaScript фреймворки
JS фр тоже используют конструкцию {{}} для переменных, поэтому чтобы не путать с Blade, для движка Blade нужно писать @{{}}, тогда выражение целиком будет нетронуто. Символ @ будет отброшен, а в JS фрейм придет чистый {{}}

Символ @ также используется для выхода из директив
@@json()
@json()

Директива @verbatim
Для показа js переменных в большом шаблоне
Для оборачивания HTML, чтобы внутри каждой переменной не приставлять символ @

@verbatim
  <div class="container">
    Hello {{ name }}
  </div>
@endverbatim

Операторы IF

Аналог IF(){} ELSEIF(){} ELSE{}

@if (условие)
  код
@elseif (условие)
  код
@else
  код
@endif

Аналог IF(!){}

@unless (условие)
  код
@endunless

Аналог PHP isset

@isset(условие)
  код
@endisset

Аналог PHP empty

@empty(условие)
  код
@endempty

Директивы аутентификации

@auth
  код
@endauth

@auth('admin')
  код
@endauth

@guest
  код
@endguest

@guest('admin')
  код
@endguest

Директивы проверки наличия/отсутствия контента

@hasSection('navigation')
  @yield('navigation')
@endif

@sectionMissing('navigation')
  @include('default-navigation')
@endif

Директивы переменных среды

@production
  код
@endproduction

@env('staging')
  код
@endenv

@env(['staging', 'production'])
  код
@endenv

Операторы Switch

@switch($i)

  @case(1)
    код
  @break

  @case(2)
    код
  @break

  @default
    код

@endswitch

Операторы Loops

@for ($i = 0; $i < 10; $i++)
  {{ $i }}
@endfor

@foreach ($users as $user)
  {{ $user->id }}
@endforeach

@forelse ($users as $user)
  {{ $user->name }}
@empty
  код
@endforelse

@while (true)
  код
@endwhile

Пропустить итерацию или завершить цикл

@continue
@continue(условие)

@break
@break(условие)

Переменная цикла
Внутри цикла доступна переменная $loop.
У ней есть свойства index, iteration, remaining, count, first, last, even, odd, depth, parent.

Для вложенных циклов, получим доступ к $loop через parent

@foreach ($users as $user)
  @foreach ($user->posts as $post)
    @if ($loop->parent->first)
	  код
    @endif
  @endforeach
@endforeach

Комменты в коде Blade
Комменты удаляются при компилировании
{{-- коммент --}}

Вставка PHP в шаблон Blade
@php
  код
@endphp

Директива @once
Для кусков шаблона, которые нужно отрендерить 1 раз.

@once
  @push('scripts')
    <script>
      код
    </script>
  @endpush
@endonce

Формы

Поле CSRF
Скрытое поле для токена

<form>
  @csrf
</form>

Метод отправки формы
Аттрибут method не позволяет указать PUT, PATCH, DELETE, поэтому указываем в скрытом поле _method

<form method="POST">
  @method('PUT')
</form>

Вывод ошибок валидации

Директива @error проверяет, есть ли ошибки валидации, в массиве ошибок, для этого поля.
@error('title')
  {{ $message }}
@enderror

Само поле
<label>Title</label>
<input type="text" class="@error('title') is-invalid @enderror">

Вторым параметром в @error можно передать именованный пакет ошибок
@error('title', 'createpostform')
  {{ $message }}
@enderror

Компоненты
Компоненты и слоты очень похожи на sections и layouts. Компоненты бывают на базе классов, и анонимные.

Компонент на базе класса
php artisan make:component Alert

Класс компонента в App\View\Components
Вьюха компонента в resources/views/components

Ручная регистрация пакета компонентов Blade
Регистрируем класс компонента в СП

public function boot() {
  Blade::component('package-alert', AlertComponent::class);
}

Получаем тег <x-package-alert/>

Отображение компонентов во вьюхах
Компоненты начинаются со строки x-

<x-alert/>
<x-user-profile/>
<x-inputs.button/>

Пути
точка как разделитель папок

App\View\Components\Inputs\Button.php
<x-inputs.button/>

Передача данных в компоненты

Через аттрибуты HTML
<x-alert type="error" :message="$message"/>

Необходимые параметры Компонента определить в его конструкторе класса

public function __construct($type, $message) {
  $this->type = $type;
  $this->message = $message;
  $this->alertType = $alertType; стиль camelCase
}

<div class="alert">
  {{ $message }} {{ $type }}
  <x-alert alert-type="danger" /> стиль kebab-case
</div>

Из шаблона доступны не только переменные, но и сами методы класса Компонента

метод isSelected

public function isSelected($option) {
  return $option === $this->selected;
}

вызовем метод isSelected

<option {{ $isSelected($value) ? 'selected="selected"' : '' }}>
  код
</option>

Аттрибуты и слоты внутри класса
Компоненты Blade позволяют доступ к имени компонента, аттрибутам, и слоту внутри метода render в классе компонента.
Для этого метод render должен возвращать Closure.

public function render() {

  return function (array $data) {
    $data['componentName'];
    $data['attributes'];
    $data['slot'];

  return '<div>Component content</div>';

  };
}

Дополнительные зависимости
Зависимости автоматически внедряются в СК.

Управление аттрибутами
Все атрибуты, которые не являются частью конструктора компонента, будут автоматически добавлены в "пакет атрибутов" компонента в переменную $attributes

<x-alert type="error" :message="$message" class="mt-4"/>

<div {{ $attributes }}>
  <!-- Component Content -->
</div>

Дефолтовые и объединённые аттрибуты
Для аттрибутов можно указать значения по умолчанию. Можно добавить дополнительные значения в аттрибуты

{{ $attributes->merge(['class' => 'alert alert-'.$type]) }}

Фильтрация аттрибутов
Фильтровать аттрибуты с помощью метода filter.
Метод принимает Closure и возвращает true если хотим сохранить аттрибут, или false.

{{ $attributes->filter(fn ($value, $key) => $key == 'foo') }}

{{ $attributes->whereStartsWith('wire:model') }} получить все аттрибуты начинающиеся с заданной строки

{{ $attributes->whereStartsWith('wire:model')->first() }} отобразить первый аттрибут в пакете аттрибутов

Слоты
Слоты это способ закинуть контент в компонент.
Можно много слотов в разных частях компонента.
Область видимости слотов позволяет получить изнутри слота доступ к данным компонента.

компонент
<div class="alert alert-danger">
  {{ $slot }}
</div>

слот
<x-alert>
  Something went wrong!
</x-alert>


Инлайновые малые компоненты, можно вернуть из метода render.

Анонимные компоненты - это компоненты с одной вьюхой и без класса.

<x-alert/>
для resources/views/components/alert.blade.php

<x-inputs.button/>
для resources/views/components/inputs/button.blade.php

Создать инлайновый компонент
php artisan make:component Alert --inline

@include, @includeIf, @includeWhen, @includeUnless, @includeFirst - вложенные шаблоны

Blade::include('includes.input', 'input');
создать алиас шаблона для быстрого доступа к нему

@each вывод массивов
@push
@stack
@prepend
@inject

Создать свою директиву
Blade::directive('datetime', function ($expression) {
  return "<?php echo ($expression)->format('m/d/Y H:i'); ?>";
});
-------------------------------------------------

Frontend -> Localization

Ф App

Языковые файлы со строками лежат в resources/lang

resources/lang/en/messages.php
resources/lang/ru/messages.php
resources/lang/es/messages.php
итд

Разделение на регионы
называть по стандарту ISO 15897

resources/lang/en_GB/messages.php

Языковые файлы возвращают массив
return [
  'welcome' => 'Welcome to our application',
];

Локаль
Дефолтовый язык в config/app.php
App::setLocale($locale); изменить на лету

Запасной язык
Когда активный язык не содержит строку перевода

в config/app.php
'fallback_locale' => 'en'

Определить текущую локаль
$locale = App::getLocale();
if (App::isLocale('en')) {}

Создать перевод
resources/lang/es.json

{
    "I love programming.": "Me encanta programar."
}

Получить перевод
Хелпер __()

__('messages.welcome'); файл и ключ
__('I love programming.'); ключ

{{ __('messages.welcome') }}
@lang('messages.welcome') @lang не экранирует

Заполнители внутри строк перевода
регистр будет соблюдаться

'welcome' => 'Welcome, :name'
'welcome' => 'Welcome, :Name'
'welcome' => 'Welcome, :NAME'

вывод строки
__('messages.welcome', ['name' => 'dayle']);

Плюрализация
Множественное число.
В строках можно писать в формате "ед.число|множ.число"

'apples' => 'There is one apple|There are many apples',

или

'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',

И получим такую строку, передавая число
trans_choice('messages.apples', 10);

Вариант с заполнителями
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',

trans_choice('time.minutes_ago', 5, ['value' => 5]);

Пакеты с языковыми файлами
Могут поставляться уже со своими файлами, из репоза.

Эти файлы и строки можно менять, перенеся файлы сюда
resources/lang/vendor/{packagename}/{locale en,ru,etc}/messages.php
-------------------------------------------------

Frontend -> Scaffolding

Легкий старт с Bootstrap, React, Vue.
Используется NPM для установки этих пакетов.

Bootstrap и Vue в пакете
composer require laravel/ui

Далее запустить команды
php artisan ui bootstrap
php artisan ui vue
php artisan ui bootstrap --auth
php artisan ui vue --auth

Появится файл package.json.
В нём писать все js зависимости как в composer.json

Laravel Mix компилирует SASS, Less, Vue.

Установить зависимости из package.json
npm install

Запуск компиляции
npm run dev
webpack обработает инструкции из webpack.mix.js

Поставить наблюдателя для перекомпиляции
npm run watch

Либы Lodash и Axios уже стоят.

resources/sass/app.scss, public/css
resources/js/app.js, public/js

app.js загружает файл resources/js/bootstrap.js

Компоненты Vue
в папке resources/js/components
компоненты регистрируются в app.js
-------------------------------------------------

Frontend -> Compiling Assets

Laravel Mix использует Webpack для компиляции css и js ресурсов.
Laravel Mix это обёртка над Webpack.

Установка
https://nodejs.org/en/download
node -v
npm -v

В корне проекта будет файл package.json
аналог composer.json

Установка зависимостей из package.json
npm install

Запуск всех Mix задач
npm run dev

Запуск всех Mix задач и минификация
npm run production

Наблюдение за изменяемыми файлами и перекомпиляция
npm run watch

Файл настройки Webpack
webpack.mix.js

Less в CSS

mix.less('resources/less/app.less', 'public/css')
   .less('resources/less/admin.less', 'public/css/admin');

своё имя выходного файла
mix.less('resources/less/app.less', 'public/css/styles.css');

свои настройки при компиляции
mix.less('resources/less/app.less', 'public/css', {
  strictMath: true
});


Sass в CSS

mix.sass('resources/sass/app.scss', 'public/css')
   .sass('resources/sass/admin.sass', 'public/css/admin');

своё имя выходного файла
mix.sass('resources/sass/app.sass', 'public/css/styles.css');

свои настройки при компиляции
mix.sass('resources/sass/app.sass', 'public/css', {
  precision: 5
});


Stylus в CSS

mix.stylus('resources/stylus/app.styl', 'public/css');

плагин npm install rupture

mix.stylus('resources/stylus/app.styl', 'public/css', {
  use: [
    require('rupture')()
  ]
});


PostCSS

Это преобразователь CSS.
Плагин Autoprefixer добавляет нужные префиксы CSS3 для браузеров.

mix.sass('resources/sass/app.scss', 'public/css')
  .options({
    postCss: [
      require('postcss-css-variables')()
    ]
});


Чистый CSS

объединение css файлов в 1

mix.styles([
  'public/css/vendor/normalize.css',
  'public/css/vendor/videojs.css'
  ], 'public/css/all.css');


URL в CSS
Webpack оптимизирует любые вызовы url() внутри CSS.

Абсолютные пути будут исключены из оптимизации. Пример

url('/images/thing.png')
url('http://example.com/images/thing.png')

Mix и Webpack найдут файл example.png, положат его в папку public/images и затем перепишут url() в CSS

Было
.example {background: url('../images/example.png');}

Станет
.example {background: url(/images/example.png?d41d8cd98f00e);}

отключить перезапись url()

mix.sass('resources/sass/app.scss', 'public/css')
  .options({
    processCssUrls: false
});


Source Maps
Карты дают дополнительную отладочную информацию в браузере при использовании скомпилированных ресурсов.

включить
mix.js('resources/js/app.js', 'public/js')
  .sourceMaps();


Работа с JS
mix.js('resources/js/app.js', 'public/js');

это сразу даст
синтаксис ES2015, модули, компиляция .vue, минификацию

Библиотеки вендоров
Их можно убрать из объединения в 1 файл.

mix.js('resources/js/app.js', 'public/js')
  .extract(['vue']);

Все либы будут в отдельном большом файле vendor.js

public/js/manifest.js
public/js/vendor.js все либы
public/js/app.js ваш код

подключить так
<script src="/js/manifest.js"></script>
<script src="/js/vendor.js"></script>
<script src="/js/app.js"></script>


React
пропустил


Vanilla JS
минификация и объединение в 1 файл

mix.scripts([
  'public/js/admin.js',
  'public/js/dashboard.js'
  ], 'public/js/all.js');

метод mix.babel() как mix.scripts(), но просто переводит старый код в новый ES2015

Конфигурация Webpack
Mix смотрит конфиг webpack.config.js
Его менять есть 2 пути

1. Слить несколько конфигов

mix.webpackConfig({
  resolve: {
    modules: [
      path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js')
    ]
  }
});

2. Скопировать в корень node_modules/laravel-mix/setup/webpack.config.js и в package.json проставить все настройки с флагом --config чтобы ссылались на этот файл в корне

Копирование папок и файлов в другое место

mix.copy('node_modules/foo/bar.css', 'public/css/bar.css'); файлы

mix.copyDirectory('resources/img', 'public/img'); папки

Управление версиями и кеширование
К скомпилированным ресурсам добавляется метка времени или токен, чтобы скинуть кеш браузеров.

mix.js('resources/js/app.js', 'public/js')
  .version(); добавит хеш

во вьюхе подключать так (через хелпер mix()):
<script src="{{ mix('/js/app.js') }}"></script>

Файлы с контролем версий не нужны при разработке, поэтому указать только для продакшена

mix.js('resources/js/app.js', 'public/js');
if (mix.inProduction()) {
  mix.version();
}

Если скомпилированные ресурсы лежат в CDN
нужно изменить базовый URL который сгенерит хелпер mix().

В config/app.php добавить 'mix_url' => env('MIX_ASSET_URL', null).

Тогда урлы будут создаваться такие
https://cdn.example.com/js/app.js?id=1964bec

BrowserSync плагин для браузера
Автоматически мониторит изменения и перезагружает страницу браузера.

установить
npm install -g browser-sync

включить
mix.browserSync('my-domain.test');

затем
npm run watch

Переменные среды
вставка переменных сред .env в Mix
Такие переменные с префиксом MIX_

получить доступ можно так
process.env.MIX_SENTRY_DSN_PUBLIC

если переменная меняется, то перезапустить задачу
npm run watch

Уведомления ОС
Mix отправляет системные уведомления в операционнную систему, когда выполняет задачи компиляции.

Это можно отключить
mix.disableNotifications();
-------------------------------------------------

Security -> Authentication

конфиг config/auth.php
Ф Auth

Гуарды - как юзеры аутентифицируются для каждого запроса. Session
Провайдеры - как юзеры извлекаются из хранилища юзеров. Eloquent

Поле пароля от 60 до 255 символов.
Таблица юзеров users должна содержать поле remember_token для галочки "запомнить меня".

Готовый каркас аутентификации (АУ)

composer require laravel/ui
php artisan ui vue --auth

Состав
Лайот, вьюхи, роуты для страницы логина и регистрации.
Велком-страницу админки HomeController.
Контроллеры RegisterController, LoginController, ForgotPasswordController, ResetPasswordController в неймспейсе App\Http\Controllers\Auth
Вьюхи в resources/views/auth
Лайот в resources/views/layouts

Создать с нуля приложение с АУ
laravel new blog --auth

Редирект после логина

RouteServiceProvider
public const HOME = '/adminpanel';

В трейте AuthenticatesUsers или классе LoginController создать метод authenticated и вернуть что нужно.

Для логина используется поле почты.
это можно поменять

LoginController
public function username() {
  return 'username';
}

Свой гуард
в LoginController, RegisterController, ResetPasswordController прописать гуард

protected function guard() {
  return Auth::guard('guard-name');
}

Изменить набор полей, метод сохранения юзера в БД, - в классе RegisterController.
В методе create вызывается запись App\User через Eloquent.

Получить залогиненного юзера
Auth::user();
Auth::id();

Через объект Request
$request->user()

Проверка на залогин
if (Auth::check()) {}
Проверку на залогин делают через МВ и вешают на роуты и контроллеры.

МВ Auth для проверки на залогин

прикрепить к роуту
Route::get('profile', function () {})->middleware('auth');

прикрепить к контроллеру

public function __construct() {
  $this->middleware('auth');
}

Редирект незалогиненного на страницу логина
app/Http/Middleware/Authenticate.php

protected function redirectTo($request) {
  return route('login');
}

К роуту можно прикрепить также Гуард. из списка auth.php

Проверка пароля на особо важных страницах, например биллинге

МВ password.confirm присоединить к роуту

Route::get('/settings/security', function () {})->middleware(['auth', 'password.confirm']);

Потом проверка не делается 3 часа. Это можно изменить в auth.password_timeout

Контроль попыток логина

трейт ThrottlesLogins включен в контроллер LoginController
После нескольких попыток логина, бан на 1 мин

Ручная АУ юзеров

public function authenticate(Request $request) {

  $credentials = $request->only('email', 'password'); данные из формы

  проверка выборкой из БД. пароль уже хеширован для проверки
  if (Auth::attempt($credentials)) {
    return redirect()->intended('dashboard'); в методе intended урл редиректа куда потом направит
  }

  дополнительные условия для проверки
  if (Auth::attempt(['email' => $email, 'password' => $password, 'ban' => 0])) {
  }

}

Доступ к гуардам
Если разные гуарды для разных частей приложения

if (Auth::guard('admin')->attempt($credentials)) {}
Все гуарды в конфиге списком auth.php

Разлогин
Auth::logout();

Галочка "Запомнить меня"
в таблице users поле remember_token
$remember ставим в true
в LoginController это уже встроено

if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {}

Проверка на наличие того, что юзер поставил галочку "Запомнить меня"
по факту проверка специальной отдельной куки

if (Auth::viaRemember()) {}

Другие методы АУ

Логиним
Auth::login($user);
Auth::login($user, true); с галочкой Запомнить меня

Auth::guard('admin')->login($user); с указанием гуарда

Auth::loginUsingId(1); по ID юзера
Auth::loginUsingId(1, true); по ID юзера и с галочкой

if (Auth::once($credentials)) {} логин для 1 запроса. без кук и сессий

HTTP Basic АУ
Добавить МВ auth.basic к роуту.
По умолчанию используется поле email как username.
Для FastCGI дополнительные настройки в .htaccess

Route::get('profile', function () {})->middleware('auth.basic');

HTTP Basic АУ без сохранения состояния
Нужна для API. пропустил


Разлогин для других устройств, кроме текущего
По факту инвалидация всех других сессий, кроме текущей.

раскоментить МВ в app/Http/Kernel.php
'web' => [\Illuminate\Session\Middleware\AuthenticateSession::class];

Auth::logoutOtherDevices($password); этот метод требует вбива пароля.

Добавление своих гуардов
пропустил

Добавление своих провайдеров
пропустил

События
Можно добавить прослушиватели, на события АУ в EventServiceProvider: События Registered, Attempting, Authenticated, Login, Failed, Validated, Verified, Logout, CurrentDeviceLogout, OtherDeviceLogout, Lockout, PasswordReset.
-------------------------------------------------

Security -> Authorization

Авторизация (АВ) - это разрешение юзеру действий над ресурсом.
Реализуется через Гейты (Г) и Политики (П).

Гейты - это как роуты, основаны на замыканиях, применяются к действиям в общем виде.
Политики - это как контроллеры, группируют логику вокруг модели или ресурса.

Гейты
Ф Gate. Передаем юзера $user и опционально модель.

App\Providers\AuthServiceProvider

Gate::define('update-post', function ($user) {
  return $user->isAdmin;
});

Gate::define('update-post', function ($user, $post) {
  return $user->id === $post->user_id;
});

Gate::define('update-post', 'App\Policies\PostPolicy@update');

Разрешаем или запрещаем действия
$user передаётся туда сам

if (Gate::allows('update-post')) {}
if (Gate::allows('update-post', $post)) {}
if (Gate::denies('update-post', $post)) {}

Разрешаем или запрещаем действия массово

if (Gate::any(['update-post', 'delete-post'], $post)) {}
if (Gate::none(['update-post', 'delete-post'], $post)) {}

Проверка разрешения Юзер-Действие
if (Gate::forUser($user)->allows('update-post', $post)) {}
if (Gate::forUser($user)->denies('update-post', $post)) {}

Авторизовать или выбросить исключение
Если юзеру не разрешено действие то выплюнет HTTP 403

Gate::authorize('update-post', $post);

Передать дополнительный контекст

Gate::define('create-post', function ($user, $category, $extraFlag) {
  return $category->group > 3 && $extraFlag === true;
});

if (Gate::check('create-post', [$category, $extraFlag])) {}

Методы Гейта
allows, denies, check, any, none, authorize, can, cannot

Директивы Blade
@can, @cannot, @canany

Ответ Гейта
Возвращает boolean. Можно вернуть ответ Response с текстом ошибки.

Gate::define('edit-settings', function ($user) {

  return $user->isAdmin
    ? Response::allow()
    : Response::deny('You must be a super administrator.');

});

Gate::allows вернет boolean. Поэтому поймать такой ответ можно

$response = Gate::inspect('edit-settings', $post);

if ($response->allowed()) {

  } else {
    echo $response->message();
}

Метод before
запускается ДО всех проверок

Gate::before(function ($user, $ability) {
  if ($user->isSuperAdmin()) {
    return true;
  }
});

Метод after
запускается ПОСЛЕ всех проверок

Gate::after(function ($user, $ability, $result, $arguments) {
  if ($user->isSuperAdmin()) {
    return true;
  }
});

Если before и after возвращают true, то проверка прошла глобально.
Это нужно например чтобы выдать все права админу.

Политики
Политики - это классы которые организуют логику доступа для модели или ресурса.
В блоге модель Post и политика PostPolicy.
Политики в app/Policies.
Политики разрешаются через СК, поэтому можно добавить любые зависимости.

Создать политику
php artisan make:policy PostPolicy

создать с CRUD (viewAny, view, create, update, delete, restore, forceDelete)
php artisan make:policy PostPolicy --model=Post

Регистрация политики
тут AuthServiceProvider

в массиве $policies = [Post::class => PostPolicy::class];
тут связь Eloquent Модели и Политики

Автопоиск политики
Политики зареганные явно, имеют приоритет над авто-найденными политиками.
Альтернатива регистрации руками.
Через наименования User и UserPolicy.
Можно написать свою логику автопоиска политики в методе Gate::guessPolicyNamesUsing.

В политику добавляем методы для каждого действия, которое оно разрешает или запрещает
Все методы: viewAny, view, create, update, delete, restore, forceDelete

class PostPolicy {
  public function update(User $user, Post $post) {
    return $user->id === $post->user_id; проверка что Юзер может редактировать Пост. что это его пост
  }
}


Что политика возвращает в Ответ
Вернем не boolean а полный Ответ

public function update(User $user, Post $post) {
  return $user->id === $post->user_id
    ? Response::allow()
    : Response::deny('You do not own this post.');
}

ловим ответ

$response = Gate::inspect('update', $post);
if ($response->allowed()) {} else {
  echo $response->message();
}

Все Г и П возвращают false если запрос от не аутентифицированного юзера.
Такие запросы можно пропускать тоже.

public function update(?User $user, Post $post) {
  return optional($user)->id === $post->user_id;
}

Фильтры политик. Вообщем полный доступ для админа. Метод before как в Гейтах

public function before($user, $ability) {
  if ($user->isSuperAdmin()) {
    return true;
	return false; полный запрет
	return NULL; авторизация будет выполняться методами политики
  }
}

Авторизация действий используя Политики

1. Через модель User. модель User содержит эти 2 метода

if ($user->can('update', $post)) {} метод update модели post
if ($user->cant('update', $post)) {}

Если для данной модели зарегистрирована политика, метод can автоматически вызовет соответствующую политику и вернет результат.

Если для модели не зарегистрирована политика, метод can попытается вызвать гейт на основе замыкания, соответствующий заданному имени действия.

Действия не требующие моделей
if ($user->can('create', Post::class)) {}

2. через МВ
МВ авторизует действия, до того как запрос достигнет роута или контроллера.
В App\Http\Kernel, МВ Illuminate\Auth\Middleware\Authorize стоит с ключом can.

Route::put('/post/{post}', function (Post $post) {})->middleware('can:update,post');

can это МВ
update это действие которое хотим авторизовать
post это параметр маршрута который передаем Политике. по факту передадим модель Post

Если юзер не авторизован для выполнения этого действия, то вернется ответ HTTP 403

Действия не требующие моделей

Route::post('/post', function () {})->middleware('can:create,App\Post');

3. через метод контроллера authorize()
вернет HTTP 403 если нет авторизации. Как и метод can, этот метод принимает имя действия, которое вы хотите разрешить, и соответствующую модель. Если действие не авторизовано.

public function update(Request $request, Post $post) {
  $this->authorize('update', $post);
}

Действия не требующие моделей

public function create(Request $request) {
  $this->authorize('create', Post::class);
}

Авторизация Контроллеров Ресурсов
использовать метод authorizeResource в конструкторе контроллера ресурсов.
этот метод прикрепляет МВ can к методам контроллера ресурсов

public function __construct() {
  $this->authorizeResource(Post::class, 'post'); прикрепили модель и роут
}

ресурсный контроллер должен быть создан с флагом --model

4. через шаблоны Blade
директивы @can, @cannot

@can('update', $post)
  юзер может изменять пост
@elsecan('create', App\Post::class)
  юзер может создавать пост
@endcan

@cannot('update', $post)
  юзер НЕможет изменять пост
@elsecannot('create', App\Post::class)
  юзер НЕможет создавать пост
@endcannot

@canany(['update', 'view', 'delete'], $post)
  юзер может изменять, просматривать, удалять пост
@elsecanany(['create'], \App\Post::class)
  юзе может создавать пост
@endcanany

@can, @cannot аналог @if и @unless. Можно переписать так

@if (Auth::user()->can('update', $post))
  юзер может изменять пост
@endif

@unless (Auth::user()->can('update', $post))
  юзер НЕможет изменять пост
@endunless

Действия не требующие моделей
@can('create', App\Post::class)
  юзер может создавать пост
@endcan

@cannot('create', App\Post::class)
  юзер Неможет создавать пост
@endcannot

Передача дополнительного контекста

public function update(User $user, Post $post, int $category) {
  return $user->id === $post->user_id && $category > 3;
}

и потом вызвать политику так:
$this->authorize('update', [$post, $request->input('category')]);
-------------------------------------------------

Security -> Email Verification

Готовые методы отправки и верификации пользователей при реге.
Модель App\User должна расширять контракт Illuminate\Contracts\Auth\MustVerifyEmail.

Новые юзеры получают почту со ссылкой.
К событию Illuminate\Auth\Events\Registered присоединен слушатель SendEmailVerificationNotification в EventServiceProvider

Таблица users должна содержать столбик email_verified_at с датой верификации юзера.
Этот столбик уже есть в поставке, запустить php artisan migrate

Добавить роут Auth::routes(['verify' => true]);
Класс Auth\VerificationController содержит всю логику верификации по почте

МВ verified разрешает доступ к роуту только проверенным юзерам
Route::get('profile', function () {})->middleware('verified');

Вьюхи готовы
composer require laravel/ui
php artisan ui vue --auth

шаблон resources/views/auth/verify.blade.php

Редирект после верификации
VerificationController:
protected $redirectTo = '/dashboard';

События
Есть набор событий при отправке почты юзеру и дальнейшей верификации.
-------------------------------------------------

Security -> Encryption

Используется OpenSSL с AES-256, AES-128, AES-256-CBC с подписью MAC.
Ф Crypt.

Ключ
в файле config/app.php ключ key вбить руками

или сгенерить командой
php artisan key:generate

Зашифровать
Crypt::encryptString($value);

Расшифровать
Crypt::decryptString($value);
если не удалось, будет выброшено исключение DecryptException
-------------------------------------------------

Security -> Hashing

Для хеширования паролей.
Ф Hash.

В LoginController и RegisterController включено по умолчанию и используется Bcrypt.

Конфиг config/hashing.php

Драйверы
Bcrypt, Argon2 (Argon2i (требует PHP 7.2), Argon2id (требует PHP 7.3)).

Хешируем

Hash::make($value);
Hash::make($value, ['rounds' => 12]); сложность для Bcrypt

Hash::make($value, ['memory' => 1024, 'time' => 2, 'threads' => 2]); сложность для Argon2

Проверка хеша
if (Hash::check('passwordfromForm', $passwordfromDBasHash)) {}

Проверка необходимости повторного хеширования пароля
Это нужно когда изменилась "сложность" и требуется перехешировать пароль на новый хеш

if (Hash::needsRehash($hashed)) {
  Hash::make($value);
}
-------------------------------------------------

Security -> Resetting Passwords

Готовый набор для сброса пароля

composer require laravel/ui
php artisan ui vue --auth
php artisan migrate

база должна сохранять password reset токен.
токен годен 1 час.
изменить можно в config/auth.php в параметре expire

контракт Illuminate\Contracts\Auth\CanResetPassword
класс App\User
вьюхи resources/views/auth/passwords

вся логика тут
Auth\ForgotPasswordController
Auth\ResetPasswordController

редирект после сброса пароля
ResetPasswordController
$redirectTo = '/dashboard';

Настройка Гуарда Аутентификации
в auth.php
в ResetPasswordController указать свой гуард

protected function guard() {
  return Auth::guard('guard-name'); мой гуард
}

Брокеры паролей
в auth.php
в ForgotPasswordController и ResetPasswordController

public function broker() {
  return Password::broker('name'); свой брокер
}

Класс уведомлений для отправки почты юзеру

модель User
public function sendPasswordResetNotification($token) {
  $this->notify(new ResetPasswordNotification($token));
}
-------------------------------------------------

Digging Deeper -> Artisan Console

Artisan - это command line interface (CLI)
Ф Artisan

список всех команд
php artisan list

хелп по команде
php artisan help commandName

Tinker - это пакет REPL (read-eval-print-loop) на базе пакета PsySH. Уже стоит.

установка Tinker вручную
composer require laravel/tinker

войти в Tinker
php artisan tinker

опубликовать файл конфига
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

Белый список команд
clear-compiled, down, env, inspire, migrate, optimize, up

в tinker.php добавить свои команды в свойство 'commands'

Чтобы Tinker не присваивал классам псевдонимы
в tinker.php добавить классы в свойство 'dont_alias'

Классы команд разрешаются через СК, поэтому можно любые зависимости.

Создать команду
в app/Console/Commands

php artisan make:command CommandName

заполнить свойства
$signature = 'email:send {user}';
$description = 'description description';

исполнение в методе
public function handle(DripEmailer $drip) {
  $drip->send(User::find($this->argument('user')));
}

Команды на базе Замыканий

Роуты на основе замыканий - альтернатива контроллерам.
Команды на основе замыканий - альтернатива командам на классах.

в app/Console/Kernel.php в методе commands грузим routes/console.php
в этом файле определять роуты на базе замыканий но только через Artisan::command

Сигнатура метода

Artisan::command('build {project}', function ($project) {

  в замыкании получаем аргументы и опции команды
  $this->info("Building {$project}!");
});

Artisan::command('email:send {user}', function (DripEmailer $drip, $user) {
  $drip->send(User::find($user));
});


Описание

Artisan::command('build {project}', function ($project) {
  $this->info("Building {$project}!");
})->describe('Build the project');

Аргументы

$signature = 'email:send {user}'; аргумент user обязателен
email:send {user?} аргумент user НЕобязателен
email:send {user=foo} аргумент user со значением по умолчанию

Опции
идут с дефисами --

$signature = 'email:send {user} {--queue}'; опция без значения это флаг
php artisan email:send 1 --queue; запуск

'email:send {user} {--queue=}'; опция со значением
php artisan email:send 1 --queue=default; запуск

email:send {user} {--queue=default}; опция со значением по умолчанию

Шорткат для опции
email:send {user} {--Q|queue}; --Q это краткая запись опции --queue

Ввод массивов

email:send {user*}
php artisan email:send foo bar

email:send {user} {--id=*}
php artisan email:send --id=foo --id=bar


Описание для аргументов и опций

$signature = 'email:send
  {user : The ID of the user}
  {--queue= : Whether the job should be queued}';

Получить аргументы и опции

public function handle() {

  $userId = $this->argument('user');
  $arguments = $this->arguments();

  $queueName = $this->option('queue');
  $options = $this->options();
}

Запрос на ввод

public function handle() {
  $name = $this->ask('What is your name?');
  $password = $this->secret('What is the password?');
}

Запрос на подтверждение

if ($this->confirm('Do you wish to continue?')) {}; ввести y или yes

Автозаполнение ввода

$this->anticipate('What is your name?', ['Taylor', 'Dayle']);

замыкание будет вызываться при печатании каждой буквы
$this->anticipate('What is your name?', function ($input) {});

Множественный выбор из вариантов

$this->choice(
  'What is your name?',
  ['Taylor', 'Dayle'],
  $defaultIndex, значение выбора по умолчанию
  $maxAttempts = null, колво попыток выбора
  $allowMultipleSelections = false позволить множественный выбор
);

Вывод результата
каждый будет своим цветом

public function handle() {
  $this->line('Display this on the screen'); без цвета
  $this->info('Display this on the screen'); синий
  $this->comment('Display this on the screen');
  $this->question ('Display this on the screen');
  $this->error('Display this on the screen'); красный
}

Вывод результата таблицей

$headers = ['Name', 'Email'];
$users = App\User::all(['name', 'email'])->toArray();
$this->table($headers, $users);

Прогресс бар

$bar = $this->output->createProgressBar(count($users));
$bar->start();

foreach ($users as $user) {
  $this->performTask($user);
  $bar->advance();
}

$bar->finish();

Регистрация команд

команды в app/Console/Commands зареганы автоматически.
Для других папок сделать так

protected function commands() {
  $this->load(__DIR__.'/Commands');
  $this->load(__DIR__.'/MoreCommands');
}

или

добавить в app/Console/Kernel.php
$commands = [
  Commands\SendEmails::class
];

Вызов команд вне CLI
из роута или контроллера.
Artisan::call принимает команду, класс, параметры

Route::get('/foo', function () {

  $exitCode = Artisan::call('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

});

или

Artisan::call('email:send 1 --queue=default');

Поставим команду в очередь чтобы работало в фоновом режиме

Route::get('/foo', function () {

  Artisan::queue('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

});

Указать соединение и очередь

Artisan::queue('email:send', [
  'user' => 1,
  '--queue' => 'default'
])->onConnection('redis')
  ->onQueue('commands');

Передать опции как массивы

Route::get('/foo', function () {

  $exitCode = Artisan::call('email:send', [
    'user' => 1,
	'--id' => [5, 13]
  ]);

});

Передать булево значение

$exitCode = Artisan::call('migrate:refresh', [
  '--force' => true
]);

Вызов команд из других команд

public function handle() {

  $this->call('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

}

Подавить вывод в консоль
$this->callSilent('email:send', [
  'user' => 1,
  '--queue' => 'default'
]);

Кастомизация Stub
чтобы править рутовые команды Artisan.
папка /stubs.
править сами шаблоны.
Все изменения сделанные руками, отразятся во всех командах Artisan::make

php artisan stub:publish
-------------------------------------------------

Digging Deeper -> Broadcasting

Вещание - это websockets.
Изменения на сервере приходят в клиентскую js либу в виде новых данных и обновляются реалтайм.
JS либа это Laravel Echo.
Вещание событий через вебсокеты.

Конфиг config/broadcasting.php

Драйверы
Pusher, Redis, log(для отладки), NULL(выключено)

СП
в config/app.php в массиве providers раскоментить App\Providers\BroadcastServiceProvider

требуется CSRF токен
<meta name="csrf-token" content="{{ csrf_token() }}">


Либа Laravel Echo

Вещатель Pusher
composer require pusher/pusher-php-server

указать драйвер в .env
BROADCAST_DRIVER=pusher

resources/js/bootstrap.js

import Echo from "laravel-echo";
window.Pusher = require('pusher-js');
window.Echo = new Echo({
  broadcaster: 'pusher', вещатель
  key: 'your-pusher-channels-key'
});

Пакет laravel-websockets на чистом php, совместим с Pusher, работает без Nodejs

Вещатель Redis
composer require predis/predis

указать драйвер в .env
BROADCAST_DRIVER=redis

Redis работает по принципу публикации-подписки.
Сервер вебсокетов получает сообщения от Redis, передает на Каналы вебсокетов.

Связь Redis с сервером Socket.IO

npm install --save socket.io-client
https://github.com/tlaverdure/laravel-echo-server

import Echo from "laravel-echo"
window.io = require('socket.io-client');
window.Echo = new Echo({
  broadcaster: 'socket.io',
  host: window.location.hostname + ':6001'
});

Запустить прослушиватель очереди.
Все трансляции событий выполняются с помощью задач в очереди.

События транслируются через каналы.
Каналы бывают публичные и приватные.
Приватные требует АУ и авторизации.

альтернатива Pusher
https://github.com/beyondcode/laravel-websockets


Пример обновление статуса заказа

запуск события ShippingStatusUpdated
event(new ShippingStatusUpdated($update));

стартуем приватный канал
class ShippingStatusUpdated implements ShouldBroadcast{
  public function broadcastOn() {
    return new PrivateChannel('order.'.$this->update->order_id);
  }
}

правила авторизации в канале, пишем в routes/channels.php

Broadcast::channel('order.{orderId}', function ($user, $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;
});

Прослушиваем событие в JS либе

Echo.private(`order.${orderId}`)
  .listen('ShippingStatusUpdated', (e) => {
    console.log(e.update);
});

Название трансляции
public function broadcastAs() {
  return 'broadName';
}
.listen('.broadName', function (e) {});

Передача данных в событие
public function broadcastWith() {
  return ['id' => $this->user->id];
}

Очередь трансляции
очередь по умолчанию в queue.php
можно задать свою очередь

$broadcastQueue = 'your-queue-name';

можно использовать очередь sync вместо драйвера очереди по умолчанию.

Условия трансляции
транслировать событие, только если выполнено какое-то условие

public function broadcastWhen() {
  return $this->value > 100;
}

Авторизация приватных каналов
делается отдельный HTTP запрос на роут для авторизации

Broadcast::routes(); роут для авторизации. автоматически поместит роут в МВ 'web'
Broadcast::routes($attributes);

роут точки авторизации для доступа к каналу /broadcasting/auth

window.Echo = new Echo({
  broadcaster: 'pusher',
  key: 'your-pusher-channels-key',
  authEndpoint: '/custom/endpoint/auth' указать свою точку авторизации
});

делаем авторизацию в routes/channels.php
передаем имя канала и юзера

Broadcast::channel('order.{orderId}', function ($user, $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;
});

как роуты HTTP, роуты каналов могут привязывать модель
Broadcast::channel('order.{order}', function ($user, Order $order) {
  return $user->id === $order->user_id;
});

каналы аутентифицируют юзера через гуарды
Broadcast::channel('channel', function () {}, ['guards' => ['web', 'admin']]);

Классы каналов
php artisan make:channel OrderChannel
лежат в App/Broadcasting

регаем каналы в routes/channels.php

Broadcast::channel('order.{order}', OrderChannel::class);

логику АУ кладём сюда

public function join(User $user, Order $order) {
  return $user->id === $order->user_id;
}

классы каналов разрешаются через СК. возможны любые зависимости добавить

запуск события
event(new ShippingStatusUpdated($update));
broadcast(new ShippingStatusUpdated($update))->toOthers(); исключить текущего пользователя из получателей

например создаём задачу в TODO. и вставляем
axios.post('/task', task)
  .then((response) => {
    this.tasks.push(response.data);
});
но задача вставится 2 раза. сначала напрямую. потом из события. поэтому нужен метод toOthers()

Laravel Echo, Vue, Axios - заголовок X-Socket-ID будет назначен автоматически.

для других либ делать так
var socketId = Echo.socketId();

Приём трансляции

установка Laravel Echo
Laravel Echo это JS либа которая делает подписку на каналы для прослушивания событий
npm install --save laravel-echo pusher-js

resources/js/bootstrap.js
import Echo from "laravel-echo"
window.Echo = new Echo({
  broadcaster: 'pusher',
  key: 'your-pusher-channels-key',
  cluster: 'eu', кластер
  forceTLS: true работать через TLS
});

Прослушивание событий
Echo.channel('orders')
  .listen('OrderShipped', (e) => {
    console.log(e.order.name);
});

прослушивание приватных каналов, и несколько каналов одновременно
Echo.private('orders')
  .listen(...)
  .listen(...)
  .listen(...);

Отключение от канала
Echo.leaveChannel('orders');
Echo.leave('orders'); покинуть канал, и все связанные с ним каналы

Неймспейс событий

App\Events
но можно задать своё

window.Echo = new Echo({
  broadcaster: 'pusher',
  key: 'your-pusher-channels-key',
  namespace: 'App.Other.Namespace'
});

или

Echo.channel('orders')
  .listen('.Namespace\\Event\\Class', (e) => {});

Каналы присутствия
это частные каналы, но с инфой кто подписан на канал

авторизация юзеров на частные каналы присутствия

Broadcast::channel('chat.{roomId}', function ($user, $roomId) {
  if ($user->canJoinRoom($roomId)) {
    return ['id' => $user->id, 'name' => $user->name];
  }
});

присоединиться к каналу присутствия

Echo.join(`chat.${roomId}`)
  .here((users) => {сразу после присоединения сработает})
  .joining((user) => {когда юзер присоединился})
  .leaving((user) => {когда юзер покинул канал}
);

каналы присутствия получают события также, как приватные и публичные каналы
public function broadcastOn() {
  return new PresenceChannel('room.'.$this->message->room_id);
}

каналы присутствия. отсылка события

broadcast(new NewMessage($message));
broadcast(new NewMessage($message))->toOthers();

прослушивать так
Echo.join(`chat.${roomId}`)
  .here(...)
  .joining(...)
  .leaving(...)
  .listen('NewMessage', (e) => {}
);

События клиента
он печатает и это видно для другого клиента

Echo.private('chat')
  .whisper('typing', {
    name: this.user.name
});

Echo.private('chat')
  .listenForWhisper('typing', (e) => {
    console.log(e.name);
});

Уведомления

Echo.private(`App.User.${userId}`)
  .notification((notification) => {
    console.log(notification.type);
});
-------------------------------------------------

Digging Deeper -> Cache

Ф Cache. хелпер Cache

Конфиг config/cache.php

драйверы
Memcached, Redis, File, Database

драйвер Database

Schema::create('cache', function ($table) {
  $table->string('key')->unique();
  $table->text('value');
  $table->integer('expiration');
});

php artisan cache:table

драйвер Memcached
https://pecl.php.net/package/memcached

конфиг config/cache.php

'memcached' => [
  [
    'host' => '127.0.0.1',
    'port' => 11211,
    'weight' => 100
  ],
];

драйвер Redis
composer predis/predis


доступ к разным хранилищам
Cache::store('file')->get('foo');
Cache::store('redis')->get('foo');
Cache::store('database')->get('foo');

получить данные
Cache::get('key');
Cache::get('key', 'defaultvalue');
Cache::get('key', function () {
  return DB::table(...)->get(); тут свою логику писать
});

проверка на наличие
if (Cache::has('key')) {}

инкремент и декремент значения
на 1 или $amount

Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);

получить данные, а если их нет то сохранить и получить
Cache::remember('users', $seconds, function () {
  return DB::table('users')->get();
});

получить данные, а если их нет то сохранить навсегда и получить
Cache::rememberForever('users', function () {
  return DB::table('users')->get();
});

получить данные и удалить
$value = Cache::pull('key');

сохранить данные
Cache::put('key', 'value'); на бесконечно
Cache::put('key', 'value', $seconds); на N секунд
Cache::put('key', 'value', now()->addMinutes(10)); на N секунд

сохранить данные, если их нет
Cache::add('key', 'value', $seconds);

сохранить данные навсегда
Cache::forever('key', 'value');

удалить данные
Cache::forget('key');

удалить, указав 0 или отрицательное значение TTL
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);

удалить все данные
Cache::flush();


хелпер Cache

получить данные
cache('key');

сохранить данные
cache(['key' => 'value'], $seconds);
cache(['key' => 'value'], now()->addMinutes(10));

функция Cache
cache()->remember('users', $seconds, function () {
  return DB::table('users')->get();
});

Теги кеша
Тегами группировать связанные элементы.
Не поддерживаются драйверами file, dynamodb, database.

сохранить
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);

получить
$john = Cache::tags(['people', 'artists'])->get('John');
$anne = Cache::tags(['people', 'authors'])->get('Anne');

удалить
Cache::tags(['people', 'authors'])->flush();
Cache::tags('authors')->flush();

Атомарная блокировка
Чтобы гарантировать последовательность операций над кешем.
На драйверах memcached, dynamodb, redis, database, array.

для драйвера database

Schema::create('cache_locks', function ($table) {
  $table->string('key')->primary();
  $table->string('owner');
  $table->integer('expiration');
});

$lock = Cache::lock('foo', 10);

if ($lock->get()) {
  лок на 10сек
  $lock->release();
}

Cache::lock('foo')->get(function () {
  тут лок пока идёт работа
});

если блокировка недоступна прямо сейчас, то указать сколько секунд ждать

$lock = Cache::lock('foo', 10);

try {

  $lock->block(5);
  тут код если блокировка получена

} catch (LockTimeoutException $e) {

  блокировка не получена

} finally {

  optional($lock)->release();

}

Cache::lock('foo', 10)->block(5, function () {
  тут код если блокировка получена
});

Поставить блокировку в одном процессе а снять в другом
$this->owner токен

1 процесс
$podcast = Podcast::find($id);
$lock = Cache::lock('foo', 120);

if ($result = $lock->get()) {
  ProcessPodcast::dispatch($podcast, $lock->owner());
}

2 процесс
Cache::restoreLock('foo', $this->owner)->release();

снять блокировку без токена
Cache::lock('foo')->forceRelease();

Свой драйвер кеша

реализовать контракт Illuminate\Contracts\Cache\Store

зарегать драйвер
Cache::extend('mongo', function ($app) {
  return Cache::repository(new MongoStore);
});

События кеша
CacheHit, CacheMissed, KeyForgotten, KeyWritten
-------------------------------------------------

Digging Deeper -> Collections

Класс Illuminate\Support\Collection для работы с массивами.
Хелпер Collect.
Коллекции неизменяемы, каждый метод возвращает новый инстанс коллекции, исходный массив не изменяется.
Модели Eloquent возвращают коллекции.

создать коллекцию
$collection = collect([1, 2, 3]);

В класс Collection можно на лету внедрять свои методы. Расширим коллекцию новым методом

Collection::macro('toUpper', function () {
  return $this->map(function ($value) {
    return Str::upper($value);
  });
});

$collection = collect(['first', 'second']);
$upper = $collection->toUpper();


Методы коллекций

all() - вернет базовый массив
average(), avg() - вернет среднее значение, можно по ключу

chunk() - разбивает на несколько мелких коллекций
collapse() - сливает коллекции в одну коллекцию
combine() - сливает ключи одной коллекции, со значениями другой коллекции
collect() - возвращает новый инстанс Collection. копию из А в Б
concat() - добавляет массив или коллекцию, в конец существующей коллекции
contains(), containsStrict() - определяет, есть ли в коллекции значение, или пара ключ-значение. строго и нестрого
count() - колво элементов коллекции
countBy() - колво вхождений каждого значения в коллекцию
crossJoin() - декартово произведение всех вариантов

dd() - как var_dump(); exit
dump() - как var_dump()
diff() - вернет значения из первой коллекции, которых нет во второй коллекции
diffAssoc() - вернет пары ключи-значения из первой коллекции, которых нет во второй коллекции
diffKeys() - вернет пары ключи-значения из первой коллекции, которых нет во второй коллекции. сравнение на основе ключей
duplicates(), duplicatesStrict() - возвращает дубли из коллекции. вместе с ключами. массив будет ассоциативный. строго и нестрого

each() - перебор элементов коллекции
eachSpread() - перебор элементов коллекции когда элементы это подмассивы
every() - проверит что ВСЕ элементы обладают критерием истинности. для пустой коллекции вернет true
except() - вернет коллекцию, за исключением указанных ключей

filter() - фильтрует коллекцию и возращает коллекцию в которой элементы проходят критерий истинности
first() - вернет первый элемент, проходящий критерий истинности
firstWhere() - вернет первую пару ключ-значение, проходящую критерий истинности
flatMap() - перебирает коллекцию и может изменять элемент, возвращая новую коллекцию измененных элементов
flatten() - многомерную коллекцию сглаживает в одну плоскую
flip() - меняет местами ключи и значения
forget() - удаляет элемент по ключу. модифицирует коллекцию. а не возвращает новую
forPage() - разбивает коллекцию. N номер страницы, M колво элементов

get() - получить элемент коллекции по ключу
groupBy() - группировка коллекций по ключу

has() - проверяет есть ли элемент/элементы в коллекции

implode() - объединяет коллекции в коллекции
intersect() - удалит всё из первой коллекции, чего нет во второй коллекции. сохраняя ключи
intersectByKeys() - удалит всё из первой коллекции, каких ключей нет во второй коллекции
isEmpty() - проверка что коллекция пуста
isNotEmpty() - проверка что коллекция НЕпуста

join() - сливает коллекцию со строкой

keyBy() - собирает коллекции по ключу и соответствующие значения делает ключами
keys() - вернет все ключи коллекции

last() - возвращает последний элемент, соответствующий критерию истинности

macro() - расширяет коллекции. позволяет добавить новый метод в коллекцию (класс Collection), на лету
make() - создает новый инстанс коллекции
map() - обходит коллекцию и передает каждый элемент в колбек. колбек модифицирует и возвращает, образуя новую коллекцию измененных элементов. не изменяет вызываемую коллекцию. возвращает новую. как большинство методов тут.
mapInto() - обходит коллекцию, передавая значение в конструктор класса
mapSpread() - обходит коллекцию, передавая значение в колбек, в котором можно изменить и вернуть. создавая новую коллекцию
mapToGroups() - группировка в колбеке
mapWithKeys() - группировка в колбеке
max() - вернет максимальное значение по выборке по ключу
median() - вернет медианное значение по выборке по ключу
merge() - сливает коллекции. если ключи совпадают то перезапишет. если ключи цифровые то просто добавит всю коллекцию в конец оригинальной коллекции
mergeRecursive() - рекурсивно сливает коллекции. если ключи совпадают то будет создан подмассив значений с этим ключом
min() - вернет минимальное значение по выборке по ключу
mode() - вернет самое "частое" значение

nth() - создаст коллекцию, состоящую из каждого N-го элемента

only() - вернет коллекцию с заданными ключами

pad() - заполняет массив элементами до заданного размера. аналог PHP array_pad
partition() - отделить элементы прошедшие проверку критерием истинности, от остальных
pipe() - обходит коллекцию и возвращает результат
pluck() - извлекает в массив все значения для заданного ключа
pop() - удаляет и возвращает последний элемент коллекции
prepend() - добавляет элемент в начало коллекции
pull() - удаляет и возвращает элемент из коллекции по ключу
push() - добавляет элемент в конец коллекции
put() - добавит ключ и значение в коллекцию

random() - возвращает случайный элемент коллекции
reduce() - уменьшает коллекцию к одному значению, передавая результат каждой итерации в следующую итерацию
reject() - фильтрует коллекцию через колбек. если колбек вернет true то элемент удаляется
replace(), replaceRecursive() - аналог merge, перезаписывает элементы с одинаковыми строковыми и числовыми ключами
reverse() - меняет порядок элементов, сохраняя ключи

search() - поиск значения в коллекции, возвращает ключ
shift() - удаляет и возвращает первый элемент из коллекции
shuffle() - рандомно перемешивает
skip() - возвращает новую коллекцию без первых N членов. вырезает от начала и до N
skipUntil() - возвращает новую коллекцию c членами которые прошли критерий истины
skipWhile() - пропустит элементы для которых колбек true и вернет новую коллекцию
slice() - возвращает часть коллекции, начиная от заданного индекса. сохранит ключи
some() - псевдоним contains()
sort() - сортировка коллекции. сохраняет ключи. аналог PHP uasort
sortDesc() - как sort() но в обратном порядке
sortBy() - сортирует коллекцию по ключу. сохраняет ключи
sortByDesc() - как sortBy() но в обратном порядке
sortKeys() - сортировка на основе ключей
sortKeysDesc() - как sortKeys() но в обратном порядке
splice() - возвращает срез начиная с указанного индекса
split() - разбивает на подмассивы
sum() - сумма всех элементов

take() - вернет новую коллекцию с заданным числом элементов
takeUntil() - возвращает элементы пока колбек true (или false? судя по коду - false)
takeWhile() - возвращает элементы пока колбек false
tap() - позволяет внедриться между методами и что-то сделать с коллекцией, не затрагивая саму коллекцию
times() - создает новую коллекцию вызывая колбек N раз
toArray() - конвертит коллекцию и вложенные объекты - в массив PHP
toJson() - конвертит коллекцию в JSON
transform() - обходит коллекцию и вызывает колбек на каждый элемент. элементы будут изменены. изменяет саму коллекцию

union() - сливает коллекции. если во второй коллекции есть такие же ключи как в первой. то останется то, что в первой
unique(), uniqueStrict() - возвратит уникальные элементы. ключи будут сохранены. сравнение строго и нестрого
unless() - колбек будет выполняться до тех пор, пока первый аргумент будет true. when() - обратный для unless()
unlessEmpty() - аналог whenNotEmpty()
unlessNotEmpty() - аналог whenEmpty()
unwrap() - передали значения, получили коллекцию

values() - сбросит ключи

when() - колбек будет выполняться до тех пор, пока первый аргумент будет true. unless() - обратный для when()
whenEmpty() - колбек будет выполняться пока коллекция пустая. whenEmpty() - обратный для whenNotEmpty()
whenNotEmpty() - колбек будет выполняться пока коллекция Непустая. whenNotEmpty() - обратный для whenEmpty()
where(), whereStrict() - фильтрует коллекцию с помощью пары ключ-значение. строго и нестрого
whereBetween() - диапазон
whereIn(), whereInStrict() - вхождения. строго и нестрого
whereInstanceOf() - фильтрует по классу
whereNotBetween() - фильтрует вне приделов диапазона
whereNotIn(), whereNotInStrict() - фильтрует Невхождения. строго и нестрого
whereNotNull() - фильтрует на Неравенство NULL
whereNull() - фильтрует на равенство NULL
wrap() - делает из значения коллекцию

zip() - слияние значений массива со значениями коллекции в соответствующих индексах

Методы высокого порядка
это методы, внутри которых цикл.

average, avg, contains, each, every, filter, first, flatMap, groupBy, keyBy, map, max, min, partition, reject, skipUntil, skipWhile, some, sortBy, sortByDesc, sum, takeUntil, takeWhile, unique.

User::where('votes', '>', 500)->get();
$users->each->markAsVip(); вызовет метод markAsVip() для каждого объекта в коллекции

User::where('group', 'Development')->get();
$users->sum->votes; вызовет метод votes() для каждого объекта в коллекции

Ленивые коллекции
Основаны на генераторах PHP.
Чтобы работать с большими коллекциями без потребления памяти.
Перерабатывая массив частями.

Создать ленивую коллекцию
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {
    yield $line;
  }
});

Прочитать 10к моделей Eloquent

1. используя обычные коллекции
1 запрос к бд и получение всех объектов

App\User::all()->filter(function ($user) {
  return $user->id > 500;
});

2. используя ленивые коллекции.
1 запрос к бд, но получение по 1 объекту
потом запускается filter()

$users = App\User::cursor()->filter(function ($user) {
  return $user->id > 500;
});

foreach ($users as $user) {
  echo $user->id;
}

Почти все методы класса Collection доступны для LazyCollection класса.
Кроме методов которые изменяют саму коллекцию (shift, pop, prepend, итд)

Отдельные методы ленивых коллекций
tapEach() - аналог each()
remember() - вернет новую ленивую коллекцию которая будет помнить все значения которые уже были перечислены
-------------------------------------------------

Digging Deeper -> Events

Слушатель подписывается на событие

События в app/Events
Слушатели в app/Listeners

У 1 события могут быть N слушателей

Рега событий и слушателей
ключи это События, значения это Слушатели
в EventServiceProvider

protected $listen = [
  'App\Events\OrderShipped' => ['App\Listeners\SendShipmentNotification'],
];

Создать события и слушатели
создадутся классы из EventServiceProvider в массиве $listen

php artisan event:generate

Событие на основе Замыкания

public function boot() {
  parent::boot();
  Event::listen('event.name', function ($foo, $bar) {});
  Event::listen('event.*', function ($eventName, array $data) {});
}

Автоматическое обнаружение Событий и Слушателей
включить в EventServiceProvider

public function shouldDiscoverEvents() {
  return true;
}

Все классы в app/Listeners автоматически обнаруживаются

Указать папки где искать
в EventServiceProvider

protected function discoverEventsWithin() {
  return [
    $this->app->path('Listeners'),
  ];
}

В продакшене кешировать
php artisan event:cache

очистить кеш
php artisan event:clear

посмотреть список всех событий и слушателей
php artisan event:list

Событие это контейнер данных который держит данные нужные событию, например модель Eloquent.
Слушатель получает объект События в методе handle.
Слушатели разрешаются через СК поэтому возможны любые зависимости в конструкторе.

Остановить распространение События среди других Слушателей
из handle вернуть false

Слушатели в очереди

Cлушателя в очередь если медленная задача типа отправки почты.

Настроить очередь. в Слушатель добавить интерфейс ShouldQueue.
если Слушателя сгенерили командой event:generate, то он там есть.

В Слушателе настроить $connection, $queue, $delay (коннект к очереди, имя очереди, задержка).

имя очереди на лету
public function viaQueue() {
  return 'listeners';
}

постановка Слушателя в очередь по условию на лету

public function shouldQueue(OrderPlaced $event) {
  return $event->order->subtotal >= 5000; если вернет false то слушатель не будет выполнен
}

Получить доступ к очереди вручную через методы delete, release

Обработка невыполненных задач
если работа Слушателя завершилась неудачно, после максимального колва попыток.
будет вызван метод

public function failed(OrderShipped $event, $exception) {}

Отправка событий всем зареганным слушателям. хелпер Event

event(new OrderShipped($order));
OrderShipped::dispatch($order); или через трейт Dispatchable

Подписчики на события
подписчики на события это классы которые могут подписываться на несколько событий внутри 1 класса

public function subscribe($events) {

  $events->listen(
    'Illuminate\Auth\Events\Login',
    'App\Listeners\UserEventSubscriber@handleUserLogin'
  );

  $events->listen(
    'Illuminate\Auth\Events\Logout',
    'App\Listeners\UserEventSubscriber@handleUserLogout'
  );
}

Рега подписчиков на события
в EventServiceProvider

protected $subscribe = [
  'App\Listeners\UserEventSubscriber',
];
-------------------------------------------------

Digging Deeper -> File Storage

Абстракция файловой системы на основе либы PHP Flysystem
Конфиг config/filesystems.php
хелпер Asset
Ф Storage

Диск public
на основе драйвера local
файлы для публичного доступа
папка storage/app/public

чтобы файлы стали доступны для публичного доступа надо создать символическую ссылку из public/storage в storage/app/public

создать ссылку на файл
php artisan storage:link

создать ссылку на файл
asset('storage/file.txt');

создать символические ссылки в файле конфига
'links' => [
  public_path('storage') => storage_path('app/public'),
  public_path('images') => storage_path('app/images'),
];

драйвер Local
все операции проводятся относительно root установленного в конфиге
по умолчанию это storage/app
пермишены на папки 0755 на файлы 0644. настраивается в конфиге

Storage::disk('local')->put('file.txt', 'Contents');

драйверы FTP, SFTP, Amazon S3
примеры конфигов в мане

composer league/flysystem-sftp
composer league/flysystem-aws-s3-v3
composer league/flysystem-cached-adapter - для увеличения производительности

Кеширование для диска
настройки конфига: cache, disk, expire, prefix

Частые процедуры

сохранить
Storage::put('avatars/1', $fileContents); на диск по умолчанию
Storage::disk('s3')->put('avatars/1', $fileContents); на выбранный диск

получить
Storage::get('file.jpg');
Storage::disk('s3')->exists('file.jpg'); проверка на наличие
Storage::disk('s3')->missing('file.jpg'); проверка на отсутствие

скачать
Storage::download('file.jpg');
Storage::download('file.jpg', $name, $headers); $name имя файла которое увидит юзер

урлы файлов
Storage::url('file.jpg');

временные урлы файлов для Amazon S3

Storage::temporaryUrl(
  'file.jpg', now()->addMinutes(5),
  ['ResponseContentType' => 'application/octet-stream']
);

урл хоста
в конфиге 'url' => env('APP_URL').'/storage'

размер файла
Storage::size('file.jpg');
Storage::lastModified('file.jpg');

сохранить
Storage::put('file.jpg', $contents);
Storage::put('file.jpg', $resource); с поддержкой потока

потоковый стриминг
Storage::putFile('photos', new File('/path/to/photo')); сгенерит уникальное имя и расширение на основе MIME
Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg'); указать своё имя
Storage::putFile('photos', new File('/path/to/photo'), 'public'); указать видимость для Amazon S3

писать в файл в начало или конец
Storage::prepend('file.log', 'Prepended Text');
Storage::append('file.log', 'Appended Text');

копирование и перемещение
Storage::copy('old/file.jpg', 'new/file.jpg');
Storage::move('old/file.jpg', 'new/file.jpg');

загрузка файла
Storage::putFile('avatars', $request->file('avatar')); сгенерит уникальное имя и расширение на основе MIME
или
$request->file('avatar')->store('avatars'); сгенерит уникальное имя и расширение на основе MIME

указать своё имя файла
Storage::putFileAs('avatars', $request->file('avatar'), $request->user()->id);
$request->file('avatar')->storeAs('avatars', $request->user()->id);

удалить непечатаемые и недопустимые символы из путей и имен файлов
League\Flysystem\Util::normalizePath

указать диск при сохранении

$request->file('avatar')->store(
  'avatars/'.$request->user()->id,
  's3'
);

$request->file('avatar')->storeAs(
  'avatars',
  $request->user()->id,
  's3'
);

оригинальное имя и расширение загруженного файла
$request->file('avatar')->getClientOriginalName();
$request->file('avatar')->extension();

Видимость файла
это абстракция за которой простой пермишен ФС
public, private

Storage::put('file.jpg', $contents, 'public'); установить при сохранении
Storage::getVisibility('file.jpg'); получить для уже сохраненных
Storage::setVisibility('file.jpg', 'public'); установить для уже сохраненных

сохранить с видимостью public

$request->file('avatar')->storePublicly('avatars', 's3');

$request->file('avatar')->storePubliclyAs(
  'avatars',
  $request->user()->id,
  's3'
);

удалить файлы
Storage::delete('file.jpg');
Storage::delete(['file.jpg', 'file2.jpg']);
Storage::disk('s3')->delete('folder_path/file_name.jpg'); с указанием диска

получить файлы в папке
Storage::files($directory); только файлы
Storage::allFiles($directory); файлы из подпапок тоже

получить папки в папке
$directories = Storage::directories($directory); папки
$directories = Storage::allDirectories($directory); папки из подпапок тоже

создать папку
Storage::makeDirectory($directory);

удалить папку
Storage::deleteDirectory($directory);

Свой адаптер
например dropbox
composer require spatie/flysystem-dropbox

создать СП

public function boot() {
  Storage::extend('dropbox', function ($app, $config) {
    $client = new DropboxClient(
      $config['authorization_token']
    );
  return new Filesystem(new DropboxAdapter($client));
  });
}

зарегать СП в config/app.php
прописать драйвер в config/filesystems.php
-------------------------------------------------

Digging Deeper -> Helpers

Хелперы - это глобальные вспомогательные функции

Массивы и Объекты

Arr::accessible - проверка что это массив
Arr::add - добавить в массив новую пару ключ-значение если данный ключ не существует
Arr::collapse - сливает массивы в один массив
Arr::crossJoin - сливает массивы возвращая декартово произведение всех возможных вариантов
Arr::divide - разбивает массив на массив ключей и массив значений
Arr::dot - сливает многомерный массив в одиномерный массив используя точку
Arr::except - удаляет из массива пару ключ-значение, по ключу
Arr::exists - проверяет что ключ существует в массиве
Arr::first - вернет первый элемент, прошедший критерий истины, если не нашел то вернет значение по умолчанию
Arr::flatten - сливает многомерный массив в одиномерный массив (забирает все значения)
Arr::forget - удаляет пару ключ-значение, по ключу. использует точку как глубину захода в подмассивы
Arr::get - получает значение, по ключу. использует точку как глубину захода в подмассивы, если не нашел то вернет значение по умолчанию
Arr::has - проверяет, существует ли элемент, или ВСЕ переданные элементы
Arr::hasAny - проверяет, существует ли ЛЮБОЙ элемент, в переданных элементах
Arr::isAssoc - проверяет что массив ассоциативный
Arr::last - вернет последний элемент, прошедший критерий истины, если не нашел то вернет значение по умолчанию
Arr::only - вернет только указанные пары ключ-значение, по ключам
Arr::pluck - извлекает все значения, по ключу. из подмассивов. в итоговом массиве ключами могут быть другие значения
Arr::prepend - добавить элемент или пару ключ-значение, в начало массива
Arr::pull - возвращает и удаляет пару ключ-значение, по ключу. если ключа нет то вернет значение по умолчанию
Arr::query - преобразует массив в строку запроса query string
Arr::random - возвращает случайное значение из массива. можно указать колво возвращаемых значений
Arr::set - установка значения, по ключу. используя точку чтобы добраться вглубь вложенных подмассивов
Arr::shuffle - рандомно перемешать
Arr::sort - сортировка по значению. сортировка в Замыкании
Arr::sortRecursive - рекурсивная сортировка
Arr::where - фильтрует массив используя Замыкание
Arr::wrap - оборачивает значение в массив

data_fill - заполняет значениями, по ключу, используя точки. внутри подмассивов. если его там нет. если есть то не перезапишет
data_get - извлекает значения, по ключу, используя точки. внутри подмассивов. если ключ не найден, вернет значение по умолчанию
data_set - заполняет значениями, по ключу, используя точки. внутри подмассивов. если оно там есть то перезапишет. если заполнить только то, что не существует, то 4й аргумент в false

head - вернет первый элемент массива
last - вернет последний элемент массива


Пути

app_path - полный путь к папке app
base_path - полный путь к корню проекта root
config_path - полный путь к папке config
database_path - полный путь к папке database
mix - путь до mix файла
public_path - полный путь к папке public
resource_path - полный путь к папке resources
storage_path - полный путь к папке storage

Строки

__ - перевод строки из языкового файла. по ключу или фразе
class_basename - вернет имя класса удалив неймспейс
e - запускает PHP htmlspecialchars с double_encode в true
preg_replace_array - последовательная замена в строке по шаблону регулярки, но замены в виде массива

Str::after - в строке вернёт всё, после указанной подстроки
Str::afterLast - в строке вернёт всё, после последнего вхождения указанной подстроки
Str::ascii - строку в ASCII
Str::before - в строке вернёт всё, до указанной подстроки
Str::beforeLast - в строке вернёт всё, до последнего вхождения указанной подстроки
Str::between - вернет часть строки между двумя подстроками
Str::camel - преобразует camel_case в CamelCase
Str::contains - проверит содержит ли строка, подстроку (или любую подстроку из массива подстрок). регистр важен
Str::containsAll - проверит содержит ли строка, все подстроки из массива подстрок. регистр важен
Str::endsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), концом строки
Str::finish - добавит в конец строки, подстроку. если ее еще там нет
Str::is - проверяет, соответствует ли строка, шаблону. в шаблоне есть знак *
Str::isAscii - проверит является ли строкой 7 bit ASCII
Str::isUuid - проверит является ли строка UUID
Str::kebab - преобразует CamelCase в camel-case
Str::length - длинна строки
Str::limit - обрежет строку до N символов. может добавить в конец троеточие
Str::lower - строку в нижний регистр
Str::orderedUuid - генерирует timestamp first UUID
Str::padBoth - на основе PHP str_pad. оборачивает строку, подстроками с двух сторон
Str::padLeft - на основе PHP str_pad. оборачивает строку, подстроками слева
Str::padRight - на основе PHP str_pad. оборачивает строку, подстроками справа
Str::plural - преобразует единственное число во множественное. работает только для англ. можно передать колво объектов для правильности
Str::random - случайная строка заданной длинны. на основе PHP random_bytes
Str::replaceArray - заменяет заполнители (?) в строке, последовательно, используя массив подстрок для замен
Str::replaceFirst - заменяет первое вхождение в строке, на подстроку
Str::replaceLast - заменяет последнее вхождение в строке, на подстроку
Str::singular - преобразует множественное число в единственное. работает только для англ
Str::slug - генерирует слуг (slug) из строки. можно указать разделитель для слов
Str::snake - преобразует CamelCase в camel_case
Str::start - добавляет подстроку в начало, в строке. если этой подстроки там нет
Str::startsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), началом строки
Str::studly - преобразует camel_case в CamelCase
Str::substr - возвращает часть строки с индекса N и длинной M
Str::title - делает все слова строки с большой буквы
Str::ucfirst - делает первый символ строки с большой буквы
Str::upper - делает все символы большими
Str::uuid - генерирует UUID версии 4
Str::words - обрежет строку до N слов. может добавить в конец троеточие

trans - перевод строки из языкового файла. по ключу
trans_choice - перевод строки из языкового файла с интонацией (числом для глаголов множественного числа). по ключу

Свободные строки
ООП интерфейс с цепочками вызовов

after - в строке вернёт всё, после указанной подстроки
afterLast - в строке вернёт всё, после последнего вхождения указанной подстроки
append - добавит подстроку к строке, с конца
ascii - строку в ASCII

basename - вернет имя класса удалив неймспейс, или просто последнюю часть из строки а/b/c, или указанную подстроку
before - в строке вернёт всё, до указанной подстроки
beforeLast - в строке вернёт всё, до последнего вхождения указанной подстроки

camel - преобразует camel_case в CamelCase
contains - проверит содержит ли строка, подстроку (или любую подстроку из массива подстрок). регистр важен
containsAll - проверит содержит ли строка, все подстроки из массива подстрок. регистр важен

dirname - вернет родительскую папку, из строки которая является путем. можно указать какую родительскую папку по уровню вернуть

endsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), концом строки
exactly - проверит равны ли строки
explode - разбивает строку по разделителю, в массив (коллекцию)

finish - добавит в конец строки, подстроку. если ее еще там нет

is - проверяет, соответствует ли строка, шаблону. в шаблоне есть знак *
isAscii - проверит является ли строкой 7 bit ASCII
isEmpty - проверка что пустая строка
isNotEmpty - проверка что Непустая строка

kebab - преобразует CamelCase в camel-case

length - длинна строки
limit - обрежет строку до N символов. может добавить в конец троеточие
lower - строку в нижний регистр
ltrim - обрежет строку слева от пустых символов, или указанных символов

match - возвратит подстроку, которая соответствует регулярке
matchAll - возвратит массив подстрок, которые соответствует регулярке

padBoth - на основе PHP str_pad. оборачивает строку, подстроками с двух сторон
padLeft - на основе PHP str_pad. оборачивает строку, подстроками слева
padRight - на основе PHP str_pad. оборачивает строку, подстроками справа
plural - преобразует единственное число во множественное. работает только для англ. можно передать колво объектов для правильности
prepend - добавить подстроку, в начало строки

replace - заменяет подстроку на подстроку
replaceArray - заменяет заполнители (?) в строке, последовательно, используя массив подстрок для замен
replaceFirst - заменяет первое вхождение в строке, на подстроку
replaceLast - заменяет последнее вхождение в строке, на подстроку
replaceMatches - замена на подстроку по регулярке. может через Замыкание обрабатывая каждую подмаску
rtrim - обрежет строку справа от пустых символов, или указанных символов

singular - преобразует множественное число в единственное. работает только для англ
slug - генерирует слуг (slug) из строки. можно указать разделитель для слов
snake - преобразует CamelCase в camel_case
split - разбивает строку на массив подстрок, используя регулярки. аналог explode
start - добавляет подстроку в начало, в строке. если этой подстроки там нет
startsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), началом строки
studly - преобразует camel_case в CamelCase
substr - возвращает часть строки с индекса N и длинной M

title - делает все слова строки с большой буквы
trim - обрежет строку с обоих сторон от пустых символов, или указанных символов

ucfirst - делает первый символ строки с большой буквы
upper - делает все символы большими

when - вызывает Замыкание, если условие истинно, и другое замыкание если условие ложно
whenEmpty - вызывает Замыкание, если строка пуста. Замыкание может вернуть значение
words - обрежет строку до N слов. может добавить в конец троеточие

Урлы

action - генерирует урл для контроллер+действие+параметры роута
asset - генерирует урл для ресурса типа картинки итд. в .env установить ASSET_URL
route - генерирует абсолютный урл для именованного роута. можно передать параметры. можно относительный урл
secure_asset - генерирует урл для ресурса типа картинки итд. используя HTTPS
secure_url - генерирует полный урл HTTPS для заданного пути
url - генерирует полный урл для заданного пути. еще есть url()->current(), url()->full(), url()->previous()

Разное

abort - генерация HTTP исключения с кодом ошибки, мессагой, заголовками
abort_if - генерация HTTP исключения с кодом ошибки, мессагой, заголовками. если условие true
abort_unless - генерация HTTP исключения с кодом ошибки, мессагой, заголовками. если условие false
app - вернет инстанс СК. можно передать класс или интерфейс чтобы разрешить его
auth - вернет инстанс Auth. альтернатива фасаду Auth. можно передать гуард к которому получить доступ

back - редирект назад
bcrypt - хеширует значение. альтернатива фасаду Hash
blank - проверяет значение на пустоту
broadcast - передаёт событие, слушателям

cache - вернет значение из кеша, или значение по умолчанию. можно писать в кеш. можно указать колво секунд кеширования
class_uses_recursive - вернет все трейты для класса и родительского класса
collect - создаст коллекцию из переданных значений
config - получить или установить значение из конфига (файлов конфига) в формате имяфайла.ключ. можно значения по умолчанию
cookie - создать куку
csrf_field - генерирует скрытое html поле с токеном
csrf_token - получить токен

dd - аналог var_dump(); exit;
dispatch - добавляет задачу в очередь задач
dispatch_now - выполняет задачу немедленно
dump - аналог var_dump();

env - возвращает переменые окружения из .env
event - отправляет событие, слушателям

factory - создает модель фабрики для тестирования или посева
filled - проверяет значение на НЕпустоту

info - пишет инфу в журнал log. можно передать контекстные данные
logger - пишет инфу уровня debug в журнал log. можно передать контекстные данные
method_field - генерирует глаголы HTTP для форм в скрытое поле
now - инстанс времени Carbon для текущего времени
old - вернет старый ввод в форму, из сессии. flash ввод
optional - доступ к свойствам и методам, переданного объекта. принимает Замыкание
policy - вернет Политику переданного класса

redirect - генерация HTTP редиректа с кодом, заголовками. на путь, на именованный роут
report - сообщит об исключении используя ваш обработчик исключений
request - вернет объект запроса Request. или значение по ключу
rescue - выполнит переданное Замыкание и поймает все исключения. исключения будут переданы в ваш обработчик report()
resolve - разрешает переданный класс или интерфейс, в СК
response - создаст объект ответа Response
retry - выполняет Замыкание N раз через M сек

session - получить или установить значения сессии

tap - принимает значение и Замыкание. и внутри Замыкания манипуляции
throw_if - генерит исключение если условие true
throw_unless - генерит исключение если условие false
today - инстанс времени Carbon для текущего времени
trait_uses_recursive - вернет все трейты для трейта
transform - выполняет Замыкание для переданного значения. если значение пустое то вернет значение по умолчанию

validator - создаст инстанс Validator. альтернатива фасаду Validator
value - вернет переданное значение. или результат работы Замыкания
view - вернет инстанс View

with - вернет переданное значение. или результат работы Замыкания
-------------------------------------------------

Digging Deeper -> HTTP Client

API для внешних HTTP запросов
На базе Guzzle
Ф Http

Установить
composer require guzzlehttp/guzzle

Делать запросы

Http::get('http://test.com');
Http::get('http://test.com/users/1')['name']; если возвращается JSON то сразу получить элемент массива
Http::post
Http::put
Http::patch
Http::delete

Возвращается объект ответа Response, у которого есть методы

$response->body();
$response->json();
$response->status();
$response->ok();
$response->successful();
$response->failed();
$response->serverError();
$response->clientError();
$response->header($header);
$response->headers();

Передать данные в Запрос

Http::get('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдет как application/json
Http::post('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдет как application/x-www-form-urlencoded
Http::asForm()->post('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдут сырые данные
Http::withBody(
  base64_encode($photo), 'image/jpeg'
)->post('http://test.com/photo');

отправить файлы в нескольких запросах
Http::attach(
  'attachment',
  file_get_contents('photo.jpg'),
  'photo.jpg'
)->post('http://test.com/attachments');

или

Http::attach(
  'attachment',
  fopen('photo.jpg', 'r'),
  'photo.jpg'
)->post('http://test.com/attachments');

Передать заголовки в Запрос

Http::withHeaders([
  'X-First' => 'foo',
  'X-Second' => 'bar'
])->post('http://test.com/users', [
  'name' => 'Taylor'
]);

Передать аутентификацию в Запрос

basic
Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);

digest
Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);

токен
Http::withToken('token')->post(...);

Ждать ответа N сек
Http::timeout(3)->get(...);

Попыток N и ждать ответа M млс
Http::retry(3, 500)->post(...);

Обработка ошибок

$response->successful(); код >= 200 and < 300
$response->failed(); код >= 400
$response->clientError(); код 400
$response->serverError(); код 500

Выбросить исключение

$response = Http::post);
$response->throw();
return $response['user']['id'];

Опции Guzzle
http://docs.guzzlephp.org/en/stable/request-options.html

передать опции

Http::withOptions([
  'debug' => true
])->get('http://test.com/users');

Тестирование
фасад Http метод fake

Http::fake(); пустые ответы с кодом 200

Http::fake([
  'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),
  'google.com/*' => Http::response('Hello World', 200, ['Headers']),
  '*' => Http::response('Hello World', 200, ['Headers']), на все остальные адреса будет эта заглушка
]);

серия поддельных ответов

Http::fake([
  'github.com/*' => Http::sequence()
    ->push('Hello World', 200)
    ->push(['foo' => 'bar'], 200)
    ->pushStatus(404),
]);

Http::fake([
  'github.com/*' => Http::sequence()
    ->push('Hello World', 200)
    ->push(['foo' => 'bar'], 200)
    ->whenEmpty(Http::response()),
]);

Http::fakeSequence()
  ->push('Hello World', 200)
  ->whenEmpty(Http::response());

Http::fake(function ($request) {
  return Http::response('Hello World', 200);
});

Проверка данных запросов

Http::fake();

Http::withHeaders([
  'X-First' => 'foo'
])->post('http://test.com/users', [
  'name' => 'Taylor',
  'role' => 'Developer'
]);

Http::assertSent(function ($request) {
  return
    $request->hasHeader('X-First', 'foo') &&
    $request->url() == 'http://test.com/users' &&
    $request['name'] == 'Taylor' &&
    $request['role'] == 'Developer';
});

Http::assertNotSent(function (Request $request) {
  return $request->url() === 'http://test.com/posts';
});

Http::assertNothingSent();
-------------------------------------------------

Digging Deeper -> Mail

На основе либы SwiftMailer
Драйвера SMTP, Mailgun, Postmark, Amazon SES, sendmail
Конфиг в config/mail.php
Ф Mail

Требуется Guzzle
composer require guzzlehttp/guzzle

драйвер Mailgun
пропуск

драйвер Postmark
composer require wildbit/swiftmailer-postmark

драйвер Amazon SES
composer aws/aws-sdk-php

Каждый тип почты представлен как класс в app/Mail

Создать почтовый класс
php artisan make:mail OrderShipped

Отправить почту
методы from, subject, view, attach

public function build() {
  return $this->from('example@example.com')
    ->view('emails.orders.shipped');
}

Прописать From и Reply в конфиге
from => 'address, name'
reply_to => 'address, name'

во вьюхах шаблоны Blade
складывать сюда resources/views/emails


Plain text

public function build() {
  return $this->view('emails.orders.shipped')
    ->text('emails.orders.shipped_plain');
}

Передать данные в шаблон

1. через публичные свойства почтового класса

public function __construct(Order $order) {
  $this->order = $order;
}

{{ $order->price }}

2. через метод with

public function __construct(Order $order) {
  $this->order = $order;
}

public function build() {
  return $this->view('emails.orders.shipped')
    ->with([
      'orderName' => $this->order->name,
      'orderPrice' => $this->order->price,
  ]);
}

{{ $orderPrice }}

Вложить файл

public function build() {

  return $this->view('emails.orders.shipped')
    ->attach('/path/to/file');

  return $this->view('emails.orders.shipped')
    ->attach('/path/to/file', [
      'as' => 'name.pdf', отображаемое имя
      'mime' => 'application/pdf', миме тип
  ]);

}

Если файл с диска ФС

public function build() {

  return $this->view('emails.orders.shipped')
    ->attachFromStorage('/path/to/file');

  return $this->view('emails.orders.shipped')
    ->attachFromStorage('/path/to/file', 'name.pdf', [
      'mime' => 'application/pdf'
  ]);

  return $this->view('emails.orders.shipped')
    ->attachFromStorageDisk('s3', '/path/to/file');
}

Вложение данные сгенеренных на лету без сохранения на диск

public function build() {

  return $this->view('emails.orders.shipped')
    ->attachData($this->pdf, 'name.pdf', [
    'mime' => 'application/pdf',
  ]);

}

Встраивание картинки (Embedding inline images)
$message автоматически доступна
кроме plain text писем

<img src="{{ $message->embed($pathToImage) }}">

Встраивание raw data

<img src="{{ $message->embedData($data, $name) }}">


Настройка SwiftMailer

public function build() {

  $this->view('emails.orders.shipped');

  в колбеке пишем свой функционал до отправки
  $this->withSwiftMessage(function ($message) {
    $message->getHeaders()
      ->addTextHeader('Custom-Header', 'HeaderValue');
  });
}


письма Markdown

php artisan make:mail OrderShipped --markdown=emails.orders.shipped

public function build() {

  return $this->from('example@example.com')
    ->markdown('emails.orders.shipped');

}

Внутри таких вьюх компоненты на основе Blade и Markdown

Кнопка
@component('mail::button', ['url' => $url, 'color' => 'success'])
View Order
@endcomponent

Панель
@component('mail::panel')
This is the panel content.
@endcomponent

Таблица
@component('mail::table')
| Laravel       | Table         | Example  |
| ------------- |:-------------:| --------:|
| Col 2 is      | Centered      | $10      |
| Col 3 is      | Right-Aligned | $20      |
@endcomponent

Экспорт всех компонентов для кастомизации в папку resources/views/vendor/mail
php artisan vendor:publish --tag=laravel-mail

CSS в файле resources/views/vendor/mail/html/themes/default.css
в конфиге mail в ключе theme можно свой файл добавить

В почтовом классе можно выбрать тему в переменной $theme


Отправка почты

массив почт, инстанс юзера, коллекцию юзеров
должны быть свойства email, name

Mail::to($request->user())
  ->send(new OrderShipped($order));

Mail::to($request->user())
  ->cc($moreUsers)
  ->bcc($evenMoreUsers)
  ->send(new OrderShipped($order));

Рассылка в цикле

foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {
  Mail::to($recipient)->send(new OrderShipped($order));
}

Отправить с определенного драйвера почты
в конфиге mail есть default драйвер. можно с другого

Mail::mailer('postmark')
  ->to($request->user())
  ->send(new OrderShipped($order));

Отправка письма в очередь задач

Mail::to($request->user())
  ->cc($moreUsers)
  ->bcc($evenMoreUsers)
  ->queue(new OrderShipped($order));

Отложить отправку на время
$when = now()->addMinutes(10);

Mail::to($request->user())
  ->cc($moreUsers)
  ->bcc($evenMoreUsers)
  ->later($when, new OrderShipped($order));

Отправка в нужную очередь

$message = (new OrderShipped($order))
  ->onConnection('sqs')
  ->onQueue('emails');

Mail::to($request->user())
  ->cc($moreUsers)
  ->bcc($evenMoreUsers)
  ->queue($message);

Классы рассылки которые всегда ставить в очередь
реализовать контракт ShouldQueue

class OrderShipped extends Mailable implements ShouldQueue {}


Получить письмо в HTML

$invoice = App\Invoice::find(1);
(new App\Mail\InvoicePaid($invoice))->render();

Получить письмо в HTML в браузере
в замыкании роута или из контроллера

Route::get('mailable', function () {

  $invoice = App\Invoice::find(1);
  return new App\Mail\InvoicePaid($invoice);

});

Локализация на языки

Mail::to($request->user())->locale('es')->send(
  new OrderShipped($order)
);

Сохранить локаль юзера и подставить автоматически

class User extends Model implements HasLocalePreference {
  public function preferredLocale() {
    return $this->locale;
  }
}
Mail::to($request->user())->send(new OrderShipped($order));


При локальной разработке
  почтовый драйвер log
  одна почта куда слать. настроить в config/mail.php в поле to => 'address, name'
  сервис Mailtrap и драйвер smtp

События
protected $listen = [

  до отправки
  'Illuminate\Mail\Events\MessageSending' => ['App\Listeners\LogSendingMessage'],

  после отправки
  'Illuminate\Mail\Events\MessageSent' => ['App\Listeners\LogSentMessage'],
];
-------------------------------------------------

Digging Deeper -> Notifications

Отправка уведомлений (У) по разным каналам почта, sms, slack
У - это короткие мессаги юзеру
Каждое У это отдельный класс в app/Notifications

создать У
php artisan make:notification InvoicePaid

в методе via вся логика
методы каналов toDatabase, toMail

отправить У

1. через трейт Notifiable
class User extends Authenticatable {
  use Notifiable;
  $user->notify(new InvoicePaid($invoice));
}

2. через фасад Notification
Notification::send($users, new InvoicePaid($invoice));

Каналы доставки
email, sms, database, broadcast, nexmo, slack
остальные https://laravel-notification-channels.com

public function via($notifiable) {
  return $notifiable->prefers_sms ? ['nexmo'] : ['mail', 'database'];
}

Очереди
настроить очереди
добавить в класс интерфейс ShouldQueue и трейт Queueable
они есть, если сгенерировали командой

class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  $user->notify(new InvoicePaid($invoice));
}

Задержка отправки

$when = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($when));

Указать канал и очередь

public function viaQueues() {
  return [
    'mail' => 'mail-queue',
    'slack' => 'slack-queue',
  ];
}

Отправить У анониму кто не зареган как User

Notification::route('mail', 'taylor@example.com')
  ->route('nexmo', '555')
  ->route('slack', 'https://hooks.slack.com/services')
  ->notify(new InvoicePaid($invoice));

УВЕДОМЛЕНИЯ ТИПА ПОЧТА

Форматирование
Создать метод toMail
В конструктор можно передать любые данные для шаблона письма

указать строки текста. шаблон будет сгенерен автоматически
public function toMail($notifiable) {

  $url = url('/invoice/'.$this->invoice->id);

  return (new MailMessage)
    ->greeting('Hello!')
    ->line('One of your invoices has been paid!')
    ->action('View Invoice', $url)
    ->line('Thank you for using our application!');
}

указать вьюху
public function toMail($notifiable) {
  return (new MailMessage)->view(
    'emails.name', ['invoice' => $this->invoice]
  );
}

указать версию plain text
public function toMail($notifiable) {
  return (new MailMessage)->view(
    ['emails.name.html', 'emails.name.plain'],
    ['invoice' => $this->invoice]
  );
}

формат письма как сообщение об ошибке. кнопка будет красной
public function toMail($notifiable) {
  return (new MailMessage)
    ->error()
    ->subject('Notification Subject')
    ->line('...');
}

Настройка отправителя (поля from)
настройка в config/mail.php

можно на лету
public function toMail($notifiable) {
  return (new MailMessage)
    ->from('test@example.com', 'Example')
    ->line('...');
}

Настройка получателя (поля to)
автоматически ищет свойство email в объекте

можно указать своё
public function routeNotificationForMail($notification) {
  return $this->email_address; почта
  return [$this->email_address => $this->name]; почта и имя
}

Настройка заголовка письма
заголовок письма это имя класса InvoicePaid разделенное пробелами "Invoice Paid"

можно свой
public function toMail($notifiable) {
  return (new MailMessage)
    ->subject('Notification Subject')
    ->line('...');
}

Настройка драйвера почты
берется из настроек config/mail.php

можно свой
public function toMail($notifiable) {
  return (new MailMessage)
    ->mailer('postmark')
    ->line('...');
}

Настройка шаблонов HTML

запустить команду
php artisan vendor:publish --tag=laravel-notifications

шаблоны появятся в
resources/views/vendor/notifications

Отладка HTML письма в браузере
Route::get('mail', function () {
  $invoice = App\Invoice::find(1);
  return (new App\Notifications\InvoicePaid($invoice))
    ->toMail($invoice->user);
});

Разметка Markdown
Красивые шаблоны У будут сгенерены по результатам разметки
Созданные компоненты Blade и Markdown

создать У с Markdown
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid

public function toMail($notifiable) {
  $url = url('/invoice/'.$this->invoice->id);
  return (new MailMessage)
    ->subject('Invoice Paid')
    ->markdown('mail.invoice.paid', ['url' => $url]); вьюха
}

Компоненты

кнопка
@component('mail::button', ['url' => $url, 'color' => 'green'])
View Invoice
@endcomponent

панель
@component('mail::panel')
This is the panel content
@endcomponent

таблица
@component('mail::table')
| Laravel       | Table         | Example  |
| ------------- |:-------------:| --------:|
| Col 2 is      | Centered      | $10      |
| Col 3 is      | Right-Aligned | $20      |
@endcomponent

Настройка компонентов
экспортировать компоненты себе сюда resources/views/vendor/mail
php artisan vendor:publish --tag=laravel-mail

Настройка css
resources/views/vendor/mail/html/themes/default.css
можно создать свой файл и прописать его в конфиге mail в поле theme

выбрать тему на лету
public function toMail($notifiable) {
  return (new MailMessage)
    ->theme('invoice')
    ->subject('Invoice Paid')
    ->markdown('mail.invoice.paid', ['url' => $url]);
}

УВЕДОМЛЕНИЯ ТИПА DATABASE
канал database. хранит У в таблице

создать таблицу
php artisan notifications:table
php artisan migrate

в классе У методы toDatabase и toArray
данные У сохраняются в поле data таблицы notifications
метод toArray используется для вещания в канал broadcast в JS либу

public function toArray($notifiable) {
  return [
    'invoice_id' => $this->invoice->id,
    'amount' => $this->invoice->amount,
  ];
}

Получить У
трейт Notifiable включен в модель App\User и в notifications Eloquent
у У есть поле created_at для сортировки по времени

$user = App\User::find(1);
foreach ($user->notifications as $notification) {
  echo $notification->type;
}

или

foreach ($user->unreadNotifications as $notification) {
  echo $notification->type; только непрочитанные
}

Отметить У как прочитанные
это обновит поле read_at в таблице

$user = App\User::find(1);
foreach ($user->unreadNotifications as $notification) {
  $notification->markAsRead();
}

можно вызвать на коллекции
$user->unreadNotifications->markAsRead();

или так массово без извлечения из БД
$user = App\User::find(1);
$user->unreadNotifications()->update(['read_at' => now()]);

Удалить У
$user->notifications()->delete();


УВЕДОМЛЕНИЯ ТИПА ВЕЩАНИЯ
на основе event broadcasting
канал broadcast
метод toBroadcast в классе У
вернет JSON данные

public function toBroadcast($notifiable) {
  return new BroadcastMessage([
    'invoice_id' => $this->invoice->id,
    'amount' => $this->invoice->amount,
  ]);
}

Настройка очереди
все уведомления broadcast стоят в очереди broadcasting

можно указать свою
return (new BroadcastMessage($data))
  ->onConnection('sqs')
  ->onQueue('broadcasts');

Настройка типа уведомлений
все уведомления типа broadcast имеют поле $type в котором имя класса У

изменить можно в методе
public function broadcastType() {
  return 'broadcast.message';
}

Прослушивание У
уведомления пускаются на приватном канале
через Laravel Echo, метод хелпер notification

Echo.private('App.User.' + userId)
  .notification((notification) => {
    console.log(notification.type);
});

Настройка канала
Если вы хотите настроить, по каким каналам уведомляемый объект получает уведомления

public function receivesBroadcastNotificationsOn() {
  return 'users.'.$this->id;
}

УВЕДОМЛЕНИЯ ТИПА SMS

пакет Nexmo
composer require laravel/nexmo-notification-channel

в .env прописать NEXMO_KEY, NEXMO_SECRET

Форматирование У
public function toNexmo($notifiable) {
  return (new NexmoMessage)
    ->content('Your SMS message content');
}

Отправка уведомлений с короткими кодами, которые представляют собой предварительно определенные шаблоны сообщений в вашей учетной записи Nexmo.

Поддержка отправки юникода

public function toNexmo($notifiable) {
  return (new NexmoMessage)
    ->content('Your unicode message')
    ->unicode();
}

Настройка номера FROM
настроить в конфиге config/services.php или на лету

public function toNexmo($notifiable) {
  return (new NexmoMessage)
    ->content('Your SMS message content')
    ->from('15554443333');
}

Отправить КОМУ

public function routeNotificationForNexmo($notification) {
  return $this->phone_number;
}

УВЕДОМЛЕНИЯ ТИПА SLACK

поставить пакет
composer require laravel/slack-notification-channel

настроить Incoming WebHooks

Форматирование уведомлений

public function toSlack($notifiable) {
  return (new SlackMessage)
    ->from('Ghost', ':ghost:') юзернейм
    ->to('#other') канал или юзернейм
    ->image('https://laravel.com/img/favicon/favicon.ico')
    ->content('One of your invoices has been paid!');
}

Вложения

public function toSlack($notifiable) {

  $url = url('/exceptions/'.$this->exception->id); ссылка

  return (new SlackMessage)
    ->error()
    ->content('Whoops! Something went wrong.')
    ->attachment(function ($attachment) use ($url) {
      $attachment->title('Exception: File Not Found', $url) анкор ссылки
        ->content('File [background.jpg] was not found.');
  });
}

передать таблицу

public function toSlack($notifiable) {
  $url = url('/invoices/'.$this->invoice->id);

  return (new SlackMessage)
    ->success()
    ->content('One of your invoices has been paid!')
    ->attachment(function ($attachment) use ($url) {
      $attachment->title('Invoice 1322', $url)
        ->fields([
          'Title' => 'Server Expenses',
          'Amount' => '$1,234',
          'Via' => 'American Express',
          'Was Overdue' => ':-1:',
        ]);
  });
}

Markdown

public function toSlack($notifiable) {
  $url = url('/exceptions/'.$this->exception->id);

  return (new SlackMessage)
    ->error()
    ->content('Whoops! Something went wrong.')
    ->attachment(function ($attachment) use ($url) {
      $attachment->title('Exception: File Not Found', $url)
        ->content('File [background.jpg] was *not found*.')
        ->markdown(['text']);
  });
}

Роутинг

это указание webhook URL
public function routeNotificationForSlack($notification) {
  return 'https://hooks.slack.com/services/...';
}

Локализация уведомлений
отправить У на языке отличном от текущего и запомнить язык

$user->notify((new InvoicePaid($invoice))->locale('es'));
Notification::locale('es')->send($users, new InvoicePaid($invoice)); фасад Notification

если язык запоминается в базе данных

public function preferredLocale() {
  return $this->locale;
}

тогда метод locale можно не вызывать
$user->notify(new InvoicePaid($invoice));

События системы У
когда У отправлено, запускается событие

в EventServiceProvider
protected $listen = [
  'Illuminate\Notifications\Events\NotificationSent' => ['App\Listeners\LogNotification'],
];

регнули слушателя. команда event:generate создаст класс Слушателя

public function handle(NotificationSent $event) {
  $event->channel
  $event->notifiable
  $event->notification
  $event->response
}

Можно создавать свои каналы и драйверы
-------------------------------------------------

Digging Deeper -> Package Development

Пакет - это способ добавить новый функционал. Содержит контроллеры-модели-вьюхи-роуты.
Универсальные пакеты типа Carbon, Behat добавлять через composer.

У контрактов и фасадов одинаковый уровень тестируемости.
Пакет для тестов https://github.com/orchestral/testbench

Автоматическое обнаружение пакета
Вручную в config/app.php в массив providers добавить СП пакета.
Автоматически, добавив СП в composer.json в ключ 'extra'. Там же прописать фасады пакета.

Отключить Автоматическое обнаружение пакета
добавить в composer.json в ключ "extra" в подключ "dont-discover".
можно поставить "*" чтобы отключить обнаружение всех пакетов.

СП связывает пакет и фреймворк.
СП привязывает контроллеры-модели-вьюхи-роуты к СК

КОНФИГИ

опубликовать конфиги пакета в папку config
в СП написать

public function boot() {
  $this->publishes([
    __DIR__.'/path/to/config/courier.php' => config_path('courier.php'),
  ]);
}

Юзер запустит команду vendor:publish
это скопирует конфиги в нужную папку
конфиг пакета будет доступен как обычный в формате файл.ключ

config('courier.option');

В конфигах не использовать замыкания

дефолтовый конфиг
слить конфиг пакета с копией в папке app

public function register() {
  $this->mergeConfigFrom(
    __DIR__.'/path/to/config/courier.php', 'courier'
  );
}

РОУТЫ

загрузить роуты пакета
public function boot() {
  $this->loadRoutesFrom(__DIR__.'/routes.php');
}

МИГРАЦИИ

загрузить миграции пакета
чтобы они автоматически запускались командой php artisan migrate

public function boot() {
  $this->loadMigrationsFrom(__DIR__.'/path/to/migrations');
}

ФАБРИКИ

загрузить фабрики пакета (database factories)
public function boot() {
  $this->loadFactoriesFrom(__DIR__.'/path/to/factories');
}

их использовать так
factory(Package\Namespace\Model::class)->create();

ПЕРЕВОДЫ

загрузить переводы пакета (translation files)
public function boot() {
  $this->loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');
}

доступ в формате package::file.line
trans('courier::messages.welcome');

опубликовать переводы пакета в папке приложения resources/lang/vendor
public function boot() {

  $this->loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');

  $this->publishes([
    __DIR__.'/path/to/translations' => resource_path('lang/vendor/courier'),
  ]);
}

юзер запускает команду vendor:publish и переводы окажутся в нужной папке

ВЬЮХИ
загрузить вьюхи пакета

public function boot() {
  $this->loadViewsFrom(__DIR__.'/path/to/views', 'courier');

  $this->publishes([
    __DIR__.'/path/to/views' => resource_path('views/vendor/courier'),
  ]);
}

формат доступа package::view

view('courier::admin');

вьюхи лежат в папке пакета
командой vendor:publish перекидываются в папку app для изменения

КОМПОНЕНТЫ
загрузить компоненты пакета (view components blade)

public function boot() {
  $this->loadViewComponentsAs('courier', [
    Alert::class,
    Button::class,
  ]);
}

использовать так

<x-courier-alert />
<x-courier-button />

анонимные компоненты так
<x-courier::alert />

КОМАНДЫ ARTISAN
загрузить команды пакета чтобы юзать в Artisan CLI

public function boot() {
  if ($this->app->runningInConsole()) {
    $this->commands([
      FooCommand::class,
      BarCommand::class,
    ]);
  }
}

ПУБЛИЧНЫЕ АКТИВЫ
assets
image, css, js

public function boot() {
  $this->publishes([
    __DIR__.'/path/to/assets' => public_path('vendor/courier'),
  ], 'public');
}

команда vendor:publish опубликует ресурсы в папке public
можно тегирование
php artisan vendor:publish --tag=public --force
флаг --force даст обновление ресурсов при обновлении самого пакета

Тегирование группы ресурсов
публикация группы ресурсов отдельно по тегам

public function boot() {

  $this->publishes([
    __DIR__.'/../config/package.php' => config_path('package.php')
  ], 'config');

  $this->publishes([
    __DIR__.'/../database/migrations/' => database_path('migrations')
  ], 'migrations');
}
php artisan vendor:publish --tag=config
-------------------------------------------------

Digging Deeper -> Queues

Laravel Horizon - это панель управления очередями на основе Redis.
Драйверы Beanstalk, Amazon SQS, Redis, Database, Synchronous (для локальной разработки), Null.

В очередь ставят тяжелые задачи
Конфиг config/queue.php

Соединение и Очередь

Соединение - это коннект к драйверам.
Соединение имеет очередь по умолчанию в ключе queue в конфиге.
В соединении может быть много очередей.
У каждой очереди может быть свой приоритет.

отправим задачу в очередь по умолчанию
Job::dispatch();

отправим задачу в очередь nameQueue
Job::dispatch()->onQueue('nameQueue');

Драйвер Database
таблица для задач

php artisan queue:table
php artisan migrate

Драйвер Redis, Redis Cluster
composer predis/predis

конфиг в config/database.php
настроить key hash tag
настроить block_for сколько ждать доступности задачи

Драйвер Amazon SQS
composer aws/aws-sdk-php

Драйвер Beanstalkd
composer pda/pheanstalk

Создать задачу
все задачи в app/Jobs
задачи запускают асинхронно

php artisan make:job ProcessPodcast

Логика в методе handle
он вызывается когда задача выполняется
СК автоматически разрешает зависимости в конструкторе класса задач

class ProcessPodcast implements ShouldQueue {
  public function __construct(Podcast $podcast) {
    $this->podcast = $podcast;
  }
  public function handle() {}
}

передать Eloquent модель в конструктор
бинарные данные типа картинок, должны быть переданы через метод base64_encode()

Полный контроль над тем, как СК внедряет зависимости, можно получить через метод

$this->app->bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) {
  return $job->handle($app->make(AudioProcessor::class));
});

Отношения других моделей Eloquent тоже загружаются.
Это можно предотвратить и загрузить модель без отношений

public function __construct(Podcast $podcast) {
  $this->podcast = $podcast->withoutRelations();
}

МВ для задач
МВ для задач оборачивает задачу логикой. Например логика ограничение скорости

public function handle() {

  Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {

	info('Lock obtained...');
    Handle job

    }, function () {

      Could not obtain lock
      return $this->release(5);

    });
}

Чтобы разгрузить метод handle от логики, положим логику в МВ app/Jobs/Middleware

class RateLimited {

  public function handle($job, $next) {
    Redis::throttle('key')
      ->block(0)->allow(1)->every(5)
      ->then(function () use ($job, $next) {
        // Lock obtained...
        $next($job);
      }, function () use ($job) {
        // Could not obtain lock...
        $job->release(5);
      });
    }
}

МВ job работает как МВ route
в класс задачи кладем МВ

public function middleware() {
  return [new RateLimited];
}

Отправка задачи в контроллере
ProcessPodcast::dispatch($podcast);

отправка по условию
ProcessPodcast::dispatchIf($accountActive === true, $podcast);
ProcessPodcast::dispatchUnless($accountSuspended === false, $podcast);

Отправить но отложить исполнение на время N
ProcessPodcast::dispatch($podcast)->delay(now()->addMinutes(10));

Отправить после того как Ответ придёт юзеру в браузер
SendNotification::dispatchAfterResponse();

или

dispatch(function () {
  Mail::to('taylor@laravel.com')->send(new WelcomeMessage);
})->afterResponse();

Синхронная отправка
отправка задачи сразу на выполнение без очереди
ProcessPodcast::dispatchNow($podcast);

Цепочки задач
список задач в нужной последовательности
если одна задача падает, то остальные не исполняются

ProcessPodcast::withChain([

  классы
  new OptimizePodcast,
  new ReleasePodcast,

  замыкание
  function () {
    Podcast::update(...);
  },

])->dispatch();

Удаление задачи
не остановит цепочку задач

$this->delete()

указать Соединение и Очередь

ProcessPodcast::withChain([
  new OptimizePodcast,
  new ReleasePodcast
])->dispatch()->allOnConnection('redis')->allOnQueue('podcasts');

Отправить задачу в нужную очередь
ProcessPodcast::dispatch($podcast)->onQueue('processing');

У разных очередей разное колво воркеров

Отправить задачу в нужное Соединение
ProcessPodcast::dispatch($podcast)->onConnection('sqs');

Отправить задачу в нужную Соединение и Очередь
ProcessPodcast::dispatch($podcast)
  ->onConnection('sqs')
  ->onQueue('processing');


Максимальное колво попыток выполнения задачи

через командную строку
php artisan queue:work --tries=3

в классе задачи. больший приоритет чем командная строка
public $tries = 5;

Выполнять задачу любое колво раз за N времени
также этот метод доступен в queued event listeners

public function retryUntil() {
  return now()->addSeconds(5);
}

Максимальное колво выброса исключений до обозначения задачи как невыполненной
Требуется PHP extension pcntl

public $maxExceptions = 3;

Максимальное количество секунд, в течение которых может выполняться задача

через командную строку
php artisan queue:work --timeout=30

в классе задачи. больший приоритет чем командная строка
public $timeout = 120;

Ограничение скорости
для драйвера Redis

запустить 10 раз каждые 60сек. key это имя класса задачи или модель Eloquent

Redis::throttle('key')->allow(10)->every(60)->then(function () {

  Job logic

}, function () {

  Could not obtain lock
  return $this->release(10);

});

Максимальное колво воркеров которые выполняют задачи. установить 1 воркер за 1 раз

Redis::funnel('key')->limit(1)->then(function () {

  Job logic

}, function () {

  Could not obtain lock
  return $this->release(10);

});

Обработка ошибок
если задача выбросила исключение то она возвращается в очередь
максимальное колво попыток задаётся в командной строке --tries или классе $tries


Задачи на основе Замыканий
dispatch(function () use ($podcast) {
  $podcast->publish();
});

Запуск воркера
работает до ручного выключения или закрытия терминала
фоновую работу воркера обеспечит Supervisor

php artisan queue:work

Воркер - это обработчик задач.
Воркер это демон, загружает в память код один раз.
Не перезагружает код после каждой задачи.
После изменения кода делать рестарт воркеров.

ручной рестарт воркеров
php artisan queue:listen

выбор Соединения
соединения прописаны в config/queue.php

php artisan queue:work redisconnection

выбор Соединения и Очереди
php artisan queue:work redisconnection --queue=emailsqueue

выполнить 1 задачу в очереди
php artisan queue:work --once

выполнить все задачи в очереди и выйти
php artisan queue:work --stop-when-empty

Приоритеты в очереди
в config/queue.php в ключе queue = low

на лету выставить высокий приоритет
dispatch((new Job)->onQueue('high'));

сначала выполнит задачи с высоким приоритетом, потом с низким
php artisan queue:work --queue=high,low

Деплой на сервер

сделать рестарт воркеров
php artisan queue:restart

сколько ждать перед следующей попыткой выполнить задачу
в config/queue.php ключ retry_after

сколько ждать перед тем как убить воркер. timeout всегда чуть короче чем retry_after
php artisan queue:work --timeout=60

сколько спать воркеру
php artisan queue:work --sleep=3


Supervisor
http://supervisord.org/index.html

установка
sudo apt-get install supervisor

конфиг
/etc/supervisor/conf.d

настройки
numprocs - колво воркеров
stopwaitsecs - должно быть больше самого длительной задачи воркера

команды
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start laravel-worker:*


Работа с невыполненными задачам

создать таблицу failed_jobs
php artisan queue:failed-table
php artisan migrate

колво попыток выполнить задачу
иначе выполнит 1 раз
php artisan queue:work redis --tries=3

сколько ждать перед следующей попыткой
иначе повторит немедленно
php artisan queue:work redis --delay=3

или в свойстве класса
public $retryAfter = 3;

или в методе класса
public function retryAfter() {return 3;}

если задача не выполнена, можно что-то вернуть
метод failed не вызывается если использовали dispatchNow
public function failed(Throwable $exception) {
  Send user notification of failure, etc...
}


если задача не выполнена то будет событие
в AppServiceProvider

public function boot() {
  Queue::failing(function (JobFailed $event) {
    $event->connectionName
    $event->job
    $event->exception
  });
}


посмотреть невыполненные задачи
php artisan queue:failed

запуск невыполненных задач по job ID
php artisan queue:retry 5

запуск невыполненных задач сразу много
php artisan queue:retry 5 6 7 8 9 10
php artisan queue:retry --range=5-10
php artisan queue:retry all все сразу

удалить невыполненные задачи
php artisan queue:forget 5
php artisan queue:flush

Задача ставится в очередь, модель Eloquent сериализуется и пишется в базу.
Время прошло, модель удалилась. Наступил запуск задачи.
Модели нет. Будет исключение ModelNotFoundException.

Настроить автоматическое удаление таких задач
public $deleteWhenMissingModels = true;

События
Ф Queue
методы before, after
События ДО и ПОСЛЕ выполнения задачи.

в AppServiceProvider

public function boot() {

  Queue::before(function (JobProcessing $event) {
    $event->connectionName
    $event->job
    $event->job->payload()
  });

  Queue::after(function (JobProcessed $event) {
    $event->connectionName
    $event->job
    $event->job->payload()
  });

  колбек выполнится до попыток воркера получить задачу из очереди
  Queue::looping(function () {
    while (DB::transactionLevel() > 0) {
      DB::rollBack();
    }
  });
}
-------------------------------------------------

Digging Deeper -> Task Scheduling

обычно 1 крон = 1 задача
такие задачи вне Гит
и нужен ssh


Крон
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1

Все задачи в классе App\Console\Kernel в методе schedule

protected function schedule(Schedule $schedule) {

  используя замыкание
  $schedule->call(function () {
    DB::table('recent_users')->delete();
  })->daily();

  используя вызываемые классы
  $schedule->call(new DeleteRecentUsers)->daily();

  команды Artisan
  $schedule->command('emails:send Taylor --force')->daily();
  $schedule->command(EmailsCommand::class, ['Taylor', '--force'])->daily();

  очереди задач
  $schedule->job(new Heartbeat)->everyFiveMinutes();
  $schedule->job(new Heartbeat, 'heartbeats')->everyFiveMinutes();

  команды оболочки shell
  $schedule->exec('node /home/forge/script.js')->daily();
}

Настройки

cron('* * * * *');

everyMinute(), everyTwoMinutes(), everyThreeMinutes(), everyFourMinutes(), everyFiveMinutes(), everyTenMinutes(), everyFifteenMinutes(), everyThirtyMinutes()

hourly(), hourlyAt(17), everyTwoHours(), everyThreeHours(), everyFourHours(), everySixHours()

daily(), dailyAt('13:00'), twiceDaily(1, 13)

weekly(), weeklyOn(1, '8:00')

monthly(), monthlyOn(4, '15:00'), lastDayOfMonth('15:00')

quarterly(), yearly()

timezone('America/New_York')

weekdays(), weekends(), sundays(), mondays(), tuesdays(), wednesdays(), thursdays(), fridays(), saturdays(), days(array|mixed), between($start, $end), unlessBetween($start, $end), when(Closure), skip(Closure) environments($env), at()

Цепочки

$schedule->command('foo')
  ->weekdays()
  ->hourly()
  ->timezone('America/Chicago')
  ->between('8:00', '17:00');

$schedule->call(function () {})
  ->weekly()
  ->mondays()
  ->at('13:00');

Таймзона для всех задач
в app/Console/Kernel.php

protected function scheduleTimezone() {
  return 'America/Chicago';
}

Таймзона на лету
->timezone('America/New_York');


Дублирование задач
Задачи будут стартовать, даже если предыдущая не закончилась.
Чтобы предотвратить дублирование

$schedule->command('emails:send')->withoutOverlapping();

сколько минут ждать лок
$schedule->command('emails:send')->withoutOverlapping(10);


Выполнение 1 задачи на 1 сервере
если несколько серверов
драйвер кеша database, memcached, redis

$schedule->command('report:generate')
  ->fridays()
  ->at('17:00')
  ->onOneServer();


Паралельное выполнение задач
По умолчанию все задачи выполняются последовательно

работает только для command и exec
$schedule->command('analytics:report')
  ->daily()
  ->runInBackground();

В режиме обслуживания сайта задачи не выполняются
чтобы выполнялись

$schedule->command('emails:send')->evenInMaintenanceMode();

Вывод результата задачи

вывод в файл
$schedule->command('emails:send')->daily()->sendOutputTo($filePath);

вывод в файл. добавлять
$schedule->command('emails:send')->daily()->appendOutputTo($filePath);

отправить по почте
$schedule->command('foo')->daily()->sendOutputTo($filePath)->emailOutputTo('foo@example.com');

отправить по почте только в случае сбоя
$schedule->command('foo')->daily()->emailOutputOnFailure('foo@example.com');

данные методы только для методов command и exec
emailOutputTo, emailOutputOnFailure, sendOutputTo, appendOutputTo


Хуки

$schedule->command('emails:send')
  ->daily()
  ->before(function () {
    до начала выполнения
  })
  ->after(function () {
    задача выполнена
});

$schedule->command('emails:send')
  ->daily()
  ->onSuccess(function () {
    задача выполнена успешно
  })
  ->onFailure(function () {
    задача не выполнилась
});


Пинг урлов

требуется
composer require guzzlehttp/guzzle

пинг урла до и после выполнения задачи
$schedule->command('emails:send')
  ->daily()
  ->pingBefore($url)
  ->thenPing($url);

если условие true
$schedule->command('emails:send')
  ->daily()
  ->pingBeforeIf($condition, $url)
  ->thenPingIf($condition, $url);

если условие false
$schedule->command('emails:send')
  ->daily()
  ->pingOnSuccess($successUrl)
  ->pingOnFailure($failureUrl);
-------------------------------------------------

Database -> Getting Started

Базы данных: MySQL 5.6+, PostgreSQL 9.4+, SQLite 3.8.8+, SQL Server 2017+
Методы: сырой SQL, query builder, Eloquent ORM

конфиг в config/database.php

SQLite

создать бд
touch database/database.sqlite

конфиг в .env
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
DB_FOREIGN_KEYS=true для ограничений внешнего ключа

настройки параметров host, database, username, password
или одним урлом driver://username:password@host:port/database?options в параметре DATABASE_URL или url

Отдельные соединения с БД для чтения (SELECT) и записи (INSERT, UPDATE, DELETE)
это будет работать для любого метода: сырой SQL, query builder, Eloquent ORM

'mysql' => [
  'read' => [],
  'write' => [],
  'sticky' => true, сразу разрешить чтение данных, которые были добавлены в текущем же запросе. запись была сделана, операция чтения возьмёт данные из соединения write а не read, ибо в read еще нет этих данных
];

фасад DB
методы select, update, insert, delete, statement, transaction

Доступ к разным Соединениям с БД

foo должно быть соединением с бд из config/database.php
DB::connection('foo');

доступ к сырому инстансу PDO
DB::connection()->getPdo();


Запросы сырого SQL

биндинг. привязка параметров. защищает от SQL injection. возвращает array
DB::select('select * from users where active = ?', [1]);

именованные параметры
DB::select('select * from users where id = :id', ['id' => 1]);

DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);

вернёт колво строк
DB::update('update users set votes = 100 where name = ?', ['John']);
DB::delete('delete from users');

для запросов не возвращающих значения
DB::statement('drop table users');


События и Слушатель запроса
в AppServiceProvider

public function boot() {
  DB::listen(function ($query) {
    $query->sql
    $query->bindings
    $query->time
  });
}

Транзакции
транзакция это набор операций. если возникла ошибка то всё откатывается назад

DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
});

отработка блокировок

5 - колво попыток проведения транзакции
DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
}, 5);

Транзакции вручную
эти методы для query builder и Eloquent ORM

DB::beginTransaction();
DB::rollBack();
DB::commit();
-------------------------------------------------

Database -> Query Builder

Query Builder (КБ) - это построитель запросов
Использует PDO для создания и выполнения запросов
Работает для всех систем БД
Привязки предотвращают атаки SQL injection
Ф DB
Метод DB::table возвращает инстанс КБ


Получить все строки (метод get)
DB::table('users')->get();

Получить 1ю строку (метод first)
DB::table('users')->where('name', 'John')->first();

Получить 1 строку по id (метод find)
DB::table('users')->find(3);

Получить 1 строку 1 столбик (метод value)
DB::table('users')->where('name', 'John')->value('email');

Получить все строки по 1 или нескольким столбикам (метод pluck)
DB::table('roles')->pluck('title');
DB::table('roles')->pluck('title', 'name');

Получить все строки чанками по N (метод chunk)
DB::table('users')->chunk(100, function ($users) {});

Обновить все строки чанками (метод chunkById)
DB::table('users')->chunkById(100, function ($users) {
  foreach ($users as $user) {
    DB::table('users')->where('id', $user->id)->update(['active' => true]);
  }
});


Агрегатные функции
DB::table('users')->count();
DB::table('users')->max();
DB::table('users')->min();
DB::table('users')->avg();
DB::table('users')->sum();

Проверка на существование
DB::table('users')->exists();
DB::table('users')->doesntExist();


Select

выбрать нужные столбики
DB::table('users')->select('name', 'email as user_email')->get();

работа с distinct
DB::table('users')->distinct()->get();

на лету добавить в select еще столбик
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();


Сырые запросы
метод DB::raw
самому обрабатывать код против SQL injection

DB::table('users')->select(DB::raw('count(*) as user_count, status'))->get();


Вместо DB::raw можно использовать методы

selectRaw вместо addSelect(DB::raw())
DB::table('orders')->selectRaw('price * ? as price1', [1.08])->get();

whereRaw и orWhereRaw вместо where
DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 10)', [20])->get();

havingRaw и orHavingRaw вместо having
DB::table('orders')->select('department', ...)->groupBy('department')->havingRaw('SUM(price) > ?', [25])->get();

orderByRaw вместо order by
DB::table('orders')->orderByRaw('updated_at - created_at DESC')->get();

groupByRaw вместо group by
DB::table('orders')->select(...)->groupByRaw('city, state')->get();


Запросы JOIN

Inner Join (базовое внутреннее соединение)

DB::table('users')
  ->join('contacts', 'users.id', '=', 'contacts.user_id')
  ->join('orders', 'users.id', '=', 'orders.user_id')
  ->select('users.*', 'contacts.phone', 'orders.price')
  ->get();

Left Join, Right Join

DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')->get();
DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')->get();

Cross Join (перекрестное соединение)
декартово произведение таблиц

DB::table('sizes')->crossJoin('colors')->get();


Дополнения к Join

можно указать свои условия соединения в замыкании

DB::table('users')
  ->join('contacts', function ($join) {
    $join->on('users.id', '=', 'contacts.user_id')
	->orOn(...);
  })
  ->get();

использование дополнительных методов where и orWhere

DB::table('users')
  ->join('contacts', function ($join) {
    $join->on('users.id', '=', 'contacts.user_id')
      ->where('contacts.user_id', '>', 5);
  })
  ->get();

использование методов joinSub, leftJoinSub, rightJoinSub для подзапросов внутри

$latestPosts = DB::table('posts')
  ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)
  ->groupBy('user_id');

$users = DB::table('users')
  ->joinSub($latestPosts, 'latest_posts', function ($join) {
    $join->on('users.id', '=', 'latest_posts.user_id');
})->get();


Запросы Union
метод union и unionAll
чтобы слить результаты запросов

$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first)->get();


Уточнения по Where
DB::table('users')->where('votes', 10)->get();
DB::table('users')->where('votes', '=', 10)->get(); аналог верхней строки
DB::table('users')->where('votes', '>=', 10)->get();
DB::table('users')->where('name', 'like', 'T%')->get();
DB::table('users')->where([['status', '=', '1'], ['subscribed', '<>', '1']])->get(); массив условий


Метод orWhere
DB::table('users')->orWhere('name', 'John')->get();

группировка внутри or (... and ...)
DB::table('users')->where('votes', '>', 100)->orWhere(function($query) {
  $query->where('name', 'Abigail')->where('votes', '>', 50);
})
->get();


Дополнительные методы
whereBetween, orWhereBetween
whereNotBetween, orWhereNotBetween
whereIn, whereNotIn
orWhereIn, orWhereNotIn
whereIntegerInRaw, whereIntegerNotInRaw (когда внутри IN() большой массив)
whereNull, whereNotNull
orWhereNull, orWhereNotNull
whereDate, whereMonth, whereDay, whereYear, whereTime для сравнения с датой
whereColumn, orWhereColumn для сравнения 2 столбиков


Группировка параметров скобочками внутри замыкания
выдаст select * from users where name = 'John' and (votes > 100 or title = 'Admin')
Всегда группировать вызовы orWhere

DB::table('users')
  ->where('name', '=', 'John')
  ->where(function ($query) {
    $query->where('votes', '>', 100)
      ->orWhere('title', '=', 'Admin');
})->get();


Метод whereExists
select * from users where exists (select 1 from orders where orders.user_id = users.id)

DB::table('users')
  ->whereExists(function ($query) {
    $query->select(DB::raw(1))
      ->from('orders')
      ->whereRaw('orders.user_id = users.id');
})->get();


Подзапрос во Where

User::where(function ($query) {
  $query->select('type')
    ->from('membership')
    ->whereColumn('user_id', 'users.id')
    ->orderByDesc('start_date')
    ->limit(1);
}, 'Pro')->get();


Запросы из JSON столбиков

DB::table('users')->where('options->language', 'en')->get();
DB::table('users')->where('preferences->dining->meal', 'salad')->get();
DB::table('users')->whereJsonContains('options->languages', 'en')->get(); не поддерживается SQLite
DB::table('users')->whereJsonContains('options->languages', ['en', 'de'])->get(); для MySQL и PostgreSQL поддержка массива

DB::table('users')->whereJsonLength('options->languages', 0)->get(); запросы по длинне
DB::table('users')->whereJsonLength('options->languages', '>', 1)->get(); запросы по длинне

Сортировка
DB::table('users')->orderBy('name', 'desc')->get(); сортировка в указанном направлении
DB::table('users')->orderBy('name', 'desc')->orderBy('email', 'asc')->get(); сортировка по нескольким столбикам

сортировка по дате (по столбику created_at)
можно передать своё имя столбика
DB::table('users')->latest()->first();

сортировка рандомная
DB::table('users')->inRandomOrder()->first();

удалить сортировку
$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();

удалить сортировку и применить новую
$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();


Группировка
методы groupBy и having (работает как where)

DB::table('users')->groupBy('account_id')->having('account_id', '>', 100)->get();
DB::table('users')->groupBy('first_name', 'status')->having('account_id', '>', 100)->get(); группировка по нескольким столбикам


Лимит и офсет
skip это limit
take это offset

DB::table('users')->skip(10)->take(5)->get();
DB::table('users')->offset(10)->limit(5)->get();

Условные добавления в запрос

метод when выполняет Замыкание, когда переданный параметр true

$role = $request->input('role');
$users = DB::table('users')
  ->when($role, function ($query, $role) {
    return $query->where('role_id', $role);
})->get();

случай когда 2 замыкания, второе когда переданный параметр false

$sortBy = null;
$users = DB::table('users')
  ->when($sortBy, function ($query, $sortBy) {
    return $query->orderBy($sortBy);
  }, function ($query) {
    return $query->orderBy('name');
})->get();


Вставка строк
методы insert, insertOrIgnore, insertGetId

вставка 1 строки
DB::table('users')->insert(['email' => 'john@example.com', 'votes' => 0]);

вставка много строк
DB::table('users')->insert([
  ['email' => 'taylor@example.com', 'votes' => 0],
  ['email' => 'dayle@example.com', 'votes' => 0],
]);


будет игнорирование дубликатов строк при вставке

DB::table('users')->insertOrIgnore([
  ['id' => 1, 'email' => 'taylor@example.com'],
  ['id' => 2, 'email' => 'dayle@example.com'],
]);

вставка 1 строки и получить вставленный ID
по умолчанию это столбик id но можно передать свой

$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);
$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0], 'id_user');


Обновления строк
метод update, updateOrInsert

обновить строку
$affected = DB::table('users')->where('id', 1)->update(['votes' => 1]);

обновить строку или вставить если её нет
если строка не найдена, то она будет вставлена с данными из обоих массивов

DB::table('users')
  ->updateOrInsert(
    ['email' => 'john@example.com', 'name' => 'John'], массив условий по которому найти строку
    ['votes' => '2'] что обновлять
);


обновить строку JSON
$affected = DB::table('users')->where('id', 1)->update(['options->enabled' => true]);


Инкремент и Декремент столбика
метод increment и decrement
для них не работают События Модели

DB::table('users')->increment('votes');
DB::table('users')->increment('votes', 5); на +5
DB::table('users')->decrement('votes');
DB::table('users')->decrement('votes', 5);
DB::table('users')->increment('votes', 1, ['name' => 'John']); попутно что-то еще обновим


Удаление строк
метод delete и truncate

DB::table('users')->delete();
DB::table('users')->where('votes', '>', 100)->delete();
DB::table('users')->truncate(); удалит все строки и сбросит счетчик ID


Блокировка
метод sharedLock и lockForUpdate

DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
shared lock предотвращает изменение данных строк, пока транзакция не будет зафиксирована

DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();
for update lock предотвращает изменение данных строк или их выбор, пока существует shared lock

Отладка запросов
метод dd и dump

DB::table('users')->where('votes', '>', 100)->dd(); покажет и остановит скрипт
DB::table('users')->where('votes', '>', 100)->dump(); покажет и продолжит скрипт
-------------------------------------------------

Database -> Pagination

Пагинатор интегрирован в query builder и Eloquent ORM
Пагинация результатов query builder
get параметр должен называться page
метод groupBy не работает с методом paginate, поэтому создать пагинатор вручную

вывод по 15 элементов на страницу
DB::table('users')->paginate(15);

если нужны только ссылки Вперед и Назад
DB::table('users')->simplePaginate(15);

Пагинация результатов Eloquent
App\User::paginate(15);
User::where('votes', '>', 100)->paginate(15);
User::where('votes', '>', 100)->simplePaginate(15);

Создать пагинатор вручную

от Illuminate\Pagination\Paginator (аналог simplePaginate)
от Illuminate\Pagination\LengthAwarePaginator (аналог paginate)


Ссылки пагинатора
{{ $users->links() }}

Изменить ссылки
будут такие ссылки /custom/url?page=N
$users = App\User::paginate(15);
$users->withPath('custom/url');

Добавить параметр к ссылкам
добавит sort=votes в query string
{{ $users->appends(['sort' => 'votes'])->links() }}

Добавить весь query string к ссылкам
{{ $users->withQueryString()->links() }}

Добавить хеш к ссылкам
добавит #foo
{{ $users->fragment('foo')->links() }}

Настройка колва ссылок
по умолчанию 3
{{ $users->onEachSide(5)->links() }}

Конвертация пагинатора в JSON
метод toJson

{
  "total": 50,
  "per_page": 15,
  "current_page": 1,
  "last_page": 4,
  "first_page_url": "http://laravel.app?page=1",
  "last_page_url": "http://laravel.app?page=4",
  "next_page_url": "http://laravel.app?page=2",
  "prev_page_url": null,
  "path": "http://laravel.app",
  "from": 1,
  "to": 15,
  "data":[
    {Result Object},
    {Result Object}
   ]
}

Изменить внешний вид ссылок
передадим вью
{{ $paginator->links('view.name') }}
{{ $paginator->links('view.name', ['foo' => 'bar']) }}

экспортим вьюхи в свой каталог resources/views/vendor/pagination
изменять в bootstrap-4.blade.php
php artisan vendor:publish --tag=laravel-pagination

изменить название этого файла
в AppServiceProvider

public function boot() {

  Paginator::defaultView('view-name');
  Paginator::defaultSimpleView('view-name');

  смена дизайна с Bootstrap на Tailwind CSS
  Paginator::useTailwind();
}

Все методы пагинатора
count, currentPage, firstItem, getOptions, getUrlRange, hasPages, hasMorePages, items, lastItem, lastPage, nextPageUrl, onFirstPage, perPage, previousPageUrl, total, url, getPageName, setPageName
-------------------------------------------------

Database -> Migrations

Миграции - это аналог системы контроля версий для структуры БД
Ф Schema
Миграции лежат в database/migrations

Создать миграцию
php artisan make:migration create_users_table

параметр create это имя таблицы
php artisan make:migration create_users_table --create=users

параметр table это указать что надо создавать новую таблицу
php artisan make:migration add_votes_to_users_table --table=users

параметр --path - альтернативный путь до миграций

Класс миграции
метод up - добавление таблиц-столбцов-индексов
метод down - реверс операций сделанных в методе up

в обоих методах используется schema builder

Создать таблицу

public function up() {

  Schema::create('flights', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('airline');
    $table->timestamps();
  });

}

public function down() {
  Schema::drop('flights');
}

Запуск миграций
php artisan migrate

запуск без подтверждения. для миграций оно появляется если есть удаления
php artisan migrate --force

Откат миграций

php artisan migrate:rollback откатит последнюю
php artisan migrate:rollback --step=5 откатит последние 5

php artisan migrate:reset откатить все

php artisan migrate:refresh откатить все, и потом выполнить команду migrate. по сути пересоздание БД
php artisan migrate:refresh --seed пересоздать БД и выполнить посев
php artisan migrate:refresh --step=5 откатит и повторно перенесет последние 5 миграций

php artisan migrate:fresh удалит все таблицы, и потом выполнить команду migrate
php artisan migrate:fresh --seed


Создать таблицу
Schema::create('users', function (Blueprint $table) {
  $table->id();
});

Проверка на существование таблицы или столбика
if (Schema::hasTable('users')) {}
if (Schema::hasColumn('users', 'email')) {}

Выбрать соединение
Schema::connection('foo')->create('users', function (Blueprint $table) {
  $table->id();
});

Методы
$table->engine = 'InnoDB';
$table->charset = 'utf8mb4';
$table->collation = 'utf8mb4_unicode_ci';
$table->temporary();

Переименовать таблицу
Schema::rename($from, $to);

Удалить таблицу
Schema::drop('users');
Schema::dropIfExists('users');

Создать столбик
Schema::table('users', function (Blueprint $table) {
    $table->string('email');
});

Типы данных для столбиков
$table->id();
$table->boolean('confirmed');
$table->enum('level', ['easy', 'hard']);
$table->integer('votes');
$table->text('description');
$table->timestamp('added_on', 0);
и еще много

Модификаторы столбиков
Schema::table('users', function (Blueprint $table) {
  $table->string('email')->nullable();
});

еще:
->after('column')
->autoIncrement()
->comment('my comment')
и еще много


метод default и выражение Expression предотвратит заключение в кавычки
и позволит использовать специфичные функции

Schema::create('flights', function (Blueprint $table) {
  $table->id();
  $table->json('movies')->default(new Expression('(JSON_ARRAY())'));
  $table->timestamps();
});

Изменить столбик (метод change)
поставить composer require doctrine/dbal

Schema::table('users', function (Blueprint $table) {
    $table->string('name', 50)->change();
});

Schema::table('users', function (Blueprint $table) {
    $table->string('name', 50)->nullable()->change();
});

Переименовать столбик (метод renameColumn)
все столбики кроме enum
поставить composer require doctrine/dbal

Schema::table('users', function (Blueprint $table) {
  $table->renameColumn('from', 'to');
});

Удалить столбик (метод dropColumn)
поставить composer require doctrine/dbal

Schema::table('users', function (Blueprint $table) {
  $table->dropColumn('votes');
});

удалить несколько столбиков
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn(['votes', 'avatar', 'location']);
});

Методы работы со столбиками
dropMorphs, dropRememberToken, dropSoftDeletes, dropSoftDeletesTz, dropTimestamps, dropTimestampsTz

Создать индекс
имена индексов создаются автоматом на основе имени таблицы и столбика

$table->string('email')->unique();
$table->unique('email'); создать индекс после создания столбика
$table->index(['account_id', 'created_at']); составной индекс
$table->unique('email', 'unique_email'); задать своё имя индекса

Методы индексов
primary(), unique(), index(), spatialIndex()


Длинна индексов

По умолчанию кодировка utf8mb4
если MySQL 5.7.7+ или MariaDB 10.2.2+ то вручную настроить длину строки по умолчанию
в AppServiceProvider

public function boot() {
  Schema::defaultStringLength(191);
}

или
включить опцию innodb_large_prefix

Переименовать индекс
$table->renameIndex('from', 'to')

Удалить индекс указав имя индекса

$table->dropPrimary('indexname');
$table->dropUnique('indexname');
$table->dropIndex('indexname');
$table->dropSpatialIndex('indexname');

Удалить индекс указав имя столбика, правильный индекс сгенерится сам
Schema::table('geo', function (Blueprint $table) {
  $table->dropIndex(['state']); - автоназвание geo_state_index
});

Ограничения внешнего ключа
foreign key constraints

Связь users.id -> posts.user_id

Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');
});

более короткая запись
foreignId это алиас для unsignedBigInteger

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained();
});

constrained автоматически найдет таблицу и столбик. но можно уточнить

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained('users');
});

можно указать Action для On Delete и On Update

$table->foreignId('user_id')->constrained()->onDelete('cascade');

можно указать модификаторы столбиков
$table->foreignId('user_id')->nullable()->constrained();

Удалить внешний ключ по названию ключа
$table->dropForeign('posts_user_id_foreign');

В ограничениях внешнего ключа используется то же соглашение об именах, что и в индексах
на основе имени таблицы и столбика за которыми суффикс _foreign

Удалить внешний ключ по названию столбца, а имя ключа сгенерится автоматом
$table->dropForeign(['user_id']);

Включить и отключить ограничения внешнего ключа
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();

в SQLite по умолчанию ограничение внешнего ключа отключено
Его нужно включить в config/database.php в параметре DB_FOREIGN_KEYS = true
SQLite поддерживает внешние ключи только при создании таблицы, а не при изменении
-------------------------------------------------

Database -> Seeding

Заполнить БД тестовыми данными
классы лежат в database/seeds
зависимости разрешаются через СК

создать сеялку
php artisan make:seeder UserSeeder

С query builder
public function run() {
  DB::table('users')->insert([
    'name' => Str::random(10),
    'email' => Str::random(10).'@gmail.com',
    'password' => Hash::make('password'),
  ]);
}

С фабрики моделей Eloquent
public function run() {
  factory(App\User::class, 50)->create()->each(function ($user) {
    $user->posts()->save(factory(App\Post::class)->make());
  });
}

Запуск нескольких сеялок
в DatabaseSeeder

public function run() {
  $this->call([
    UserSeeder::class,
    PostSeeder::class,
    CommentSeeder::class,
  ]);
}

Запуск сеялок
сеялки написать

сделать перезагрузку Composer autoloader
composer dump-autoload

запустить класс DatabaseSeeder и всё что внутри
php artisan db:seed

запустить отдельную сеялку
php artisan db:seed --class=UserSeeder

удалить все таблицы и перезапустить миграции
php artisan migrate:fresh --seed

Запуск без дополнительного подтверждения
php artisan db:seed --force
-------------------------------------------------

Database -> Redis

Redis - это хранилище пар ключ-значение
composer require predis/predis
Ф Redis
команды https://redis.io/commands

Для скорости поставить PhpRedis PHP extension PECL
Конфиг в config/database.php в массиве redis

Соединение требует name, host, port, password, database
Или единый url

включить 'scheme' => 'tls' (TLS/SSL)
или будет 'tcp' по умолчанию

Настройка кластера серверов redis
в файле настроек в массиве clusters

Расширение Predis
REDIS_CLIENT = predis
поддерживает разные Соединения

Расширение PhpRedis
установлено по умолчанию
REDIS_CLIENT = phpredis

Чтобы использовать PhpRedis и Ф Redis
чтобы не было конфликта
в app.php переименовать так
'RedisManager' => Illuminate\Support\Facades\Redis::class

Вызов команд

Redis::get('user:profile:'.$id);
Redis::set('name', 'Taylor');
Redis::lrange('names', 5, 10);
Redis::command('lrange', ['name', 5, 10]);

Выбрать соединение

Redis::connection();
Redis::connection('my-connection');

Отправка сразу много команд (pipelining)

Redis::pipeline(function ($pipe) {
  for ($i = 0; $i < 1000; $i++) {
    $pipe->set("key:$i", $i);
  }
});

Publish и Subscribe на каналы

public function handle() {
  Redis::subscribe(['test-channel'], function ($message) {
    echo $message;
  });
}

Route::get('publish', function () {
  Redis::publish('test-channel', json_encode(['foo' => 'bar']));
});


Подписка на много каналов

Redis::psubscribe(['*'], function ($message, $channel) {
  echo $message;
});

Redis::psubscribe(['users.*'], function ($message, $channel) {
  echo $message;
});
-------------------------------------------------

Eloquent ORM -> Getting Started

Eloquent ORM - это реализация паттерна ActiveRecord

Таблица это Модель
Модели в app/Models

Аттрибуты модели - это столбики
Модели Eloquent - это тоже query builder, и доступны все его методы

конфиг config/database.php


создать модель
php artisan make:model Flight

создать модель и миграцию
php artisan make:model Flight --migration
php artisan make:model Flight -m аналог --migration

Пример

class Flight extends Model {

  имя таблицы. по умолчанию будет искать flights. можно своё
  protected $table = 'my_flights';

  имя первичного ключа. по умолчанию id (autoincrement, int). можно свой
  protected $primaryKey = 'flight_id';

  если первичный ключ не (autoincrement, int)
  public $incrementing = false;

  если первичный ключ не (int)
  protected $keyType = 'string';

  если не хотим автоматического наполнения столбиков created_at, updated_at
  public $timestamps = false;

  установить свой формат для timestamp
  protected $dateFormat = 'U';

  установить свои имена столбиков вместо created_at, updated_at
  const CREATED_AT = 'creation_date';
  const UPDATED_AT = 'last_update';

  выбрать Соединение
  protected $connection = 'connection-name';

  значения по умолчанию для столбиков
  protected $attributes = [
    'delayed' => false,
  ];

}

получить все строки
App\Flight::all();

получить некоторые строки
App\Flight::where('active', 1)->orderBy('name', 'desc')->take(10)->get();

обновить модель

метод fresh не переизвлекает модель из БД
$flight = App\Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh();

метод refresh переизвлекает модель из БД
$flight = App\Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"

метод all и get возвращают Коллекции
поэтому доступны все методы Коллекций

Получить все строки чанками по N
Flight::chunk(200, function ($flights) {});

Получить все строки по 1 (курсоры)
foreach (Flight::where('foo', 'bar')->cursor() as $flight) {}

курсор возвращает ленивые Коллекции LazyCollection
поэтому доступны все методы ленивых коллекций

App\User::cursor()->filter(function ($user) {
  return $user->id > 500;
});


Подзапросы в Select
для выборки из связанных таблиц

Destination::addSelect(['last_flight' => Flight::select('name')
  ->whereColumn('destination_id', 'destinations.id')
  ->orderBy('arrived_at', 'desc')
  ->limit(1)
])->get();

Подзапросы в OrderBy
для выборки из связанных таблиц

Destination::orderByDesc(
  Flight::select('arrived_at')
    ->whereColumn('destination_id', 'destinations.id')
    ->orderBy('arrived_at', 'desc')
    ->limit(1)
)->get();


Получение моделей

по id
App\Flight::find(1);
App\Flight::find([1, 2, 3]);

1ю модель из выборки
App\Flight::where('active', 1)->first();
App\Flight::firstWhere('active', 1);

1ю модель из выборки, а если нет то выполнить замыкание
App\Flight::where('legs', '>', 100)->firstOr(function () {});

1ю модель из выборки, а если нет то выполнить замыкание. выберем только нужные столбики
App\Flight::where('legs', '>', 100)->firstOr(['id', 'legs'], function () {});

если модели не найдены, то будет выброшено исключение ModelNotFoundException
удобно для контроллеров и роутов
если исключение не перехвачено, то юзеру будет отправлен ответ HTTP 404

App\Flight::findOrFail(1);
App\Flight::where('legs', '>', 100)->firstOrFail();


Агрегатные функции
все агрегатные функции из query builder

App\Flight::where('active', 1)->count();
App\Flight::where('active', 1)->sum('price');
App\Flight::where('active', 1)->max('price');
итд

Вставка модели
$flight = new Flight;
$flight->name = $request->name;
$flight->save();
столбики created_at и updated_at обновятся сами

Обновление модели
$flight = App\Flight::find(1);
$flight->name = 'New Flight Name';
$flight->save();

Массовое обновление
для методов saving, saved, updating, updated не срабатывают события модели

App\Flight::where('active', 1)
  ->where('destination', 'San Diego')
  ->update(['delayed' => 1]);

Контроль изменения аттрибутов модели
методы isDirty, isClean, wasChanged, getOriginal

проверка внутреннего состояния модели, с момента как они были загружены

$user->isDirty();
$user->isDirty('title');

$user->isClean();
$user->isClean('title');

$user->wasChanged();
$user->wasChanged('title');

$user->getOriginal();
$user->getOriginal('title');

Вставка модели (метод create)

Указание аттрибутов модели для массового назначения
Модели Eloquent по умолчанию защищены от массового назначения

class Flight extends Model {

  столбик name сделали массово назначаемым
  protected $fillable = ['name'];

  сделать все столбики назначаемыми
  protected $guarded = [];
}

вставляем модель
$flight = App\Flight::create(['name' => 'Flight 10']);

если модель уже есть то можно вставить так
$flight->fill(['name' => 'Flight 22']);


Другие методы создания

найти модель
если такой нет, то вставит новую модель с этими аттрибутами

App\Flight::firstOrCreate(['name' => 'Flight 10']);
App\Flight::firstOrCreate(['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30']);

найти модель
если такой нет, то создаст новую модель с этими аттрибутами
сохранить самому через вызов save()

App\Flight::firstOrNew(['name' => 'Flight 10']);
App\Flight::firstOrNew(['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30']);

обновить модель
если такой нет, то вставит новую модель с этими аттрибутами
App\Flight::updateOrCreate(['departure' => 'Oakland', 'destination' => 'San Diego'], ['price' => 99, 'discounted' => 1]);


Удалить модель

с извлечением модели из БД явно по ключу
$flight = App\Flight::find(1);
$flight->delete();

без извлечения
App\Flight::destroy(1); тоже по ключу
App\Flight::destroy(1, 2, 3);
App\Flight::destroy([1, 2, 3]);
App\Flight::destroy(collect([1, 2, 3]));

события модели deleting и deleted, будут работать с методом destroy()

удалить несколько моделей
App\Flight::where('active', 0)->delete();

для массового удаления не работают события модели deleting и deleted

Мягкое удаление строк
без фактического удаления
на базе столбика deleted_at в котором время удаления

class Flight extends Model {
  use SoftDeletes; подключаем трейт
}

в Schema builder есть метод для создания этого столбика

public function up() {
  Schema::table('flights', function (Blueprint $table) {
    $table->softDeletes();
  });
}

public function down() {
  Schema::table('flights', function (Blueprint $table) {
    $table->dropSoftDeletes();
  });
}

На модели вызываем метод delete и он будет в столбик deleted_at вставлять дату удаления
и строка какбы удалена
В методах выборки (select) эта строка исключается

проверка что строка мягко удалена
if ($flight->trashed()) {}

Получить все строки, в том числе мягко удаленные (метод withTrashed)

App\Flight::withTrashed()->where('account_id', 1)->get();
$flight->history()->withTrashed()->get();

Получить только мягко удаленные строки (метод onlyTrashed)

App\Flight::onlyTrashed()->where('airline_id', 1)->get();

Сделать мягко удаленную строку снова неудаленной

$flight->restore();
$flight->history()->restore();

Сделать сразу много мягко удаленных строк снова неудаленными
App\Flight::withTrashed()->where('airline_id', 1)->restore();

Реально удалить мягко удаленные строки
$flight->forceDelete();
$flight->history()->forceDelete();


Создать несохраненную копию экземпляра модели
клон

$shipping = App\Address::create([
  'type' => 'shipping',
  'line_1' => '123 Example Street',
]);
$billing = $shipping->replicate()->fill(['type' => 'billing']);
$billing->save();


Глобальные области для Запросов
позволяют добавить ограничения для всех запросов к модели
мягкое удаление сделано на таком же принципе

класс области AgeScope, интерфейс Scope, метод apply, в него добавим ограничения

class AgeScope implements Scope {
  public function apply(Builder $builder, Model $model) {
    $builder->where('age', '>', 200);
  }
}

если в методе apply добавляем в селект столбики, то юзать метод addSelect вместо метода select

Область прикрутим к модели

class User extends Model {
  protected static function booted() {
    static::addGlobalScope(new AgeScope);
  }
}

Области на основе Замыканий

class User extends Model {
  protected static function booted() {
    static::addGlobalScope('age', function (Builder $builder) {
      $builder->where('age', '>', 200);
    });
  }
}

Для конкретного запроса удалить Область

User::withoutGlobalScope(AgeScope::class)->get();
User::withoutGlobalScope('age')->get(); если область задана через замыкание

Удалить все области
User::withoutGlobalScopes()->get();

Удалить конкретные области
User::withoutGlobalScopes([FirstScope::class, SecondScope::class])->get();

Локальные области
это наборы ограничений для использования в разных местах
это методы в модели Eloquent
эти методы с префиксом scope
методы всегда возвращают query builder


class User extends Model {

  public function scopePopular($query) {
    return $query->where('votes', '>', 100);
  }

  public function scopeActive($query) {
    return $query->where('active', 1);
  }

  метод с параметрами
  public function scopeOfType($query, $type) {
    return $query->where('type', $type);
  }

}

вызываются такие методы без префикса scope
App\User::popular()->active()->orderBy('created_at')->get();

App\User::popular()->orWhere(function (Builder $query) {
  $query->active();
})->get();

или

App\User::popular()->orWhere->active()->get();

вызов метода с параметрами
App\User::ofType('admin')->get();


Сравнить модели
if ($post->is($anotherPost)) {}
проверяет на совпадение Соединение-Таблица-первичный ключ


События
retrieved извлечение
creating, created модель сохраняется первый раз
updating, updated существующая модель сохраняется
saving, saved модель создана или обновлена
deleting, deleted,
restoring, restored

массовое обновление или удаление не вызывает событий saved, updated, deleting, deleted

класс модели

class User extends Authenticatable {

  свяжем события и классы
  protected $dispatchesEvents = [
    'saved' => UserSaved::class,
    'deleted' => UserDeleted::class,
  ];
}

вместо классов событий, можно использовать замыкания

class User extends Model {
  protected static function booted() {
    static::created(function ($user) {});
  }
}


Наблюдатели
когда на модели много событий, то наблюдатель группирует всех слушателей в один класс
в классе наблюдателя методы названы как события модели

создать наблюдателя

php artisan make:observer UserObserver --model=User

классы наблюдателей в App/Observers

class UserObserver {
  public function created(User $user) {}
  public function updated(User $user) {}
  public function deleted(User $user) {}
  public function forceDeleted(User $user) {}
}

наблюдатель регистрируется в модели в методе observe
или
в методе boot в AppServiceProvider

public function boot() {
  User::observe(UserObserver::class);
}

Заглушить события
заглушить все события на модели
метод withoutEvents
все методы внутри замыкания не вызовут события модели

User::withoutEvents(function () use () {
  User::findOrFail(1)->delete();
  User::find(2);
});
-------------------------------------------------

Eloquent ORM -> Relationships

Отношения - это методы в классе Eloquent модели
Имена отношений не должны конфликтовать с аттрибутами модели
Всем отношениям доступен query builders

Отношения

One To One
One To Many
Many To Many

Has One Through
Has Many Through

Polymorphic
One To One
One To Many
Many To Many


"ONE TO ONE" (ОДИН К ОДНОМУ)

модели User и Phone

class User extends Model {

  public function phone() {

    автоматически ищет user_id foreign key в Phone
    return $this->hasOne('App\Phone');

	укажем foreign key вручную
	return $this->hasOne('App\Phone', 'foreign_key');

	автоматически ищет id primary key в User или свойство в модели $primaryKey. изменим в 3 параметре
	return $this->hasOne('App\Phone', 'foreign_key', 'primary_key');

  }
}

class Phone extends Model {

  public function user() {
    return $this->belongsTo('App\User');
	return $this->belongsTo('App\User', 'foreign_key');
	return $this->belongsTo('App\User', 'foreign_key', 'primary_key');
  }

}

$phone = User::find(1)->phone;


"ONE TO MANY" (ОДИН КО МНОГИМ)

модели Post и Comment

class Post extends Model {

  public function comments() {

    автоматически ищет post_id foreign key
    return $this->hasMany('App\Comment');

    return $this->hasMany('App\Comment', 'foreign_key');
    return $this->hasMany('App\Comment', 'foreign_key', 'primary_key');

  }

}

$comments = App\Post::find(1)->comments;
$comment = App\Post::find(1)->comments()->where('title', 'foo')->first();


"ONE TO MANY INVERSE" (ОДИН КО МНОГИМ ОБРАТНЫЙ)

модели Post и Comment

class Comment extends Model {

  public function post() {

    return $this->belongsTo('App\Post');
	return $this->belongsTo('App\Post', 'foreign_key');
	return $this->belongsTo('App\Post', 'foreign_key', 'primary_key');

  }
}

$comment = App\Comment::find(1);
$comment->post->title;


"MANY TO MANY" (МНОГИЕ КО МНОГИМ)

3 таблицы
users: id, name
roles: id, name
role_user: user_id, role_id

class User extends Model {
  public function roles() {

    return $this->belongsToMany('App\Role');

	указать таблицу вручную
	return $this->belongsToMany('App\Role', 'role_user');

	указать все параметры вручную
	return $this->belongsToMany('App\Role', 'role_user', 'user_id', 'role_id');
  }
}

class Role extends Model {
  public function users() {
    return $this->belongsToMany('App\User');
  }
}

$user = App\User::find(1);
$roles = $user->roles;
$roles = App\User::find(1)->roles()->orderBy('name')->get();

Промежуточная таблица (pivot)

$user = App\User::find(1);
foreach ($user->roles as $role) {
  $role->pivot->created_at;
}

в pivot только ключи промежуточной таблицы. можно добавить остальные аттрибуты
$this->belongsToMany('App\Role')->withPivot('column1', 'column2');

чтобы промежуточная таблица обрабатывала свои аттрибуты created_at и updated_at
$this->belongsToMany('App\Role')->withTimestamps();

можно переименовать аттрибут pivot
$this->belongsToMany('App\Podcast')->as('pivot123');

foreach ($user->roles as $role) {
  echo $role->pivot123->created_at;
}

Метод belongsToMany возвращает результат, его можно отфильтровать методами
$this->belongsToMany('App\Role')->wherePivot('approved', 1);
$this->belongsToMany('App\Role')->wherePivotIn('priority', [1, 2]);
$this->belongsToMany('App\Role')->wherePivotNotIn('priority', [1, 2]);


Отдельная модель для промежуточной таблицы

pivot модель расширяется от
Illuminate\Database\Eloquent\Relations\Pivot

pivot модель полиморфная расширяется от
Illuminate\Database\Eloquent\Relations\MorphPivot

class Role extends Model {
  public function users() {

    return $this->belongsToMany('App\User')->using('App\RoleUser');
	return $this->belongsToMany('App\User')->using('App\RoleUser')->withPivot(['created_by', 'updated_by']);

  }
}

class RoleUser extends Pivot {

  если в промежуточной таблице есть primary key
  public $incrementing = true;
}

Модели pivot могут не использовать трейт SoftDeletes


"HAS ONE THROUGH" (ИМЕЕТ ОДИН СКВОЗНОЙ)

3 таблицы
mechanics: id, name
cars:      id, name, mechanic_id
owners:    id, name, car_id

механик -> машина -> овнер
механик имеет 1 машину, машина имеет 1 овнера
механик и овнер связаны через машину
машина это промежуточная модель

class Mechanic extends Model {

  public function carOwner() {

    return $this->hasOneThrough('App\Owner', 'App\Car');

	return $this->hasOneThrough(
      'App\Owner',
      'App\Car',
      'mechanic_id', foreign key таблицы Cars
      'car_id',      foreign key таблицы Owners
      'id',          primary key таблицы Mechanics
      'id',          primary key таблицы Cars
    );

  }
}


"HAS MANY THROUGH" (ИМЕЕТ МНОГО СКВОЗНЫХ)

Страны - Юзеры - Посты

countries: id, name
users:     id, name, country_id
posts:     id, title, user_id

собрать все посты по стране

class Country extends Model {

  получаем доступ к Post через User
  public function posts() {
    return $this->hasManyThrough('App\Post', 'App\User');
  }

}


"ONE TO ONE" (ПОЛИМОРФНЫЕ)

posts:  id, name
users:  id, name
images: id, url, imageable_id (ID юзера или поста), imageable_type (класс User или Post)

class Image extends Model {
  public function imageable() {
    return $this->morphTo();
  }
}

class Post extends Model {
  public function image() {
    return $this->morphOne('App\Image', 'imageable');
  }
}

class User extends Model {
  public function image() {
    return $this->morphOne('App\Image', 'imageable');
  }
}

$post = App\Post::find(1);
$image = $post->image;

$image = App\Image::find(1);
$imageable = $image->imageable;


"ONE TO MANY" (ПОЛИМОРФНЫЕ)

posts:    id, title
videos:   id, title
comments: id, body, commentable_id (ID юзера или поста), commentable_type (класс User или Post)

$post = App\Post::find(1);
$comments = $post->comments;

$comment = App\Comment::find(1);
$commentable = $comment->commentable;


"MANY TO MANY" (ПОЛИМОРФНЫЕ)
пропустил


Карты морфинга

Relation::morphMap([
  'posts' => 'App\Post',
  'videos' => 'App\Video'
]);


Создать отношения на лету

Order::resolveRelationUsing('customer', function ($orderModel) {
  return $orderModel->belongsTo(Customer::class, 'customer_id');
});
не рекомедуется. использовать ключи всегда.


Динамические свойства это ленивая загрузка отношений
Но активная загрузка быстрее

Проверка на существование
$posts = App\Post::has('comments')->get();
$posts = App\Post::has('comments', '>=', 3)->get();
$posts = App\Post::has('comments.votes')->get();
$posts = App\Post::whereHas('comments', function (Builder $query) {
  $query->where('content', 'like', 'foo%');
})->get();

Проверка на отсутствие
$posts = App\Post::doesntHave('comments')->get();
$posts = App\Post::whereDoesntHave('comments', function (Builder $query) {
  $query->where('content', 'like', 'foo%');
})->get();


Проверка наличия связи MorphTo
$comments = App\Comment::whereHasMorph(
  'commentable',
  ['App\Post', 'App\Video'],
  function (Builder $query) {
    $query->where('title', 'like', 'foo%');
  }
)->get();

Подсчет связанных моделей
$posts = App\Post::withCount('comments')->get();

$posts = App\Post::withCount(['votes', 'comments' => function (Builder $query) {
  $query->where('content', 'like', 'foo%');
}])->get();

$posts = App\Post::withCount([
  'comments',
  'comments as pending_comments_count' => function (Builder $query) {
    $query->where('approved', false);
  },
])->get();


Подсчет связанных моделей morphTo
$activities = ActivityFeed::query()
  ->with(['parentable' => function (MorphTo $morphTo) {
    $morphTo->morphWithCount([
      Photo::class => ['tags'],
      Post::class => ['comments'],
  ]);
}])->get();

$activities = ActivityFeed::with('parentable')
  ->get()
  ->loadMorphCount('parentable', [
    Photo::class => ['tags'],
    Post::class => ['comments'],
]);

Все отношения загружаются ленивой загрузкой
Пример

class Book extends Model {
  public function author() {
    return $this->belongsTo('App\Author');
  }
}

тут в итоге N+1 запрос
$books = App\Book::all();
foreach ($books as $book) {
  $book->author->name;
}

тут только 2 запроса потому что юзается IN
$books = App\Book::with('author')->get();
foreach ($books as $book) {
  $book->author->name;
}

активная загрузка
$books = App\Book::with(['author', 'publisher'])->get();

вложенная активная загрузка
$books = App\Book::with('author.contacts')->get();

активная загрузка только нужных столбцов
$books = App\Book::with('author:id,name')->get();


Включить активную загрузку всегда

class Book extends Model {

  protected $with = ['author'];

  public function author() {
    return $this->belongsTo('App\Author');
  }

}

можно удалить элемент для 1 запроса
$books = App\Book::without('author')->get();


Загрузить отношения когда модель уже получена

$books = App\Book::all();

$books->load('author', 'publisher');
$author->load(['books' => function ($query) {
  $query->orderBy('published_date', 'asc');
}]);

загрузить отношение если оно не загружено
$book->loadMissing('author');


Вставка и обновление связанных моделей


метод SAVE

$comment = new App\Comment(['message' => 'A new comment.']);
$post = App\Post::find(1);
$post->comments()->save($comment);

$post->comments()->saveMany([
  new App\Comment(['message' => 'A new comment.']),
  new App\Comment(['message' => 'Another comment.']),
]);

перезагрузка модели и её связей
$post->refresh();

$post = App\Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();


метод CREATE

разница между save и create
save принимает полный экземпляр модели Eloquent
create принимает PHP array

$post = App\Post::find(1);
$comment = $post->comments()->create([
  'message' => 'A new comment.',
]);

$post->comments()->createMany([
  ['message' => 'A new comment.',],
  ['message' => 'Another new comment.',],
]);


установит foreign key на потомка
$account = App\Account::find(10);
$user->account()->associate($account);
$user->save();

установит foreign key на NULL
$user->account()->dissociate();
$user->save();

Если модели нет, то можно вернуть болванку по умолчанию
return $this->belongsTo('App\User')->withDefault();

или с набором полей
return $this->belongsTo('App\User')->withDefault([
  'name' => 'Guest Author'
]);


"MANY TO MANY" ВСТАВКА И УДАЛЕНИЕ

Юзер - Роли

добавить роль
$user = App\User::find(1);
$user->roles()->attach($roleId);

с доп.полями
$user->roles()->attach($roleId, ['expires' => $expires]);


удалить роль
$user->roles()->detach($roleId);
$user->roles()->detach([$roleId1, $roleId2, $roleId3]);

удалить все роли
$user->roles()->detach();

массив идентификаторов для размещения в промежуточной таблице
любые идентификаторы, которых нет в массиве будут удалены

$user->roles()->sync([$roleId1, $roleId2, $roleId3]);
$user->roles()->sync([$roleId1 => ['expires' => true], $roleId2, $roleId3]);

не удаляя предыдущие роли
$user->roles()->syncWithoutDetaching([$roleId1, $roleId2, $roleId3]);

метод Toggle
если идентификатор есть, то будет удален
если идентификатора нет, то будет добавлен
$user->roles()->toggle([$roleId1, $roleId2, $roleId3]);

сохранение дополнительных данных в промежуточной таблице
App\User::find(1)->roles()->save($role, ['expires' => $expires]);

обновление записи в промежуточной таблице
$user->roles()->updateExistingPivot($roleId, $attributes);

Касание родительских меток времени
при обновлении модели Comment обновит updated_at у модели Post

class Comment extends Model {
  protected $touches = ['post'];
}
-------------------------------------------------

Eloquent ORM -> Collections

Eloquent всегда возвращает коллекции
Результату доступны все методы коллекций и дополнительные методы
Коллекции реализуют итераторы, с ними можно работать как с массивами

Почти все методы Eloquent коллекций возвращают новый инстанс Eloquent
Методы pluck, keys, zip, collapse, flatten, flip возвращают базовый инстанс Collections


Дополнительные методы

contains - определить наличие модели в массиве
diff - вернет все модели кроме указанных
except - вернет все модели кроме указанных id

find - найти модель по id, модели, массиву
fresh - загружает модель из базы заново

intersect - загружает модели по массиву id

load - загружает отношения модели
loadMissing - загружает отношения модели если не были загружены

modelKeys - вернет массив id моделей в массиве
makeVisible - делает аттрибут видимым
makeHidden - делает аттрибут невидимым

only - вернет массив моделей по id
toQuery - возвращает query builder
unique - вернет все уникальные по id модели

Свой класс Collection со своими методами

class User extends Model {
  public function newCollection(array $models = []) {
    return new CustomCollection($models);
  }
}

теперь Eloquent возвращает для этой модели newCollection а не Collection
можно прописать это для всех моделей в base model class
-------------------------------------------------

Eloquent ORM -> Mutators

Акцессоры читают аттрибуты модели
Мутаторы пишут аттрибуты модели

Создать Акцессор
модель User
аттрибут name

class User extends Model {
  public function getNameAttribute($value) {
    return ucfirst($value);
	return $this->first_name . $this->last_name;
  }
}

Создать Мутатор
модель User
аттрибут name

class User extends Model {
  public function setNameAttribute($value) {
    $this->attributes['name'] = strtolower($value);
  }
}


Мутаторы для даты

по умолчанию Eloquent конвертит created_at и updated_at в Carbon

добавим свои аттрибуты для даты
аттрибут seen_at тоже будет сконверчен в Carbon

class User extends Model {
  protected $dates = [
    'seen_at'
  ];
}

created_at и updated_at можно выключить установив
public $timestamps = false;

Формат даты timestamp
по умолчанию 'Y-m-d H:i:s'

можно изменить
protected $dateFormat = 'U';


Приведение типов для аттрибутов
в базе поле is_admin 0 или 1. приводим к логическому true или false

protected $casts = [
  'is_admin' => 'boolean',
];

Типы
integer, real, float, double, decimal:<digits>
string, boolean, object, array, collection
date, datetime, timestamp

так нельзя делать с аттрибутами null
и аттрибутами совпадающием с именами отношений


Свой класс приведения аттрибутов

class Json implements CastsAttributes {

  public function get($model, $key, $value, $attributes) {
    return json_decode($value, true);
  }

  public function set($model, $key, $value, $attributes) {
    return json_encode($value);
  }
}

цепляем к модели
class User extends Model {
  protected $casts = [
    'options' => Json::class
  ];
}

Кроме примитивных типов, можно приводить к сложным объектам

class Address implements CastsAttributes {

  public function get($model, $key, $value, $attributes) {
    return new Address(
      $attributes['address_line_one'],
      $attributes['address_line_two']
    );
  }

  public function set($model, $key, $value, $attributes) {
    return [
      'address_line_one' => $value->lineOne,
      'address_line_two' => $value->lineTwo,
    ];
  }
}

Только входящее приведение
когда пишем в модель

class Hash implements CastsInboundAttributes {
  public function set($model, $key, $value, $attributes) {
    return bcrypt($value);
  }
}

Можно все приведения сложить в класс и его присоединить к модели


Приведение массивов и json
когда в базе есть поле где лежит json и чтобы работать с ним как с массивом
будет автоматическая сериализация-десериализация

class User extends Model {
  protected $casts = [
    'options' => 'array'
  ];
}

Приведение дат
protected $casts = [
  'created_at' => 'datetime:Y-m-d',
];


Приведение аттрибутов на лету

last_posted_at без приведения

User::select([
  'users.*',
  'last_posted_at' => Post::selectRaw('MAX(created_at)')
    ->whereColumn('user_id', 'users.id')
])->get();

last_posted_at с приведением

User::select([
  'users.*',
  'last_posted_at' => Post::selectRaw('MAX(created_at)')
    ->whereColumn('user_id', 'users.id')
])->withCasts([
    'last_posted_at' => 'datetime'
])->get();
-------------------------------------------------

Eloquent ORM -> API Resources

создаем API
модели Eloquent конвертируем в json
этим занимаются ресурсы
ресурсы в app/Http/Resources


создать ресурс
php artisan make:resource User

это было про 1 модель. а когда коллекция моделей то так
php artisan make:resource Users --collection
php artisan make:resource UserCollection


класс ресурса представляет 1 модель

class User extends JsonResource {

  массив аттрибутов для конверта в json
  public function toArray($request) {
    return [
      'id' => $this->id,
      'name' => $this->name,
      'created_at' => $this->created_at,
      'updated_at' => $this->updated_at,
    ];
  }
}

использование
Route::get('/user', function () {
  return new UserResource(User::find(1));
});


возвращаем коллекцию и пагинатор

class UserCollection extends ResourceCollection {
  public function toArray($request) {
    return [
      'data' => $this->collection,
      'links' => [
        'self' => 'link-value',
      ],
    ];
  }
}

Route::get('/users', function () {
  return UserResource::collection(User::all());
  return UserCollection(User::all());
});


не сбрасывать ключи коллекции
public $preserveKeys = true;

настройка базового класса
вызов $this->collection в UserCollection обращается к User

можно это изменить
public $collects = 'App\Http\Resources\Member';


загрузка Отношений
public function toArray($request) {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'posts' => PostResource::collection($this->posts),
  ];
}

ресурс это 1 модель в массив
коллекция ресурсов это набор моделей в массив

класс Ресурса или класс Коллекции Ресурсов

коллекцию ресурсов можно генерить на лету из класса ресурса
Route::get('/user', function () {
  return UserResource::collection(User::all());
});

если нужна мета-инфа и пагинатор то использовать коллекцию ресурсов

данные в массиве data
можно свой ключ
public static $wrap = 'user';

отключить ключ
в AppServiceProvider в методе boot
JsonResource::withoutWrapping();

в пагинаторе ключ всегда будет data

пагинатор всегда можно закинуть в метод collection ресурса

Route::get('/users', function () {
    return new UserCollection(User::paginate());
});


Условное добавление аттрибутов

public function toArray($request) {

  return [

    'id' => $this->id,
    'name' => $this->name,

	аттрибут добавиться если true
    'secret' => $this->when(Auth::user()->isAdmin(), 'secret-value'),

	через замыкание
	'secret' => $this->when(Auth::user()->isAdmin(), function () {return 'secret-value';}),

  ];
}

public function toArray($request) {
  return [

    'id' => $this->id,
    'name' => $this->name,

	аттрибуты добавятся если true
    $this->mergeWhen(Auth::user()->isAdmin(), [
      'first-secret' => 'value',
      'second-secret' => 'value',
    ])

  ];
}

не использовать mergeWhen с массивами у которых микс ключей цифры+строки
или только цифры но они неупорядочены


Условное добавление отношений

public function toArray($request) {
  return [

    'id' => $this->id,
    'name' => $this->name,

	если отношение не было загружено, то аттрибута не будет
    'posts' => PostResource::collection($this->whenLoaded('posts')),
  ];
}


добавление данных из промежуточной pivot таблицы

public function toArray($request) {
  return [

    'id' => $this->id,

	'expires_at' => $this->whenPivotLoaded('role_user', function () {return $this->pivot->expires_at;}),

	'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {return $this->subscription->expires_at;}),

    ];
}

добавление метаданных
когда api json требует еще links
в ключах data, meta, links

public function toArray($request) {
  return [
    'data' => $this->collection,
    'links' => [
      'self' => 'link-value',
    ],
  ];
}


топ левел метадата

public function toArray($request) {
  return parent::toArray($request);
}

public function with($request) {
  return [
    'meta' => [
      'key' => 'value',
    ],
  ];
}

через роутер или контроллер
return (new UserCollection(User::all()->load('roles')))
  ->additional(['meta' => [
    'key' => 'value',
  ]]);


Ответ ресурса

Route::get('/user', function () {
  return new UserResource(User::find(1));
});

Route::get('/user', function () {
  return (new UserResource(User::find(1)))
    ->response()
    ->header('X-Value', 'True');
});

class User extends JsonResource {
  public function withResponse($request, $response) {
    $response->header('X-Value', 'True');
  }
}
-------------------------------------------------

Eloquent ORM -> Serialization

Сериализация в JSON для создания API
Сериализует модели, отношения в массивы или json
У Eloquent есть методы для этого


модель и отношения в массив
user = App\User::with('roles')->first();
$user->toArray();

модель в массив
$user->attributesToArray();

коллекции моделей в массив
$users = App\User::all();
$users->toArray();

модель и отношения в json
$user->toJson();
$user->toJson(JSON_PRETTY_PRINT);


cкрыть аттрибуты из json
class User extends Model {
  protected $hidden = ['password'];
}

вывести только нужные
class User extends Model {
  protected $visible  = ['name'];
}

временно скрыть или показать
$user->makeVisible('password')->toArray();
$user->makeHidden('name')->toArray();

добавить аттрибуты
class User extends Model {

  protected $appends = ['is_admin'];

  по сути акцессор
  public function getIsAdminAttribute() {
    return $this->attributes['admin'] === 'yes';
  }

}

добавить на лету аттрибут или массив аттрибутов
$user->append('is_admin')->toArray();
$user->setAppends(['is_admin'])->toArray();


сериализация даты

формат по умолчанию для всех аттрибутов дат
protected function serializeDate(DateTimeInterface $date) {
  return $date->format('Y-m-d');
}

выставить формат на каждый аттрибут
protected $casts = [
  'birthday' => 'date:Y-m-d',
  'joined_at' => 'datetime:Y-m-d H:00',
];
-------------------------------------------------

Testing -> Getting Started

PHPUnit стоит
конфиг phpunit.xml
папки tests/Feature, tests/Unit

Unit тесты тестируют 1 метод или функцию
Feature тесты тестируют большие куски функционала

ставится переменная окружения testing
сессия и кеш ставится в array

переменные окружения в phpunit.xml

скинуть кеш
config:clear

создать .env.testing в корне
он заменит .env при запуске тестов PHPUnit или выполнение Artisan команд с параметром --env=testing

создать тесты в папке Feature
php artisan make:test UserTest

создать тесты в папке Unit
php artisan make:test UserTest --unit

запуск тестов
vendor/bin/phpunit

выдаст больше инфы
php artisan test

принимает все аргументы phpunit
php artisan test --group=feature
-------------------------------------------------

Testing -> HTTP Tests

МВ CSRF отключено

сделать get запрос
$response = $this->get('/');

поймать статус 200
$response->assertStatus(200);

добавить заголовки
$response = $this->withHeaders([
  'X-Header' => 'Value',
])->json('POST', '/user', ['name' => 'Sally']);

добавить куки
$response = $this->withCookie('color', 'blue')->get('/');
$response = $this->withCookies([
  'color' => 'blue',
  'name' => 'Taylor',
])->get('/');

отладка ответа
$response->dumpHeaders();
$response->dumpSession();
$response->dump();

добавить данные в сессию
$response = $this->withSession(['foo' => 'bar'])
  ->get('/');

поддержка залогиненности
$user = factory(User::class)->create();
$response = $this->actingAs($user)
  ->withSession(['foo' => 'bar'])
  ->get('/');

укажем гуарда
$this->actingAs($user, 'api')


тестирование json

методы json, getJson, postJson, putJson, patchJson, deleteJson, optionsJson
методы assertJson, assertExactJson, assertJsonPath

в response данные доступны как элементы массива
$this->assertTrue($response['created']);


тестирование загрузки файла

Storage::fake('avatars');

создать картинку с размерами
$file = UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);

документ
$file = UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);

документ с mime типом
$file = UploadedFile::fake()->create('document.pdf', $sizeInKilobytes, 'application/pdf');

отправить
$response = $this->json('POST', '/avatar', [
  'avatar' => $file,
]);

проверка что файл сохранился
Storage::disk('avatars')->assertExists($file->hashName());

проверка что файл НЕсохранился
Storage::disk('avatars')->assertMissing('missing.jpg');


Утверждения

assertCookie - содержит куку
assertCookieExpired - содержит куку и она истекла
assertCookieNotExpired - содержит куку и она не истекла
assertCookieMissing - не содержит куку

assertCreated - код ответа 201
assertDontSee - строки нет в ответе
assertDontSeeText - строки нет в тексте ответа
assertExactJson - точное совпадение json
assertForbidden - код ответа 403
assertHeader - заголовок есть в ответе
assertHeaderMissing - заголовка нет в ответе

assertJson - ответ содержит json
assertJsonCount - в ответе массив размера N
assertJsonFragment - ответ содержит фрагмент json
assertJsonMissing - ответ не содержит фрагмент json
assertJsonMissingExact - ответ не содержит точного фрагмента json
assertJsonMissingValidationErrors - ответ не содержит ошибок json
assertJsonPath - ответ содержит данные по указанному пути
assertJsonStructure - ответ имеет заданную структуру
assertJsonValidationErrors - ответ содержит заданные ошибки json

assertLocation - ответ содержит uri и заголовке
assertNoContent - ответ содержит код ответа и нет тела
assertNotFound - код ответа 404
assertOk - код ответа 200
assertPlainCookie - содержит куку
assertRedirect - это редирект на заданный uri

assertSee - строка есть в ответе
assertSeeInOrder - строки есть в ответе
assertSeeText - строка содержится в ответе
assertSeeTextInOrder - строки содержаться в ответе

assertSessionHas - в сессии есть фрагмент данных
assertSessionHasInput - во Flash значении есть фрагмент данных
assertSessionHasAll - в сессии массив значений
assertSessionHasErrors - в сессии есть такой ключ ошибки
assertSessionHasErrorsIn - в сессии есть такие ключи ошибки
assertSessionHasNoErrors - в сессии нет ошибок
assertSessionDoesntHaveErrors - нет ошибок для данных ключей
assertSessionMissing - нет ключа

assertStatus - код ответа N
assertSuccessful - код ответа > = 200 и <300
assertUnauthorized - код ответа 401

assertViewHas - наличие фрагмента данных
assertViewHasAll - есть список данных
assertViewIs - шаблон возвращен роутом
assertViewMissing - нет данных


Утверждения аутентификации

assertAuthenticated - залогинен
assertGuest - не залогинен
assertAuthenticatedAs - залогинен как
assertCredentials - данные валидны
assertInvalidCredentials - данные невалидны
-------------------------------------------------

Testing -> Console Tests

Консольные приложения которые ожидают ввода от юзера

Команда

Artisan::command('question', function () {

  $name = $this->ask('What is your name?');

  $language = $this->choice('Which language do you program in?', [
        'PHP',
        'Ruby',
        'Python',
  ]);

  $this->line('Your name is '.$name.' and you program in '.$language.'.');

});


Тест команды

public function testConsoleCommand() {

  $this->artisan('question')
    ->expectsQuestion('What is your name?', 'Taylor Otwell')
    ->expectsQuestion('Which language do you program in?', 'PHP')
    ->expectsOutput('Your name is Taylor Otwell and you program in PHP.')
    ->assertExitCode(0);
}


При ожидании подтверждения да/нет

$this->artisan('module:import')
  ->expectsConfirmation('Do you really wish to run this command?', 'no')
  ->assertExitCode(1);

expectsQuestion - имитируем ввод юзером
assertExitCode - код ответа
expectsOutput - вывод ответа
expectsConfirmation - когда команда ждет выбора ответа
-------------------------------------------------

Testing -> Browser Tests

Laravel Dusk - это обёртка над ChromeDriver
Тестирование в браузере
Не требует JDK и Selenium

установка
composer require --dev laravel/dusk
php artisan dusk:install

тесты в tests/Browser

в .env установить APP_URL урл приложения

запуск теста
принимает все аргументы phpunit

php artisan dusk

запуск только неудачных тестов
php artisan dusk:fails

установить нужную версию ChromeDriver вручную
php artisan dusk:chrome-driver - последнюю
php artisan dusk:chrome-driver 74 - номер версии
php artisan dusk:chrome-driver --all - все версии

файлы chromedriver должны быть исполняемые
chmod -R 0755 vendor/laravel/dusk/bin/

можно не использовать ChromeDriver и Google Chrome
а использовать сервер Selenium и любой браузер

protected function driver() {

  return RemoteWebDriver::create(
    'http://localhost:4444/wd/hub', DesiredCapabilities::phantomjs()
  );

  return RemoteWebDriver::create(
    'http://localhost:9515', DesiredCapabilities::chrome()
  );
}

создать тест
php artisan dusk:make LoginTest

Окружение
создать .env.dusk.local чтобы использовался он, а не общий .env
иначе будет бекап .env, запуск теста, потом переименование обратно в .env
шаблон .env.dusk.{environment}

вызов 1 или несколько браузеров сразу

размер окна браузера
$browser->resize(1920, 1080);
$browser->maximize();
$browser->fitContent();

переместить браузер
$browser->move(100, 100);

если тест не прошел, то ресайз браузера по размеру содержимого и скриншот
отключить ресайз
$browser->disableFitOnFailure();


Создать свой макрос действия браузера

Browser::macro('scrollToElement', function ($element = null) {

  $this->script("$('html, body').animate({ scrollTop: $('$element').offset().top }, 0);");

  return $this;
});

$this->browse(function ($browser) use ($user) {
  $browser->visit('/pay')
  ->scrollToElement('#credit-card-details')
  ->assertSee('Enter Credit Card Details');
});

Логин

$this->browse(function ($first, $second) {
  $first->loginAs(User::find(1))
  ->visit('/home');
});

Если нужны миграции бд

class ExampleTest extends DuskTestCase {
  use DatabaseMigrations;
}

Чтение и установка кук

$browser->cookie('name');
$browser->cookie('name', 'Taylor');

нешифрованные
$browser->plainCookie('name');
$browser->plainCookie('name', 'Taylor');

удалить
$browser->deleteCookie('name');


Скрин
в tests/Browser/screenshots

$browser->screenshot('filename');

Вывод консоли в файл
в tests/Browser/console

$browser->storeConsoleLog('filename');

HTML в файл
в tests/Browser/source

$browser->storeSource('filename');


Селекторы

обычные
<button>Login</button>
$browser->click('.login-page .container div > button');

удобные
<button dusk="login-button">Login</button>
$browser->click('@login-button');


Клик
$browser->clickLink($linkText);

клик если ссылка видна
if ($browser->seeLink($linkText)) {}

Dusk автоматически подгрузит jQuery если её нет

получить value
$browser->value('selector');
$browser->value('selector', 'value');
$browser->inputValue('field'); для input

текст
$browser->text('selector');

атрибут
$browser->attribute('selector', 'value');

ввод текста
email это name

$browser->type('email', 'taylor@laravel.com');

добавить текст не очищая
$browser->type('tags', 'foo')
  ->append('tags', ', bar, baz');

очистить
$browser->clear('email');

печатать медленно
$browser->typeSlowly('mobile', '+1 (202) 555-5555');
$browser->typeSlowly('mobile', '+1 (202) 555-5555', 300);

добавить медленно
$browser->type('tags', 'foo')
  ->appendSlowly('tags', ', bar, baz');

выбрать селект
size это name

$browser->select('size', 'Large');

случайный выбор
$browser->select('size');

чекбоксы
$browser->check('terms');
$browser->uncheck('terms');

радиокнопки
$browser->radio('version', 'php7');

залить файл
$browser->attach('photo', __DIR__.'/photos/img.png');

работа с клавой
$browser->keys('selector', ['{shift}', 'taylor'], 'otwell');

горячая клавиша на всё окно
command это все команды Facebook\WebDriver\WebDriverKeys

$browser->keys('.app', ['{command}', 'j']);


Клик
$browser->click('.selector');
$browser->clickAtXPath('//div[@class = "selector"]');
$browser->clickAtPoint(0, 0);

двойной
$browser->doubleClick();

правый
$browser->rightClick();
$browser->rightClick('.selector');

нажатие и удержание
$browser->clickAndHold()
  ->pause(1000)
  ->releaseMouse();

наведение
$browser->mouseover('.selector');

перетаскивание
$browser->drag('.from-selector', '.to-selector');
$browser->dragLeft('.selector', 10);
$browser->dragRight('.selector', 10);
$browser->dragUp('.selector', 10);
$browser->dragDown('.selector', 10);
$browser->dragOffset('.selector', 10, 10);


Работа с окнами js

$browser->waitForDialog($seconds = null);
$browser->assertDialogOpened('value');
$browser->typeInDialog('Hello World');
$browser->acceptDialog(); закрыть
$browser->dismissDialog(); отмена


Области видимости
поиск внутри таблицы, сразу текста и кнопки

$browser->with('.table', function ($table) {
  $table->assertSee('Hello World')
    ->clickLink('Delete');
});

выйдем из области
$browser->with('.table', function ($table) {

  тут в body .table
  $browser->elsewhere('.page-title', function ($title) {

    тут в body .page-title
    $title->assertSee('Hello World');

  });
});


Ожидание
мс
$browser->pause(1000);

ждать селектора
$browser->waitFor('.selector'); по умолчанию 5 сек
$browser->waitFor('.selector', 1); ждать 1 сек

ждать когда исчезнет
$browser->waitUntilMissing('.selector');
$browser->waitUntilMissing('.selector', 1);

ждать модальное окно и нажать внутри кнопку
тут тоже область видимости

$browser->whenAvailable('.modal', function ($modal) {
  $modal->assertSee('Hello World')
    ->press('OK');
});

ждать текст
$browser->waitForText('Hello World');
$browser->waitForText('Hello World', 1);

ждать удаления текста
$browser->waitUntilMissingText('Hello World');
$browser->waitUntilMissingText('Hello World', 1);

ждать ссылку с текстом
$browser->waitForLink('Create');
$browser->waitForLink('Create', 1);

ждать смены урла
$browser->waitForLocation('/secret');
$browser->waitForRoute($routeName, $parameters); ждать роута

ждать перезагрузки
$browser->click('.some-action')
  ->waitForReload()
  ->assertSee('something');

ждать true выражений js
$browser->waitUntil('App.dataLoaded');
$browser->waitUntil('App.data.servers.length > 0');
$browser->waitUntil('App.data.servers.length > 0', 1);

ждать выражений vue
$browser->waitUntilVue('user.name', 'Taylor', '@user');
$browser->waitUntilVueIsNot('user.name', null, '@user');

ждать с колбеком
$browser->waitUsing(10, 1, function () use ($something) {
  return $something->isReady();
}, "Something wasn't ready in time.");


скролл к элементу
$browser->scrollIntoView('selector')
  ->click('selector');

ждать компонент vue
$this->browse(function (Browser $browser) {
  $browser->visit('/')
    ->assertVue('user.name', 'Taylor', '@profile-component');
});


Утверждения

assertTitle - заголовок страницы равен
assertTitleContains - заголовок страницы содержит

assertUrlIs - урл равен

assertSchemeIs - полный урл равен
assertSchemeIsNot - полный урл не равен

assertHostIs - хост равен
assertHostIsNot -  хост не равен

assertPortIs - порт равен
assertPortIsNot - порт не равен

assertPathBeginsWith - урл начинается с пути
assertPathIs - урл равен
assertPathIsNot - урл не равен

assertRouteIs - урл равен роуту

assertQueryStringHas - есть параметр запроса
assertQueryStringMissing - нет параметра запроса

assertFragmentIs - фрагмент равен фрагменту
assertFragmentBeginsWith - фрагмент начинается с фрагмента
assertFragmentIsNot - фрагмент не равен фрагменту

assertHasCookie - кука есть
assertHasPlainCookie - кука есть
assertCookieMissing - куки нет
assertPlainCookieMissing - куки нет
assertCookieValue - кука равна
assertPlainCookieValue - кука равна

assertSee - текст есть
assertDontSee - текста нет
assertSeeIn - текст присутствует
assertDontSeeIn - текст не присутствует

assertSourceHas - исходный код есть
assertSourceMissing - нет

assertSeeLink - ссылка есть
assertDontSeeLink - нет

assertInputValue - поле ввода имеет значение
assertInputValueIsNot - не имеет

assertChecked - чекбокс стоит
assertNotChecked - не стоит

assertRadioSelected - радиокнопка выбрана
assertRadioNotSelected - нет

assertSelected - селект выбран
assertNotSelected - нет
assertSelectHasOptions - селект наполнен
assertSelectMissingOption - селект пустой
assertSelectMissingOptions - селект недоступен
assertSelectHasOption - селект доступен

assertValue - у элемента значение

assertAttribute - есть аттрибут
assertAriaAttribute - есть аттрибут aria
assertDataAttribute - есть аттрибут data

assertVisible - элемент виден
assertPresent - есть
assertMissing - не виден

assertDialogOpened - js окно открыто

assertEnabled - поле включено
assertDisabled - поле выключено

assertButtonEnabled - кнопка включена
assertButtonDisabled - выключена

assertFocused - стоит фокус
assertNotFocused - нет

assertAuthenticated - залогинен
assertGuest - нет
assertAuthenticatedAs - залогинен как

assertVue - свойство компонента Vue равно
assertVueIsNot - не равно
assertVueContains - содержит
assertVueDoesNotContain - не содержит


Создать страницу
в tests/Browser/Pages

php artisan dusk:page Login

Страница - это метод группировок селекторов под удобные аттрибуты
методы url, assert, elements

public function elements() {
  return [
    '@email' => 'input[name=email]',
  ];
}

$browser->type('@email', 'taylor@laravel.com');

можно глобально в классе tests/Browser/Pages/Page

public static function siteElements() {
  return [
    '@element' => '#selector',
  ];
}


Создать компонент
в tests/Browser/Components

php artisan dusk:component DatePicker

Компонент - это кусок который присутствует на разных страницах
например датапикер или поле поиска


Непрерывная интеграция

в .env.testing требует APP_URL=http://127.0.0.1:8000

CircleCI
пример конфига в мане

Codeship
пример конфига в мане

Heroku CI
пример конфига в мане

Travis CI
пример конфига в мане

GitHub Actions
пример конфига в мане
-------------------------------------------------

Testing -> Database

тестирование бд


создать фабрику
в database/factories

php artisan make:factory PostFactory
php artisan make:factory PostFactory --model=Post

сброс бд после каждого теста

class ExampleTest extends TestCase {
  use RefreshDatabase;
}

забить данными перед тестом
пример database/factories/UserFactory.php

$factory->define(App\User::class, function (Faker $faker) {
  return [
    'name' => $faker->name,
    'email' => $faker->unique()->safeEmail,
    'email_verified_at' => now(),
    'password' => '$2y$10$92IXigi',
    'remember_token' => Str::random(10),
    ];
});

можно отдельные файлы для каждой модели

в Faker добавить локаль в config/app.php в faker_locale

работает для extend моделей тоже

$factory->define(App\Admin::class, function (Faker\Generator $faker) {
  return factory(App\User::class)->raw([]);
});


колбеки до и после создания модели

$factory->afterMaking(App\User::class, function ($user, $faker) {});

$factory->afterCreating(App\User::class, function ($user, $faker) {
  $user->accounts()->save(factory(App\Account::class)->make());
});


колбеки для состояний

$factory->afterMakingState(App\User::class, 'delinquent', function ($user, $faker) {});

$factory->afterCreatingState(App\User::class, 'delinquent', function ($user, $faker) {});


создать модель
$user = factory(App\User::class)->make();

создать модели
$users = factory(App\User::class, 3)->make();

применить состояния
$users = factory(App\User::class, 5)->states('delinquent')->make();
$users = factory(App\User::class, 5)->states('premium', 'delinquent')->make();

изменить аттрибуты
$user = factory(App\User::class)->make([
  'name' => 'Abigail',
]);

сохранить модели
$user = factory(App\User::class)->create();
$users = factory(App\User::class, 3)->create();

сохранить с аттрибутами
$user = factory(App\User::class)->create([
  'name' => 'Abigail',
]);


создать отношения
$users = factory(App\User::class, 3)
  ->create()
  ->each(function ($user) {
     $user->posts()->save(factory(App\Post::class)->make());
});

прикрепить несколько отношений
$user->posts()->createMany(
  factory(App\Post::class, 3)->make()->toArray()
);


к посту создать юзера
$factory->define(App\Post::class, function ($faker) {
  return [
    'title' => $faker->title,
    'content' => $faker->paragraph,
    'user_id' => factory(App\User::class),
  ];
});


прикрепить вычисляемый аттрибут
$factory->define(App\Post::class, function ($faker) {
    return [
        'title' => $faker->title,
        'content' => $faker->paragraph,

        'user_id' => factory(App\User::class),

        'user_type' => function (array $post) {
            return App\User::find($post['user_id'])->type;
        },

    ];
});


посев в базу
$this->seed();
$this->seed(OrderStatusSeeder::class);

утверждения

assertDatabaseCount - колво записей равно
assertDatabaseHas - есть данные
assertDatabaseMissing - нет данных
assertDeleted - запись удалена
assertSoftDeleted - удалена мягко
-------------------------------------------------

Testing -> Mocking

имитация без выполнения
используется при тестировании

привязка имитационного объекта в СК
$this->instance(Service::class, Mockery::mock(Service::class, function ($mock) {
  $mock->shouldReceive('process')->once();
}));

СК будет юзать инстанс имитации вместо реального

или так
$this->mock(Service::class, function ($mock) {
  $mock->shouldReceive('process')->once();
});


имитировать указанные методы
$this->partialMock(Service::class, function ($mock) {
  $mock->shouldReceive('process')->once();
});

сделить за объектом
$this->spy(Service::class, function ($mock) {
    $mock->shouldHaveReceived('process');
});


Фасады

не выполнять задач
Bus::fake();
Bus::assertDispatched(function (ShipOrder $job) use ($order) {
  return $job->order->id === $order->id;
});
Bus::assertNotDispatched(AnotherJob::class);

не прослушивать события
Event::fake();
Event::assertDispatched(function (OrderShipped $event) use ($order) {
  return $event->order->id === $order->id;
});
Event::assertDispatched(OrderShipped::class, 2);
Event::assertNotDispatched(OrderFailedToShip::class);

не прослушивать только набор
Event::fake([
  OrderCreated::class,
]);

только для части теста
$order = Event::fakeFor(function () {
  $order = factory(Order::class)->create();
  Event::assertDispatched(OrderCreated::class);
});


подделка HTTP
https://laravel.com/docs/7.x/http-client#testing

не отправлять почту
в том числе в очереди
Mail::fake();

не отправлять уведомления
Notification::fake();

не ставить задачи в очередь
Queue::fake();

не загружать файлы
Storage::fake('photos');
Storage::persistentFake('photos');

имитировать фасады
кроме фасадов Request, Config

$value = Cache::get('key'); настояший вызов
Cache::shouldReceive('get')->once()->with('key')->andReturn('value'); имитация
-------------------------------------------------

Official Packages -> Cashier Stripe

биллинг Stripe API

composer require laravel/cashier

ключи API
вебхуки
выбор валюты
логи
клиенты
способы оплаты
подписки
тарифные планы
налоги
триал
разовый платёж
счета фактуры
тестирование
-------------------------------------------------

Official Packages -> Cashier Paddle

биллинг Paddle API

composer require laravel/cashier-paddle

ключи API
вебхуки
выбор валюты
платные ссылки
подписки
тарифные планы
триал
способы оплаты
разовый платёж
квитанции
тестирования нет
-------------------------------------------------

Official Packages -> Cashier Mollie

биллинг Mollie API

composer require laravel/cashier-mollie
-------------------------------------------------

Official Packages -> Dusk

Testing -> Browser Tests
выше по ману
-------------------------------------------------

Official Packages -> Envoy

удаленно выполнять задачи на серверах

composer global require laravel/envoy

Blade синтаксис
переменные. группировка задач в пакеты
последовательное и паралельное исполнение на серверах
запрос подтверждения выполнения
уведомления в Slack, Discord, Telegram
-------------------------------------------------

Official Packages -> Horizon

панель управления очередями Redis

composer require laravel/horizon

config/horizon.php
баланс simple, auto, false
воркеры
супервизор рестартит процессы линукс либа
Laravel Forge сервис конфигурации супервизора
группировка в теги задач, почт, вещания, уведомлений, прослушивателей событий, очередей
метрики
-------------------------------------------------

Official Packages -> Passport

логин для API
токены
нет состояния сеанса между запросами
на основе OAuth2

composer require laravel/passport

создать таблицы
php artisan migrate

создать ключи шифрования для токенов
php artisan passport:install будут id pramary key
php artisan passport:install --uuids будут уникальные uuids
php artisan passport:keys

трейт HasApiTokens в модель
в config/auth.php драйвер api driver passport
гуард TokenGuard
есть компоненты Passport Vue
JSON API уже есть
токены на срок
JSON API гуарды web и auth
круд клиентов
коды авторизации
круд токенов
PKCE
гуарды и провайдеры
токены гранта
выдача токенов юзеров самим себе
защита роутов через МВ
области действия токенов как права и роли через МВ Scopes
использование API через js. использование токена, куки, csrf
события при круд токенов
-------------------------------------------------

Official Packages -> Sanctum

система логина для SPA (одностраничники), приложений, API
на основе токенов. у токенов области видимости
без OAuth. токены как у GitHub
роуты
гуарды

composer require laravel/sanctum

МВ Sanctum
CORS
CSRF
вещание
тестирование
-------------------------------------------------

Official Packages -> Scout

поисковая машина
на основе индексов
драйвер Algolia

composer require laravel/scout

привязка модели
наблюдатель
очереди

конфиг в config/scout.php

composer require algolia/algoliasearch-client-php

мягкое удаление поддерживается
свои драйверы
-------------------------------------------------

Official Packages -> Socialite

логин через соцсети
поставщики OAuth
Facebook, Twitter, LinkedIn, Google, GitHub, GitLab, Bitbucket
все провайдеры https://socialiteproviders.com

composer require laravel/socialite

config/services.php

Socialite фасад

области
данные о юзере
-------------------------------------------------

Official Packages -> Telescope

отладка

composer require laravel/telescope
composer require laravel/telescope --dev локально

config/telescope.php

фильтрация что писать

теги
наблюдатели за переменными, событиями, исключениями, слушателями, задачами, журналами, почтой, моделями, уведомлениями, запросами в бд, кеширования redis, http запросами
-------------------------------------------------

Official Packages -> JetStream

готовый каркас аутентификации
интегрирован с Sanctum

composer require laravel/jetstream

2 стека фронтенда
Livewire - на основе Blade
Inertia.js - на основе VueJS
CSS в обоих случаях Tailwind

php artisan jetstream:install livewire --teams
php artisan jetstream:install inertia --teams
npm install && npm run dev
php artisan migrate
-------------------------------------------------

Official Packages -> Fortify

серверная часть для JetStream
-------------------------------------------------

Official Packages -> LiveWire

микрофреймворк для динамических компонентов
поле поиска с отображением результатов на лету
есть пагинация

composer require livewire/livewire

php artisan make:livewire search
-------------------------------------------------

Official Packages -> Sail

интерфейс командной строки для работы с Docker-контейнером для разработки
-------------------------------------------------

Official Packages -> Lumen

микрофреймворк Laravel
-------------------------------------------------

Official Packages -> Nova

платный дашбоард
-------------------------------------------------

Official Packages -> Spark

платный каркас приложения
-------------------------------------------------

Official Packages -> Forge

сервис развертывания серверов на DigitalOcean, Linode, Vultr, Amazon
сервис конфигурации супервизора для Horizon (панель управления очередями Redis)
-------------------------------------------------

Official Packages -> Vapor

бессерверная платформа от Amazon
-------------------------------------------------

CMS based Laravel

Asgard
Atlantis
Borgert
Coaster
Coaster
Decoy
Fully
Lavalite
MaguttiCMS
Microweber
October
Photon
PongoCMS
PyroCMS
Quarx
Twill
TypiCMS
-------------------------------------------------

Обновление Laravel 7 -> 8

мин версия PHP 7.3

Сеялки пространство имен Database\Seeders
Фабрики пространство имен Database\Factories

Папка database/seeds переименована в database/seeders

появился Laravel Jetstream

Collections метод isset изменился

Castable метод castUsing изменился

Dispatcher метод listen изменился

Eloquent события update и save работают для методов increment и decrement

Режим обслуживания. в public/index.php добавить код
define('LARAVEL_START', microtime(true));
if (file_exists(__DIR__.'/../storage/framework/maintenance.php')) {
  require __DIR__.'/../storage/framework/maintenance.php';
}

команда php artisan down
удалён параметр --message

команда php artisan serve
добавлен параметр --no-reload

класс Support\Manage свойство $app удалено
новое свойство $container

хелпер elixir удалён

Почта Mail метод sendNow удалён
использовать метод send

Пагинатор использует Tailwind CSS
вернуть Bootstrap в AppServiceProvider в boot() {Paginator::useBootstrap();}

очередь Queue
метод retryAfter и свойство retryAfter переименованы в backoff
свойство timeoutAt переименовано в retryUntil

когда используем withChain:
методы allOnQueue и allOnConnection удалены
методы onQueue и onConnection добавлены
в хелпере dispatch эти методы оставлены

в таблицу невыполненных задач failed_jobs добавить столбик uuid

Роуты

в RouteServiceProvider было свойство $namespace равное App\Http\Controllers

теперь $namespace = null

Контракт Session
новый метод pull

В классе тестирования TestResponse метод decodeResponseJson удален
использовать метод json

При сравнении json и массива

метод assertExactJson требует цифровые ключи и строгий порядок совпадения при сравнении

если не совпадают то использовать метод assertSimilarJson

Правила валидации unique и exists берут имя соединения из getConnectionName
-------------------------------------------------