Состав файла

Getting Started, Query Builder, Pagination, Migrations, Seeding
-------------------------------------------------

GETTING STARTED

Фасад DB

Базы данных
MySQL 5.6+, PostgreSQL 9.4+, SQLite 3.8.8+, SQL Server 2017+

Методы работы
Eloquent ORM, query builder, сырой SQL

Конфиг
config/database.php
--------------------

SQLite

создать бд
touch database/database.sqlite

Конфиг в .env
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
DB_FOREIGN_KEYS=true для ограничений внешнего ключа

Настройки параметров 1 урлом driver://username:password@host:port/database?options

Разные соединения для SELECT и INSERT-UPDATE-DELETE

'mysql' => [
  'read' => [],
  'write' => [],
  'sticky' => true, сразу разрешить чтение данных, которые были добавлены в текущем запросе. запись была сделана, операция чтения возьмёт данные из соединения write а не read, ибо в read еще нет этих данных
];

Фасад DB
методы select, update, insert, delete, statement, transaction

Доступ к разным соединениям с БД
foo должно быть соединением с бд из config/database.php
DB::connection('foo');

Доступ к сырому инстансу PDO
DB::connection()->getPdo();
--------------------

Запросы сырого SQL

Биндинг параметров. защищает от SQL injection
DB::select('select * from users where active = ?', [1]);

именованные параметры
DB::select('select * from users where id = :id', ['id' => 1]);

DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);

Вернёт колво строк
DB::update('update users set votes = 100 where name = ?', ['John']);
DB::delete('delete from users');

Для запросов не возвращающих значения
DB::statement('drop table users');
--------------------

События и Слушатель запроса

в AppServiceProvider
public function boot() {
  DB::listen(function ($query) {
    $query->sql
    $query->bindings
    $query->time
  });
}

Транзакции
транзакции это набор операций
если возникла ошибка то всё откатывается назад

DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
});

Отработка блокировок

5 попыток проведения транзакции
DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
}, 5);

Транзакции вручную
DB::beginTransaction();
DB::rollBack();
DB::commit();
-------------------------------------------------

QUERY BUILDER

Query Builder (КБ) это построитель запросов
использует PDO для создания и выполнения запросов
работает для всех видов БД
привязки предотвращают атаки SQL injection

Фасад DB
--------------------

Выйти с Eloquent на КБ
query()

Получить все строки
get()

Получить 1ю строку
first()

Получить 1 строку по id
find(3)

Получить 1 строку 1 столбик
value('email')

Получить все строки по 1 или нескольким столбикам
pluck('title')
pluck('title', 'name')

Получить все строки чанками по N
chunk(100, function ($users) {})

Обновить все строки чанками по N
DB::table('users')->chunkById(N, function ($users) {
  foreach ($users as $user) {
    DB::table('users')->where('id', $user->id)->update(['active' => true]);
  }
})
--------------------

Агрегатные функции
count()
max()
min()
avg()
sum()

Проверка на существование
exists()
doesntExist()
--------------------

Select

выбрать нужные столбики
select('name', 'email as user_email')

выбрать с distinct
distinct()

на лету добавить в select еще столбик
$query = DB::table('users')->select('name');
$query->addSelect('age');
--------------------

Сырые запросы
самому обрабатывать код против SQL injection

DB::raw универсален
select(DB::raw('count(*) as count'))

Остальные алиасы raw
selectRaw()
whereRaw()
havingRaw()
orderByRaw()
groupByRaw()
--------------------

Запросы Join

join('posts', 'users.id', '=', 'posts.user_id')
leftJoin('posts', 'users.id', '=', 'posts.user_id')
rightJoin('posts', 'users.id', '=', 'posts.user_id')
crossJoin('colors')
--------------------

Дополнительные условия в Join

join('contacts', function ($join) {
  $join->on('users.id', '=', 'contacts.user_id')
    ->where('contacts.user_id', '>', 5);
	->orOn(...);
})
--------------------

Подзапросы в Join
joinSub, leftJoinSub, rightJoinSub

$latestPosts = DB::table('posts')
  ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)
  ->groupBy('user_id');

$users = DB::table('users')
  ->joinSub($latestPosts, 'latest_posts', function ($join) {
    $join->on('users.id', '=', 'latest_posts.user_id');
})->get();
--------------------

Запросы Union
union, unionAll

$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first);
--------------------

Where

where('votes', 10);
where('votes', '=', 10);
where('votes', '>=', 10);
where('name', 'like', '%word%');
where([['a', '=', '1'], ['b', '<>', '1']]);
orWhere('name', 'John');
--------------------

Группировка внутри or (... and ...)

DB::table('users')
  ->where('votes', '>', 100)
  ->orWhere(function($query) {
    $query->where('name', 'Abigail')
	  ->where('votes', '>', 50);
  })
->get();
--------------------

Дополнительные методы

whereBetween, orWhereBetween
whereNotBetween, orWhereNotBetween

whereIn, whereNotIn
orWhereIn, orWhereNotIn

когда внутри IN() большой массив
whereIntegerInRaw, whereIntegerNotInRaw

whereNull, whereNotNull
orWhereNull, orWhereNotNull

для сравнения с датой
whereDate, whereMonth, whereDay, whereYear, whereTime 

для сравнения 2 столбиков
whereColumn, orWhereColumn
--------------------

Группировка параметров внутри замыкания
всегда группировать вызовы orWhere

select * from users where name = 'John' and (votes > 100 or title = 'Admin')

DB::table('users')
  ->where('name', '=', 'John')
  ->where(function ($query) {
    $query->where('votes', '>', 100)
      ->orWhere('title', '=', 'Admin');
})->get();
--------------------

Метод whereExists

select * from users where exists (select 1 from orders where orders.user_id = users.id)

DB::table('users')
  ->whereExists(function ($query) {
    $query->select(DB::raw(1))
      ->from('orders')
      ->whereRaw('orders.user_id = users.id');
})->get();
--------------------

Подзапрос во Where

User::where(function ($query) {
  $query->select('type')
    ->from('membership')
    ->whereColumn('user_id', 'users.id')
    ->orderByDesc('start_date')
    ->limit(1);
}, 'Pro')->get();
--------------------

Запросы из столбиков Json

where('options->language', 'en')
whereJsonContains('options->languages', 'en')
whereJsonContains('options->languages', ['en', 'de'])
whereJsonLength('options->languages', 0)
whereJsonLength('options->languages', '>', 1)
--------------------

Сортировка

orderBy('name', 'desc')
orderBy('name', 'desc')->orderBy('email', 'asc')

сортировка по дате по столбику created_at
latest()

сортировка по дате по столбику column
latest('column')

сортировка рандомная
inRandomOrder()

Удалить сортировку
reorder()

Удалить сортировку и применить новую
reorder('email', 'desc')
--------------------

Группировка
работает как where

groupBy('account_id')
groupBy('account_id', 'status')

having('account_id', '>', 100)
having('account_id', '>', 100)
--------------------

Лимит и офсет
skip это limit
take это offset

skip(N)
take(M)

limit(N)
offset(M)
--------------------

Условные добавления в запрос

$role = $request->input('role');


Если $role true, то выполнится замыкание

when($role, function ($query, $role) {
  return $query->where('role_id', $role);
})->get();

Если $role false, то выполнится второе замыкание

when($role, function ($query, $role) {
  return $query->orderBy($role);
}, function ($query) {
  return $query->orderBy('name');
})->get();
--------------------

Вставка строк

вставка 1 строки
insert(['email' => 'john@example.com', 'votes' => 0]);

вставка много строк
insert([
  ['email' => 'taylor@example.com', 'votes' => 0],
  ['email' => 'dayle@example.com', 'votes' => 0],
]);

игнорирование дубликатов при вставке
insertOrIgnore([
  ['id' => 1, 'email' => 'taylor@example.com'],
  ['id' => 2, 'email' => 'dayle@example.com'],
]);

вставка 1 строки и получить вставленный ID
insertGetId(['email' => 'john@example.com', 'votes' => 0]);
insertGetId(['email' => 'john@example.com', 'votes' => 0], 'id_user');
--------------------

Обновления строк

обновить строку
update(['votes' => 1])

обновить или вставить
если строка не найдена, то будет вставлена с данными из обоих массивов

updateOrInsert(

  условия для поиска строки
  ['email' => 'john@example.com', 'name' => 'John'], 
  
  что обновлять
  ['votes' => '2']
);

обновить строку JSON
update(['options->enabled' => true]);
--------------------

Инкремент и Декремент столбика
для них не работают события модели

increment('votes');
increment('votes', 5); на +5
decrement('votes');
decrement('votes', 5); на -5
increment('votes', 1, ['name' => 'John']); попутно еще что-то обновим
--------------------

Удаление строк

delete()
truncate(); удалит все строки и сбросит счетчик ID
--------------------

Блокировка

блокирует изменение строк, пока транзакция не зафиксирована
sharedLock()

блокирует выборку и изменение строк, пока существует sharedLock
lockForUpdate()
--------------------

SQL debug

sql запрос и результат
Brand::query()->dd();
Brand::query()->dump();

sql запрос
dd(Brand::query()->toSql());

explain запроса
Brand::query()->explain()->dd();

use Illuminate\Support\Facades\DB;
DB::enableQueryLog();
  код
dd(DB::getQueryLog());
-------------------------------------------------

PAGINATION

Пагинатор встроен в Eloquent ORM и Query Builder
метод groupBy() не работает с методом paginate()

Без пагинатора
all()
get()

Пагинатор ссылки "1,2,3"
paginate(10)

Пагинатор ссылки "Назад, Вперед"
simplePaginate(10)

Пагинатор с Eloquent
User::paginate(10)
User::simplePaginate(10)
--------------------

Свой пагинатор
стиль paginate от Pagination\LengthAwarePaginator
стиль simplePaginate от Pagination\Paginator
--------------------

Конвертация пагинатора в Json
метод toJson

{
  "total": 50,
  "per_page": 15,
  "current_page": 1,
  "last_page": 4,
  "first_page_url": "http://laravel.app?page=1",
  "last_page_url": "http://laravel.app?page=4",
  "next_page_url": "http://laravel.app?page=2",
  "prev_page_url": null,
  "path": "http://laravel.app",
  "from": 1,
  "to": 15,
  "data":[
    {Result Object},
    {Result Object}
   ]
}
--------------------

Счетчик страниц в урле пагинатора
page=N

Изменить ссылки пагинатора
withPath('custom/url')
будут ссылки вида custom/url?page=N

Ссылки пагинатора
{{$users->links()}}

Добавить параметр к ссылкам в query string
{{$users->appends(['sort' => 'votes'])->links()}}

Добавить весь query string к ссылкам
{{$users->withQueryString()->links()}}

Добавить хеш к ссылкам в query string
{{$users->fragment('foo')->links()}}

Настройка колва ссылок
{{$users->onEachSide(N)->links()}}

Изменить внешний вид ссылок
{{$paginator->links('view.name')}}
{{$paginator->links('view.name', ['foo' => 'bar'])}}

Экспорт вьюх ссылок пагинатора в свой каталог resources/views/vendor/pagination
php artisan vendor:publish --tag=laravel-pagination

Изменить название вьюхи

в AppServiceProvider
public function boot() {
  Paginator::defaultView('view-name');
  Paginator::defaultSimpleView('view-name');

  смена дизайна с Bootstrap на Tailwind CSS
  Paginator::useTailwind();
}

Все методы пагинатора
count, currentPage, firstItem, getOptions, getUrlRange, hasPages, 
hasMorePages, items, lastItem, lastPage, nextPageUrl, onFirstPage, 
perPage, previousPageUrl, total, url, getPageName, setPageName
-------------------------------------------------

MIGRATIONS

Миграции это аналог системы контроля версий для структуры БД
миграции создают таблицы, столбцы
фасад Schema

Таблица migrations
это лог всех миграций

Папка миграций
database/migrations
-------------------------

Создать миграцию
php artisan make:migration Name

Создать миграцию для таблицы table
php artisan make:migration Name --create=table
--------------------

Запустить все миграци
php artisan migrate

Запустить 1 миграцию
php artisan migrate --path=/database/migrations/name.php

Запустить все миграци без дополнительного подтверждения
php artisan migrate --force
--------------------

Откатить последнюю миграцию
php artisan migrate:rollback

Откатить последние N миграций
php artisan migrate:rollback --step=N

Откатить все миграции
php artisan migrate:reset
--------------------

Сбросить и запустить все миграции (пересоздание БД)
php artisan migrate:refresh

Сбросить и запустить все миграции (пересоздание БД и посев)
php artisan migrate:refresh --seed

Удалить все таблицы и запустить все миграции
php artisan migrate:fresh

1 команда на всё
Удалить все таблицы и запустить все миграции (сделать посев)
php artisan migrate:fresh --seed
-------------------------

Класс миграции
в методах используется schema builder

метод up
создать таблицы, столбики, индексы

метод down
удалить таблицы, столбики, индексы

public function up() {

  создать таблицу
  Schema::create('names', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->timestamps();
  });
  
}

public function down() {
  
  удалить таблицу
  Schema::drop('names');
}
-------------------------------------------------

Проверка на существование таблицы
if (Schema::hasTable('users')) {}

Проверка на существование столбика
if (Schema::hasColumn('users', 'email')) {}
--------------------

Выбрать соединение
Schema::connection('foo')->create('users', function (Blueprint $table) {
  $table->id();
});
--------------------

Параметры таблицы

$table->engine = 'InnoDB';
$table->charset = 'utf8mb4';
$table->collation = 'utf8mb4_unicode_ci';
DB::statement("ALTER TABLE `brands` comment 'коммент к таблице'");

Переименовать таблицу
Schema::rename($from, $to);

Удалить таблицу
Schema::drop('users');
Schema::dropIfExists('users');
-------------------------

У id и foreign_id должны совпадать тип столбца

1 связка
$table->integer('id')->autoIncrement();
$table->integer('categories_id');
$table->index('categories_id');
$table->foreign('categories_id')->references('id')->on('categories');

2 связка
$table->id();
$table->foreignId('categories_id')->constrained();
-------------------------

Виды столбца id

$table->id();
$table->bigIncrements('id');
`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT

$table->increments('id');
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT

$table->integer('id')->autoIncrement();
`id` INT NOT NULL AUTO_INCREMENT
-------------------------

Создать столбик

$table->string('name');
`name` VARCHAR(255) NOT NULL

$table->string('name')->nullable()->comment('название');
`name` VARCHAR(255) NULL COMMENT 'название'

$table->string('email', 100);
$table->boolean('confirmed');
$table->enum('level', ['0', '1']);
$table->integer('votes');
$table->text('description');
$table->timestamp('added_on', 0);

$table->timestamps();
`created_at` TIMESTAMP NULL, `updated_at` TIMESTAMP NULL

Случай когда 1 столбик CURRENT_TIMESTAMP а второй ON UPDATE CURRENT_TIMESTAMP

$table->timestamp('added')->useCurrent();
$table->timestamp('update')->useCurrent()
  ->default(DB::raw('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'));
--------------------

Индексы

$table->primary();
$table->unique();
$table->index();
$table->spatialIndex();

Составной ключ для промежуточной таблицы типа brand_site
строго 1 сочетание "1 сайт + 1 бренд"
$table->primary(['brand_id', 'site_id']);

Составной индекс
$table->index(['brand_id', 'site_id']);

Модификаторы

->after()
->autoIncrement()
->charset()
->collation()
->comment()
->default()
->first()
->from()
->nullable()
->storedAs()
->unsigned()
->useCurrent() - CURRENT_TIMESTAMP
->useCurrentOnUpdate() CURRENT_TIMESTAMP
->virtualAs()
->generatedAs()
->always()
--------------------

Написание специфичных функций
$table->json('movies')->default(new Expression('(JSON_ARRAY())'));
--------------------

Изменение столбиков
поставить composer require doctrine/dbal

Изменить столбик
Schema::table('users', function (Blueprint $table) {
  $table->string('name', 50)->change();
});
Schema::table('users', function (Blueprint $table) {
  $table->string('name', 50)->nullable()->change();
});

Переименовать столбик
Schema::table('users', function (Blueprint $table) {
  $table->renameColumn('from', 'to');
});

Удалить столбик
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn('votes');
});

Удалить несколько столбиков
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn(['votes', 'avatar', 'location']);
});

Методы работы со столбиками
dropMorphs, dropRememberToken, dropSoftDeletes, dropSoftDeletesTz, dropTimestamps, dropTimestampsTz
--------------------

Кодировка
по умолчанию utf8mb4
--------------------

Создать индекс
имена индексов создаются автоматически на основе имени таблицы и столбика

$table->string('email')->unique();
$table->unique('email');
$table->index(['account_id', 'created_at']);
$table->unique('email', 'mynameindexemail');

Методы индексов
primary, unique, index, spatialIndex

Длинна индексов
varchar по умолчанию 255

настроить в AppServiceProvider
public function boot() {
  Schema::defaultStringLength(255);
}

Переименовать индекс
$table->renameIndex('from', 'to')

Удалить индекс указав имя индекса
$table->dropPrimary('indexname');
$table->dropUnique('indexname');
$table->dropIndex('indexname');
$table->dropSpatialIndex('indexname');

Удалить индекс указав имя столбика, правильный индекс сгенерится сам
Schema::table('geo', function (Blueprint $table) {
  $table->dropIndex(['state']); - автоназвание geo_state_index
});
--------------------

Foreign key

Связь posts.user_id -> users.id

Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');
});

foreignId это алиас для unsignedBigInteger

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained();
});

constrained() автоматически найдет таблицу и столбик

можно уточнить
Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained('users');
});


Action для "On Delete" и "On Update"

$table->foreignId('user_id')->constrained()->onDelete('cascade');

модификаторы столбиков
$table->foreignId('user_id')->nullable()->constrained();

Удалить внешний ключ по названию ключа
$table->dropForeign('posts_user_id_foreign');

В ограничениях внешнего ключа используется то же соглашение об именах, что и в индексах
на основе имени таблицы и столбика за которыми суффикс _foreign

Удалить внешний ключ по названию столбика, а имя ключа сгенерится автоматом
$table->dropForeign(['user_id']);

Включить и отключить ограничения внешнего ключа
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();

в SQLite по умолчанию ограничение внешнего ключа отключено
Его нужно включить в config/database.php в параметре DB_FOREIGN_KEYS = true
SQLite поддерживает внешние ключи только при создании таблицы, а не при изменении
-------------------------------------------------

SEEDING

Заполнить БД тестовыми данными
сидеры вызывают фабрики
используется Eloquent и Query Builder
зависимости разрешаются через СК

Папка сидеров
database/seeds (ver 7)
database/seeders (ver 8)

Создать сидер
php artisan make:seeder Name

public function run() {

  Query Builder
  DB::table('users')->insert([
    'name' => Str::random(10),
    'email' => Str::random(10).'@gmail.com',
    'password' => Hash::make('password'),
  ]);
  
  Eloquent
  User::factory(5)->create();
  
  factory(User::class, 50)->create()->each(function ($user) {
    $user->posts()->save(factory(Post::class)->make());
  });
  
}
--------------------

Запуск нескольких сидеров
в database/seeders/DatabaseSeeder.php

public function run() {
  $this->call([
    UserSeeder::class,
    PostSeeder::class,
    CommentSeeder::class,
  ]);
}
--------------------

Мои примеры
в database/seeders/DatabaseSeeder.php

Создать бренды
Brand::factory(5)->create();
Brand::factory()->count(5)->create();
Brand::factory()->count(5)->create(['addparam' => 1]);

Создать бренды но не сохранять
Brand::factory(5)->make();
Brand::factory()->count(5)->make();
Brand::factory()->count(5)->make(['addparam' => 1]);

Изменить аттрибуты
Brand::factory()->state(['existparam' => 1])->make();

Создать бренды и сайты и в промежуточной таблице связь "сайт-бренд"
связь N:M "brands->brand_site<-sites"
Brand::factory(5)->has(Site::factory(5))->create();

Создать категории и сайты
когда связь 1:M "categories->sites"
Category::factory(5)->hasSites(5)->create();
Category::factory(5)->hasSites(5, ['addparam' => 1])->create();
Category::factory(5)->has(Site::factory()->count(5))->create();
Category::factory(5)->has(Site::factory()->count(5), 'sites')->create();

Создать сайты и категории
Site::factory()->count(5)->for(Category::factory())->create();
Site::factory()->count(5)->forCategory()->create();

Создать юзеров, сайты, и отзывы
User::factory()->has(Site::factory()->count(5))->create();
--------------------

Обновить автозагрузчик после появления новых классов
composer dump-autoload

Запустить все сидеры
php artisan db:seed

Запустить 1 сидер
php artisan db:seed --class=Brand

Запустить без дополнительного подтверждения
php artisan db:seed --force
-------------------------------------------------