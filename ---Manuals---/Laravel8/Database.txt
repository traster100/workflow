Состав файла

Getting Started, Query Builder, Pagination, Migrations, Seeding
-------------------------------------------------

GETTING STARTED

Фасад DB

Базы данных
MySQL 5.6+, PostgreSQL 9.4+, SQLite 3.8.8+, SQL Server 2017+

Методы работы
Eloquent ORM, query builder, сырой SQL

Конфиг
config/database.php
--------------------

SQLite

создать бд
touch database/database.sqlite

Конфиг в .env
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
DB_FOREIGN_KEYS=true для ограничений внешнего ключа

Настройки параметров 1 урлом driver://username:password@host:port/database?options

Разные соединения для SELECT и INSERT-UPDATE-DELETE

'mysql' => [
  'read' => [],
  'write' => [],
  'sticky' => true, сразу разрешить чтение данных, которые были добавлены в текущем запросе. запись была сделана, операция чтения возьмёт данные из соединения write а не read, ибо в read еще нет этих данных
];

Фасад DB
методы select, update, insert, delete, statement, transaction

Доступ к разным соединениям с БД
foo должно быть соединением с бд из config/database.php
DB::connection('foo');

Доступ к сырому инстансу PDO
DB::connection()->getPdo();
--------------------

Запросы сырого SQL

Биндинг параметров. защищает от SQL injection
DB::select('select * from users where active = ?', [1]);

именованные параметры
DB::select('select * from users where id = :id', ['id' => 1]);

DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);

Вернёт колво строк
DB::update('update users set votes = 100 where name = ?', ['John']);
DB::delete('delete from users');

Для запросов не возвращающих значения
DB::statement('drop table users');
--------------------

События и Слушатель запроса

в AppServiceProvider
public function boot() {
  DB::listen(function ($query) {
    $query->sql
    $query->bindings
    $query->time
  });
}

Транзакции
транзакции это набор операций
если возникла ошибка то всё откатывается назад

DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
});

Отработка блокировок

5 попыток проведения транзакции
DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
}, 5);

Транзакции вручную
DB::beginTransaction();
DB::rollBack();
DB::commit();
-------------------------------------------------

QUERY BUILDER

Query Builder (КБ) это построитель запросов
использует PDO для создания и выполнения запросов
работает для всех систем БД
привязки предотвращают атаки SQL injection

Фасад DB
--------------------

Выйти с Eloquent на КБ
$users = User::query()->where();

Получить все строки
DB::table('users')->get();

Получить 1ю строку
DB::table('users')->where('name', 'John')->first();

Получить 1 строку по id
DB::table('users')->find(3);

Получить 1 строку 1 столбик
DB::table('users')->where('name', 'John')->value('email');

Получить все строки по 1 или нескольким столбикам
DB::table('roles')->pluck('title');
DB::table('roles')->pluck('title', 'name');

Получить все строки чанками по N
DB::table('users')->chunk(100, function ($users) {});

Обновить все строки чанками по N
DB::table('users')->chunkById(100, function ($users) {
  foreach ($users as $user) {
    DB::table('users')->where('id', $user->id)->update(['active' => true]);
  }
});
--------------------

Агрегатные функции
DB::table('users')->count();
DB::table('users')->max();
DB::table('users')->min();
DB::table('users')->avg();
DB::table('users')->sum();

Проверка на существование
DB::table('users')->exists();
DB::table('users')->doesntExist();
--------------------

Select

выбрать нужные столбики
DB::table('users')->select('name', 'email as user_email')->get();

выбрать с distinct
DB::table('users')->distinct()->get();

на лету добавить в select еще столбик
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();
--------------------

Сырые запросы
самому обрабатывать код против SQL injection

DB::raw универсален
DB::table('users')->select(DB::raw('count(*) as count'))->get();

Остальные удобные алиасы
DB::table('users')->selectRaw()->get();
DB::table('users')->whereRaw()->get();
DB::table('users')->havingRaw()->get();
DB::table('users')->orderByRaw()->get();
DB::table('users')->groupByRaw()->get();
--------------------

Запросы Join

inner join

DB::table('users')
  ->join('contacts', 'users.id', '=', 'contacts.user_id')
  ->select('users.*', 'contacts.phone')
  ->get();


left join, right join

DB::table('users')
  ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
  ->get();
  
DB::table('users')
  ->rightJoin('posts', 'users.id', '=', 'posts.user_id')
  ->get();

cross join

DB::table('sizes')
  ->crossJoin('colors')
  ->get();
--------------------

Дополнительные условия в Join

DB::table('users')
  ->join('contacts', function ($join) {
    $join->on('users.id', '=', 'contacts.user_id')
	  ->where('contacts.user_id', '>', 5);
	  ->orOn(...);
  })
  ->get();

Подзапросы в Join
joinSub, leftJoinSub, rightJoinSub

$latestPosts = DB::table('posts')
  ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)
  ->groupBy('user_id');

$users = DB::table('users')
  ->joinSub($latestPosts, 'latest_posts', function ($join) {
    $join->on('users.id', '=', 'latest_posts.user_id');
})->get();
--------------------

Запросы Union
union, unionAll

$first = DB::table('users')
  ->whereNull('first_name');
  
$users = DB::table('users')
  ->whereNull('last_name')
  ->union($first)
  ->get();
--------------------

Уточнения по Where

DB::table('users')->where('votes', 10)->get();
DB::table('users')->where('votes', '=', 10)->get();
DB::table('users')->where('votes', '>=', 10)->get();
DB::table('users')->where('name', 'like', 'T%')->get();
DB::table('users')->where([['a', '=', '1'], ['b', '<>', '1']])->get();
DB::table('users')->orWhere('name', 'John')->get();

Группировка внутри or (... and ...)

DB::table('users')
  ->where('votes', '>', 100)
  ->orWhere(function($query) {
    $query->where('name', 'Abigail')
	  ->where('votes', '>', 50);
  })
->get();
--------------------

Дополнительные методы

whereBetween, orWhereBetween
whereNotBetween, orWhereNotBetween
whereIn, whereNotIn
orWhereIn, orWhereNotIn
whereIntegerInRaw, whereIntegerNotInRaw (когда внутри IN() большой массив)
whereNull, whereNotNull
orWhereNull, orWhereNotNull
whereDate, whereMonth, whereDay, whereYear, whereTime для сравнения с датой
whereColumn, orWhereColumn для сравнения 2 столбиков
--------------------

Группировка параметров скобочками внутри замыкания
всегда группировать вызовы orWhere

select * from users where name = 'John' and (votes > 100 or title = 'Admin')

DB::table('users')
  ->where('name', '=', 'John')
  ->where(function ($query) {
    $query->where('votes', '>', 100)
      ->orWhere('title', '=', 'Admin');
})->get();
--------------------

Метод whereExists

select * from users where exists (select 1 from orders where orders.user_id = users.id)

DB::table('users')
  ->whereExists(function ($query) {
    $query->select(DB::raw(1))
      ->from('orders')
      ->whereRaw('orders.user_id = users.id');
})->get();
--------------------

Подзапрос во Where

User::where(function ($query) {
  $query->select('type')
    ->from('membership')
    ->whereColumn('user_id', 'users.id')
    ->orderByDesc('start_date')
    ->limit(1);
}, 'Pro')->get();
--------------------

Запросы из столбиков Json

DB::table('users')->where('options->language', 'en')->get();
DB::table('users')->whereJsonContains('options->languages', 'en')->get();
DB::table('users')->whereJsonContains('options->languages', ['en', 'de'])->get();

запросы по длинне

DB::table('users')->whereJsonLength('options->languages', 0)->get();
DB::table('users')->whereJsonLength('options->languages', '>', 1)->get();
--------------------

Сортировка

DB::table('users')->orderBy('name', 'desc')->get();
DB::table('users')->orderBy('name', 'desc')->orderBy('email', 'asc')->get();

сортировка по дате (по столбику created_at)
можно передать своё имя столбика

DB::table('users')->latest()->first();

сортировка рандомная
DB::table('users')->inRandomOrder()->first();

Удалить сортировку
$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();

Удалить сортировку и применить новую
$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();
--------------------

Группировка
groupBy и having
работает как where

DB::table('users')
  ->groupBy('account_id')
  ->having('account_id', '>', 100)
  ->get();
  
DB::table('users')
  ->groupBy('first_name', 'status')
  ->having('account_id', '>', 100)
  ->get();
--------------------

Лимит и офсет
skip это limit
take это offset

DB::table('users')
  ->skip(10)
  ->take(5)
  ->get();
  
DB::table('users')
  ->offset(10)
  ->limit(5)
  ->get();
--------------------

Условные добавления в запрос

when выполняет Замыкание, когда переданный параметр true

$role = $request->input('role');

$users = DB::table('users')
  ->when($role, function ($query, $role) {
    return $query->where('role_id', $role);
})->get();

2 замыкания, второе сработает, когда переданный параметр false

$sortBy = null;

$users = DB::table('users')
  ->when($sortBy, function ($query, $sortBy) {
    return $query->orderBy($sortBy);
  }, function ($query) {
    return $query->orderBy('name');
})->get();
--------------------

Вставка строк
insert, insertOrIgnore, insertGetId

вставка 1 строки
DB::table('users')->insert(['email' => 'john@example.com', 'votes' => 0]);

вставка много строк
DB::table('users')->insert([
  ['email' => 'taylor@example.com', 'votes' => 0],
  ['email' => 'dayle@example.com', 'votes' => 0],
]);

игнорирование дубликатов при вставке
DB::table('users')->insertOrIgnore([
  ['id' => 1, 'email' => 'taylor@example.com'],
  ['id' => 2, 'email' => 'dayle@example.com'],
]);

вставка 1 строки и получить вставленный ID
$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);
$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0], 'id_user');
--------------------

Обновления строк
update, updateOrInsert

обновить строку
$affected = DB::table('users')
  ->where('id', 1)
  ->update(['votes' => 1]);

обновить или вставить
если строка не найдена, то она будет вставлена с данными из обоих массивов

DB::table('users')
  ->updateOrInsert(
    ['email' => 'john@example.com', 'name' => 'John'], массив условий поиска строки
    ['votes' => '2'] что обновлять
);

обновить строку JSON
DB::table('users')->where('id', 1)->update(['options->enabled' => true]);
--------------------

Инкремент и Декремент столбика
increment, decrement
для них не работают события модели

DB::table('users')->increment('votes');
DB::table('users')->increment('votes', 5); на +5
DB::table('users')->decrement('votes');
DB::table('users')->decrement('votes', 5); на -5
DB::table('users')->increment('votes', 1, ['name' => 'John']); попутно что-то еще обновим
--------------------

Удаление строк
delete, truncate

DB::table('users')->delete();
DB::table('users')->where('votes', '>', 100)->delete();
DB::table('users')->truncate(); удалит все строки и сбросит счетчик ID
--------------------

Блокировка

блокирует изменение строк, пока транзакция не зафиксирована

DB::table('users')
  ->where('votes', '>', 100)
  ->sharedLock()
  ->get();

блокирует выборку и изменение строк, пока существует sharedLock

DB::table('users')
  ->where('votes', '>', 100)
  ->lockForUpdate()
  ->get();
--------------------

SQL debug

sql запрос и результат
Brand::query()->dd();
Brand::query()->dump();

sql запрос
dd(Brand::query()->toSql());

explain запроса
Brand::query()->explain()->dd();

use Illuminate\Support\Facades\DB;
DB::enableQueryLog();
  код
dd(DB::getQueryLog());
-------------------------------------------------

PAGINATION

Пагинатор встроен в Eloquent ORM и Query Builder
метод groupBy не работает с методом paginate()

Без пагинатора
User:all();
DB::table('users')->get();

Пагинатор ссылки "1,2,3"
User:paginate(10);
DB::table('users')->paginate(10);

Пагинатор ссылки "Назад, Вперед"
User:simplePaginate(10);
DB::table('users')->simplePaginate(10);

Пагинатор с Eloquent
App\User::paginate(15);
User::where('votes', '>', 100)->paginate(15);
User::where('votes', '>', 100)->simplePaginate(15);
--------------------

Свой пагинатор
стиль paginate от Pagination\LengthAwarePaginator
стиль simplePaginate от Pagination\Paginator
--------------------

Ссылки пагинатора
{{$users->links()}}

Счетчик страниц в урле пагинатора
page=N

Изменить ссылки
$users = App\User::paginate(15)->withPath('custom/url');
будут такие custom/url?page=N

Добавить параметр к ссылкам
{{$users->appends(['sort' => 'votes'])->links()}}
добавит sort=votes в query string

Добавить весь query string к ссылкам
{{$users->withQueryString()->links()}}

Добавить хеш к ссылкам
{{$users->fragment('foo')->links()}}
добавит #foo

Настройка колва ссылок
по умолчанию 3
{{$users->onEachSide(5)->links()}}
--------------------

Конвертация пагинатора в Json
метод toJson

{
  "total": 50,
  "per_page": 15,
  "current_page": 1,
  "last_page": 4,
  "first_page_url": "http://laravel.app?page=1",
  "last_page_url": "http://laravel.app?page=4",
  "next_page_url": "http://laravel.app?page=2",
  "prev_page_url": null,
  "path": "http://laravel.app",
  "from": 1,
  "to": 15,
  "data":[
    {Result Object},
    {Result Object}
   ]
}
--------------------

Изменить внешний вид ссылок пагинатора
{{$paginator->links('view.name')}}
{{$paginator->links('view.name', ['foo' => 'bar'])}}

Экспорт вьюх пагинатора в свой каталог resources/views/vendor/pagination
php artisan vendor:publish --tag=laravel-pagination

Изменить название вьюхи

в AppServiceProvider
public function boot() {

  Paginator::defaultView('view-name');
  Paginator::defaultSimpleView('view-name');

  смена дизайна с Bootstrap на Tailwind CSS
  Paginator::useTailwind();
}

Все методы пагинатора
count, currentPage, firstItem, getOptions, getUrlRange, hasPages, 
hasMorePages, items, lastItem, lastPage, nextPageUrl, onFirstPage, 
perPage, previousPageUrl, total, url, getPageName, setPageName
-------------------------------------------------

MIGRATIONS

Миграции это аналог системы контроля версий для структуры БД
миграции создают таблицы, столбцы
фасад Schema

Таблица migrations
это лог всех миграций

Папка миграций
database/migrations
-------------------------

Создать миграцию
php artisan make:migration Name

Создать миграцию для таблицы table
php artisan make:migration Name --create=table
--------------------

Запустить все миграци
php artisan migrate

Запустить 1 миграцию
php artisan migrate --path=/database/migrations/name.php

Запустить все миграци без дополнительного подтверждения
php artisan migrate --force
--------------------

Откатить последнюю миграцию
php artisan migrate:rollback

Откатить последние N миграций
php artisan migrate:rollback --step=N

Откатить все миграции
php artisan migrate:reset
--------------------

Сбросить и запустить все миграции (пересоздание БД)
php artisan migrate:refresh

Сбросить и запустить все миграции (пересоздание БД и посев)
php artisan migrate:refresh --seed

Удалить все таблицы и запустить все миграции
php artisan migrate:fresh

1 команда на всё
Удалить все таблицы и запустить все миграции (сделать посев)
php artisan migrate:fresh --seed
-------------------------

Класс миграции
в методах используется schema builder

метод up
создать таблицы, столбики, индексы

метод down
удалить таблицы, столбики, индексы

public function up() {

  создать таблицу
  Schema::create('names', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->timestamps();
  });
  
}

public function down() {
  
  удалить таблицу
  Schema::drop('names');
}
-------------------------------------------------

Проверка на существование таблицы
if (Schema::hasTable('users')) {}

Проверка на существование столбика
if (Schema::hasColumn('users', 'email')) {}
--------------------

Выбрать соединение
Schema::connection('foo')->create('users', function (Blueprint $table) {
  $table->id();
});
--------------------

Параметры таблицы

$table->engine = 'InnoDB';
$table->charset = 'utf8mb4';
$table->collation = 'utf8mb4_unicode_ci';
DB::statement("ALTER TABLE `brands` comment 'коммент к таблице'");

Переименовать таблицу
Schema::rename($from, $to);

Удалить таблицу
Schema::drop('users');
Schema::dropIfExists('users');
-------------------------

У id и foreign_id должны совпадать тип столбца

Если ID такой
$table->integer('id')->autoIncrement();

То Foreign_ID такой
$table->integer('categories_id');
$table->index('categories_id');
$table->foreign('categories_id')->references('id')->on('categories');

Если ID такой
$table->id();

То Foreign_ID такой
$table->foreignId('categories_id')->constrained();
-------------------------

Виды столбца id

$table->id();
$table->bigIncrements('id');
`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT

$table->increments('id');
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT

$table->integer('id')->autoIncrement();
`id` INT NOT NULL AUTO_INCREMENT
-------------------------

Создать столбик

$table->string('name');
`name` VARCHAR(255) NOT NULL

$table->string('name')->nullable()->comment('название');
`name` VARCHAR(255) NULL COMMENT 'название'

$table->string('email', 100);
$table->boolean('confirmed');
$table->enum('level', ['0', '1']);
$table->integer('votes');
$table->text('description');
$table->timestamp('added_on', 0);

$table->timestamps();
`created_at` TIMESTAMP NULL, `updated_at` TIMESTAMP NULL

Случай когда 1 столбик CURRENT_TIMESTAMP а второй ON UPDATE CURRENT_TIMESTAMP

$table->timestamp('added')->useCurrent();
$table->timestamp('update')->useCurrent()
  ->default(DB::raw('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'));
--------------------

Индексы

$table->primary();
$table->unique();
$table->index();
$table->spatialIndex();

Составной ключ для промежуточной таблицы типа brand_site
строго 1 сочетание "1 сайт + 1 бренд"
$table->primary(['brand_id', 'site_id']);

Составной индекс
$table->index(['brand_id', 'site_id']);

Модификаторы

->after()
->autoIncrement()
->charset()
->collation()
->comment()
->default()
->first()
->from()
->nullable()
->storedAs()
->unsigned()
->useCurrent() - CURRENT_TIMESTAMP
->useCurrentOnUpdate() CURRENT_TIMESTAMP
->virtualAs()
->generatedAs()
->always()
--------------------

Написание специфичных функций
$table->json('movies')->default(new Expression('(JSON_ARRAY())'));
--------------------

Изменение столбиков
поставить composer require doctrine/dbal

Изменить столбик
Schema::table('users', function (Blueprint $table) {
  $table->string('name', 50)->change();
});
Schema::table('users', function (Blueprint $table) {
  $table->string('name', 50)->nullable()->change();
});

Переименовать столбик
Schema::table('users', function (Blueprint $table) {
  $table->renameColumn('from', 'to');
});

Удалить столбик
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn('votes');
});

Удалить несколько столбиков
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn(['votes', 'avatar', 'location']);
});

Методы работы со столбиками
dropMorphs, dropRememberToken, dropSoftDeletes, dropSoftDeletesTz, dropTimestamps, dropTimestampsTz
--------------------

Кодировка
по умолчанию utf8mb4
--------------------

Создать индекс
имена индексов создаются автоматически на основе имени таблицы и столбика

$table->string('email')->unique();
$table->unique('email');
$table->index(['account_id', 'created_at']);
$table->unique('email', 'mynameindexemail');

Методы индексов
primary, unique, index, spatialIndex

Длинна индексов
varchar по умолчанию 255

настроить в AppServiceProvider
public function boot() {
  Schema::defaultStringLength(255);
}

Переименовать индекс
$table->renameIndex('from', 'to')

Удалить индекс указав имя индекса
$table->dropPrimary('indexname');
$table->dropUnique('indexname');
$table->dropIndex('indexname');
$table->dropSpatialIndex('indexname');

Удалить индекс указав имя столбика, правильный индекс сгенерится сам
Schema::table('geo', function (Blueprint $table) {
  $table->dropIndex(['state']); - автоназвание geo_state_index
});
--------------------

Foreign key

Связь posts.user_id -> users.id

Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');
});

foreignId это алиас для unsignedBigInteger

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained();
});

constrained() автоматически найдет таблицу и столбик
можно уточнить

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained('users');
});


Action для "On Delete" и "On Update"

$table->foreignId('user_id')->constrained()->onDelete('cascade');

модификаторы столбиков
$table->foreignId('user_id')->nullable()->constrained();

Удалить внешний ключ по названию ключа
$table->dropForeign('posts_user_id_foreign');

В ограничениях внешнего ключа используется то же соглашение об именах, что и в индексах
на основе имени таблицы и столбика за которыми суффикс _foreign

Удалить внешний ключ по названию столбика, а имя ключа сгенерится автоматом
$table->dropForeign(['user_id']);

Включить и отключить ограничения внешнего ключа
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();

в SQLite по умолчанию ограничение внешнего ключа отключено
Его нужно включить в config/database.php в параметре DB_FOREIGN_KEYS = true
SQLite поддерживает внешние ключи только при создании таблицы, а не при изменении
-------------------------------------------------

SEEDING

Заполнить БД тестовыми данными
сидеры вызывают фабрики
используется Eloquent и Query Builder
зависимости разрешаются через СК

Папка сидеров
database/seeds (ver 7)
database/seeders (ver 8)

Создать сидер
php artisan make:seeder Name

public function run() {

  Query Builder
  DB::table('users')->insert([
    'name' => Str::random(10),
    'email' => Str::random(10).'@gmail.com',
    'password' => Hash::make('password'),
  ]);
  
  Eloquent
  User::factory(5)->create();
  
  factory(User::class, 50)->create()->each(function ($user) {
    $user->posts()->save(factory(Post::class)->make());
  });
  
}
--------------------

Запуск нескольких сидеров
в database/seeders/DatabaseSeeder.php

public function run() {
  $this->call([
    UserSeeder::class,
    PostSeeder::class,
    CommentSeeder::class,
  ]);
}
--------------------

Мои примеры
в database/seeders/DatabaseSeeder.php

Создать бренды
Brand::factory(5)->create();
Brand::factory()->count(5)->create();
Brand::factory()->count(5)->create(['addparam' => 1]);

Создать бренды но не сохранять
Brand::factory(5)->make();
Brand::factory()->count(5)->make();
Brand::factory()->count(5)->make(['addparam' => 1]);

Изменить аттрибуты
Brand::factory()->state(['existparam' => 1])->make();

Создать бренды и сайты и в промежуточной таблице связь "сайт-бренд"
связь N:M "brands->brand_site<-sites"
Brand::factory(5)->has(Site::factory(5))->create();

Создать категории и сайты
когда связь 1:M "categories->sites"
Category::factory(5)->hasSites(5)->create();
Category::factory(5)->hasSites(5, ['addparam' => 1])->create();
Category::factory(5)->has(Site::factory()->count(5))->create();
Category::factory(5)->has(Site::factory()->count(5), 'sites')->create();

Создать сайты и категории
Site::factory()->count(5)->for(Category::factory())->create();
Site::factory()->count(5)->forCategory()->create();

Создать юзеров, сайты, и отзывы
User::factory()->has(Site::factory()->count(5))->create();
--------------------

Обновить автозагрузчик после появления новых классов
composer dump-autoload

Запустить все сидеры
php artisan db:seed

Запустить 1 сидер
php artisan db:seed --class=Brand

Запустить без дополнительного подтверждения
php artisan db:seed --force
-------------------------------------------------