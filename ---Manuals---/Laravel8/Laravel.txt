PHPSTORM PLUGINS
PROLOGUE -> API DOCUMENTATION

GETTING STARTED -> INSTALLATION
GETTING STARTED -> CONFIGURATION
GETTING STARTED -> DIRECTORY STRUCTURE
GETTING STARTED -> HOMESTEAD
GETTING STARTED -> VALET
GETTING STARTED -> DEPLOYMENT

ARCHITECTURE CONCEPTS -> REQUEST LIFECYCLE
ARCHITECTURE CONCEPTS -> SERVICE CONTAINER
ARCHITECTURE CONCEPTS -> SERVICE PROVIDERS
ARCHITECTURE CONCEPTS -> FACADES
ARCHITECTURE CONCEPTS -> CONTRACTS

THE BASICS -> ROUTING
THE BASICS -> MIDDLEWARE
THE BASICS -> CSRF PROTECTION
THE BASICS -> CONTROLLERS
THE BASICS -> HTTP REQUESTS
THE BASICS -> HTTP RESPONSES
THE BASICS -> VIEWS
THE BASICS -> URL GENERATION
THE BASICS -> HTTP SESSION
THE BASICS -> VALIDATION
THE BASICS -> ERROR HANDLING
THE BASICS -> LOGGING

FRONTEND -> BLADE TEMPLATES
FRONTEND -> LOCALIZATION
FRONTEND -> SCAFFOLDING
FRONTEND -> COMPILING ASSETS

SECURITY -> AUTHENTICATION
SECURITY -> AUTHORIZATION
SECURITY -> EMAIL VERIFICATION
SECURITY -> ENCRYPTION
SECURITY -> HASHING
SECURITY -> RESETTING PASSWORDS

DIGGING DEEPER -> ARTISAN CONSOLE
DIGGING DEEPER -> BROADCASTING
WEBSOCKETS
DIGGING DEEPER -> CACHE
DIGGING DEEPER -> COLLECTIONS
DIGGING DEEPER -> EVENTS
DIGGING DEEPER -> FILE STORAGE
DIGGING DEEPER -> HELPERS
DIGGING DEEPER -> HTTP CLIENT
DIGGING DEEPER -> MAIL
DIGGING DEEPER -> NOTIFICATIONS
DIGGING DEEPER -> PACKAGE DEVELOPMENT
DIGGING DEEPER -> QUEUES
DIGGING DEEPER -> TASK SCHEDULING

DATABASE -> REDIS
ОБНОВЛЕНИЕ LARAVEL 7 -> 8
COMPOSER.JSON
PACKAGE.JSON
ЭКСПОРТ ИЗ MYSQL WORKBENCH В LARAVEL MIGRATION
НЕЙМИНГ
ЛУЧШИЕ ПРАКТИКИ
КОРОТКИЙ СИНТАКСИС
КОМАНДЫ ARTISAN
-------------------------------------------------

PHPSTORM PLUGINS

https://plugins.jetbrains.com/plugin/7532-laravel
раскрашивает папки, автодополнение кода
Settings -> Languages & Frameworks -> PHP -> Laravel

https://plugins.jetbrains.com/plugin/14957-laravel-tinker
писать и исполнять код в отдельном файле как как strach в phpstorm

https://plugins.jetbrains.com/plugin/9525--env-files-support
подсветка в файлах .env и автодополнение в остальных местах

https://github.com/barryvdh/laravel-ide-helper
генерация PHPDoc, подсказок для автодополнения кода

https://github.com/barryvdh/laravel-debugbar
панель отладки ошибок. аналог ignition
-------------------------------------------------

PROLOGUE -> API DOCUMENTATION

https://laravel.com/api/8.x/
-------------------------------------------------

GETTING STARTED -> INSTALLATION

Homestead
Виртуальная машина для локальной разработки

Расширения PHP
BCMath, Ctype, Fileinfo, JSON, Mbstring, OpenSSL, PDO, Tokenizer, XML
-------------------------

1. Инсталлер Laravel Installer поставить глобально
php composer.phar global require laravel/installer

это установит зависимости в C:/Users/u/AppData/Roaming/Composer


2. Composer поставить локально в проект
PhpStorm - Tools - Composer - Init Composer

это установит composer.phar в /


3. Проект поставить локально
php composer.phar create-project --prefer-dist laravel/laravel /full/path/myproject

это установит зависимости из composer.json в /vendor

и сгенерит Application Key командой
php artisan key:generate

Запустить локальный сервер разработки
php artisan serve

Урл проекта
http://127.0.0.1:8000


4. NodeJS поставить глобально

npm install

это установит зависимости из package.json в /node_modules
-------------------------

Настройки Webroot хоста на папку /public

1. OpenServer - Настройки - Домены
прописать что домен смотрит на папку /public

2. создать в корне .htaccess
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule (.*) public/$1
</IfModule>
-------------------------

Сделать папки доступными для записи
storage, bootstrap/cache

Настроить timezone и locale
config/app.php

Application Key
Ключи стоят если ставить через Laravel installer или Composer
Ставятся командой php artisan key:generate
Переименовать .env.example в .env и вбить ключ руками
Ключ нужен для шифрования sessions и encrypted data

Убрать index.php в урлах в public/.htaccess
уже стоит. в мане пример
-------------------------------------------------

GETTING STARTED -> CONFIGURATION

После работы с конфигами сбрасывать кеш
php artisan config:clear
--------------------

Переменные среды

хелпер env()
строка с пробелами 'в кавычках'
все переменные загружаются в $_ENV

Конфиг
.env

Конфиг для тестов
/.env.testing

Типы
string, true, false, empty, null

Получить
env('VARNAME', 'default');

Определить
if (App::environment() == 'local') {}
if (App::environment('local')) {}
if (App::environment(['local', 'staging'])) {}

Скрыть из дебага
в config/app.php
'debug_hide' => [
  '_ENV' => ['VARNAME1', 'VARNAME2'],
  '_SERVER' => ['VARNAME1', 'VARNAME2'],
  '_POST' => ['VARNAME1', 'VARNAME2'],
];
--------------------

Конфиги

хелпер config()

Папка конфигов
/config

Получить
config('file.key', 'default');

Установить
config(['file.key' => 'newvalue']);

Создать файл кеша
в bootstrap/cache/config.php
php artisan config:cache
--------------------

Выключить приложение

php artisan down
php artisan down --message='Upgrading...' --retry=60
php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16

Включить приложение
php artisan up

Шаблон заглушки
resources/views/errors/503.blade.php

Очереди задач (Queues) будут выключены
Envoyer - продвинутая выключалка приложения
-------------------------------------------------

GETTING STARTED -> DIRECTORY STRUCTURE

Папка Root

App       код приложения
Bootstrap начальная загрузка app.php, папка cache кешей
Config    конфиги
Database  миграции, посевы, sql базы
Public    главный index.php, assets, скомпилированные файлы js, css, картинки
Resources файлы js, css, less, sass, вьюхи, шрифты
Routes    роуты web.php, api.php, console.php, channels.php
Storage   скомпилированные вьюхи, файлы сессий, кешей, логи, сгенерированные файлы, картинки
Tests     тесты PHPUnit
Vendor    зависимости Composer


Папка App

Broadcasting  вещание
Console       API консольных Artisan команд, задач по расписанию
Events        события
Exceptions    исключения
Http          API для веб контроллеров, мидлваре, обработка запросов
Jobs          задачи в очереди
Listeners     обработка событий
Mail          почта
Notifications уведомления
Policies      политики
Providers     СП
Rules         валидация

Главный конфиг
.env

Зависимости composer
composer.json

Правила webpack
webpack.mix.js
-------------------------------------------------

GETTING STARTED -> HOMESTEAD

Vagrant + VirtualBox

Для Windows
в BIOS включить hardware virtualization (VT-x)

Состав
Ubuntu, Git, Nginx, PHP, MySQL, PostgreSQL, Redis, Memcached, Node, MariaDB, Sqlite3, Composer, Bower, Grunt, Gulp, Xdebug, Apache, Elasticsearch, Gearman, RabbitMQ, Neo4j, Cassandra, MongoDB, Ngrok

Установка как Vagrant box
vagrant box add laravel/homestead
или
vagrant init laravel/homestead
vagrant up

Установка из репозитария
git clone https://github.com/laravel/homestead.git ~/Homestead
bash init.sh/init.bat
это создаст homestead.yaml


Настройка homestead.yaml
После изменения, применить
vagrant reload --provision
или
vagrant provision

провайдер
provider: virtualbox

монтируем проекты
folders:

  папка на компе
  - map: C:/Users/project1
  
  папка внутри образа
  to: /home/project1

настраиваем nginx
sites:

  - map: domain.loc
  to: /home/project1/public
  
  php: '7.4' версия php

включить/выключить сервисы
services:

    - enabled:
        - 'postgresql@12-main'

    - disabled:
        - 'mysql'

поставить дополнительное ПО
- cassandra: true
- gearman: true
- mysql8: true

делать бекапы БД при выключении
backup: true

включить cron
schedule: true


Добавить хост C:/Windows/System32/drivers/etc/hosts
192.168.10.10 domain.loc

Прописать cron в /etc/cron.d

Включение/выключение Vargant
vagrant up
vagrant destroy

Установка Homestead через Composer
composer require laravel/homestead --dev
vendor\\bin\\homestead make

Настройка Mailhog для локальной отправки писем

Расшарить проект клиенту
vagrant ssh
share domain.loc

Установить версию PHP для CLI
php74

Отладка xDebug
Закладки https://www.jetbrains.com/phpstorm/marklets
Настройки /etc/php/7.x/fpm/conf.d/20-xdebug.ini

Профилирование Blackfire

Профилирование XHGui
sites:
  xhgui: 'true'


Обновление Homestead
vagrant destroy
git fetch
git pull origin release
vagrant box update
bash init.sh/init.bat
vagrant up
-------------------------------------------------

GETTING STARTED -> VALET

Виртуальная машина для Homebrew и MacOs
-------------------------------------------------

GETTING STARTED -> DEPLOYMENT

Выкладка в продакшен

1. Настроить Nginx как в мане

2. Оптимизация автозагрузки composer
composer.lock положить в гит
composer install --optimize-autoloader --no-dev

3. Создать файл кеша всех конфигов
bootstrap/cache/config.php

php artisan config:cache

4. Создать файл кеша всех роутов
bootstrap/cache/routes.php

php artisan route:cache

5. Скомпилировать все blade шаблоны
storage/framework/views

php artisan view:cache
-------------------------------------------------

ARCHITECTURE CONCEPTS -> REQUEST LIFECYCLE

1. Точка входа public/index.php
в public/index.php загружается автозагрузчик сomposer
в bootstrap/app.php создается инстанс приложения

2. Запрос передаётся в HTTP Kernel или Console Kernel
$bootstrappers запускается до обработки запроса
в bootstrappers определяется обработка ошибок, логи, среда выполнения, список МВ, через которые проходит запрос
Метод handle принимает Request (HTTP запросы) и отдаёт Response (HTTP ответы)

3. Загрузка СП
список в config/app.php в $providers
у СП сначала вызывается метод register, а после регистрации всех СП, вызывается метод boot
СП отвечают за загрузку всех компонентов фреймворка database, queue, validation, routing

4. Request передаётся на роут
роут отправляет Request на другой роут, или на контроллер, запускает МВ роута
-------------------------------------------------

ARCHITECTURE CONCEPTS -> SERVICE CONTAINER

Сервис контейнер (СК) - это хранилище, инструмент для внедрения зависимостей
Способ подтянуть другие классы для использования
СК реализует PSR-11

В контроллере UserController, в конструкторе, в СК, внедряем СП UserRepository, который работает с БД.

class UserController extends Controller {

  public function __construct(UserRepository $users) {
    $this->users = $users;
  }

  public function show($id) {
    $user = $this->users->find($id);
  }

}

Виды привязок СП к СК


Простая привязка

$this->app->bind('HelpSpot\API', function ($app) {
  return new \HelpSpot\API($app->make('HttpClient'));
});

$this->app - СК
в bind() передаём класс или интерфейс
в make() получим объект класса HttpClient


Привязка как синглтон 1 раз

$this->app->singleton('HelpSpot\API', function ($app) {
  return new \HelpSpot\API($app->make('HttpClient'));
});


Привязка существующего объекта

$api = new \HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\API', $api);


Привязка интерфейса и реализации

$this->app->bind(
  'App\Contracts\EventPusher', интерфейс EventPusher
  'App\Services\RedisEventPusher' реализация RedisEventPusher
);


Контекстная привязка на лету. 2 класса, 1 интерфейс, 2 реализации.

$this->app->when(PhotoController::class)
  ->needs(Filesystem::class)
  ->give(function () {
    return Storage::disk('local');
});

$this->app->when([VideoController::class, UploadController::class])
  ->needs(Filesystem::class)
  ->give(function () {
    return Storage::disk('s3');
});


Привязка примитивов

$this->app->when('App\Http\Controllers\UserController')
  ->needs('$variableName')
  ->give($value);


Привязка массива объектов

$this->app->when(ReportAggregator::class)
  ->needs('$reports')
  ->giveTagged('reports');


Привязка типизированных объектов

$this->app->when(Firewall::class)
  ->needs(Filter::class)
  ->give(function ($app) {
    return [
      $app->make(NullFilter::class),
      $app->make(ProfanityFilter::class),
      $app->make(TooLongFilter::class),
      ];
});

$this->app->when(Firewall::class)
  ->needs(Filter::class)
  ->give([
    NullFilter::class,
    ProfanityFilter::class,
    TooLongFilter::class,
]);


Вариативная зависимость

$this->app->when(ReportAggregator::class)
  ->needs(Report::class)
  ->giveTagged('reports');


Теги и категории для подмножеств связывания

Регистрация
$this->app->bind('SpeedReport', function () {});
$this->app->bind('MemoryReport', function () {});

Помечаем тегом
$this->app->tag(['SpeedReport', 'MemoryReport'], 'reports');

Привязываем пачку
$this->app->bind('ReportAggregator', function ($app) {
  return new ReportAggregator($app->tagged('reports'));
});

Расширенные привязки. Когда служба уже привязана, но требует изменения на лету.

$this->app->extend(Service::class, function ($service, $app) {
  return new DecoratedService($service);
});

Разрешение и использование класса вне СК
$api = $this->app->make('HelpSpot\API');
или
$api = resolve('HelpSpot\API');
$api = $this->app->makeWith('HelpSpot\API', ['id' => 1]);

Автоматическое внедрение
В конструктор класса таким образом можно внедрять controllers, event listeners, middleware.

События СК
Генерируются при каждом разрешении объекта. Разрешаемый объект передается в калбек, там его можно изменить.

Прослушать так

$this->app->resolving(function ($object, $app) {резолвинг объекта любого типа});
$this->app->resolving(\HelpSpot\API::class, function ($api, $app) {резолвинг объекта 'HelpSpot\API'});
-------------------------------------------------

ARCHITECTURE CONCEPTS -> SERVICE PROVIDERS

Сервис провайдеры (СП) - поставщики услуг
загружаются по требованию

Регистрация СП
это добавление в $providers

Папка СП
config/app.php $providers

Создать СП
php artisan make:provider NameServiceProvider

Метод register
только привязываем что-то к СК
Не пишем роуты, прослушиватели событий итд

в СП только регистрации привязки к СК
В любом методе есть доступ к СК через $app
В массивы $bindings и $singletons сложить привязки для регистрации

Метод boot
Метод вызывается после регистрации всех СП
в этом методе есть доступ ко всем СП
тут можно указать зависимости, и СК автоматических их загрузит

Обычные СП
расширяют Support\ServiceProvider

Отложенные СП
расширяют Contracts\Support\DeferrableProvider
имеют метод provides который возвращает массив СК
-------------------------------------------------

ARCHITECTURE CONCEPTS -> FACADES

Фасад (Ф) - статический интерфейс к классам в СК
дают краткий синтаксис

Фасады и зависимости

Фасады кратки, удобны, не требуется инжектить
Опасность фасадов в разрастании размера ответственности

Зависимости требуется инжектить
Зависимости утолщают конструктор и дают визуальную обратную связь

Фасады и хелперы
Многие хелперы выполняют теже функции что и Ф
между ними нет разницы

View::make('profile'); Ф
view('profile'); хелпер

Все фасады (46 шт)
https://laravel.com/docs/7.x/facades#facade-class-reference
-------------------------------------------------

ARCHITECTURE CONCEPTS -> CONTRACTS

Контракты (К) - это набор интерфейсов, которые определяют набор СП
каждый К имеет реализацию

К очередей Contracts\Queue\Queue
К почты Contracts\Mail\Mailer

К и Ф

Фасады и хелперы дают использовать сервисы без разрешения из СК

Фасады не нужно декларировать в конструкторе
К позволяют определять явные зависимости в конструкторе

Каждый Фасад имеет эквивалентный К
К и Фасад почти не отличаются

Репоз контрактов
https://github.com/illuminate/contracts

Все контракты (79 шт)
https://laravel.com/docs/7.x/contracts#contract-reference
-------------------------------------------------

THE BASICS -> ROUTING

Все роуты в группе RouteServiceProvider
Все роуты с префиксом /api обрабатываются автоматически
Внутри роута не размещать логику

Папка роутов
/routes

web.php
роуты для веба, МВ группа 'web'

api.php
роуты для api, без состояния, МВ группа 'api'
--------------------

Роуты

GET    | backend/brands              | backend.brands.index   | BrandController@index   | список ресурсов
GET    | backend/brands/create       | backend.brands.create  | BrandController@create  | вывод формы создания ресурса
POST   | backend/brands              | backend.brands.store   | BrandController@store   | сабмит формы создания ресурса
GET    | backend/brands/{brand}/edit | backend.brands.edit    | BrandController@edit    | вывод формы редактирования ресурса
PUT    | backend/brands/{brand}      | backend.brands.update  | BrandController@update  | сабмит формы редактирования ресурса
GET    | backend/brands/{brand}      | backend.brands.show    | BrandController@show    | показать ресурс
DELETE | backend/brands/{brand}      | backend.brands.destroy | BrandController@destroy | удалить ресурс

Контроллер

список ресурсов
public function index() {}

вывод формы создания ресурса
public function create() {}

сабмит формы создания ресурса
public function store(Request $request) {}

вывод формы редактирования ресурса
public function edit($id) {}

сабмит формы редактирования ресурса
public function update(Request $request, $id) {}

показать ресурс
public function show($id) {}

удалить ресурс
public function destroy($id) {}
--------------------

HTTP методы (глаголы verb)

Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);
--------------------

Создать роут

Route::get('foo', function () {});
http://domain.loc/foo

Route::get('/user', 'UserController@index');
http://domain.loc/user

Роут на несколько HTTP методов
Route::match(['get', 'post'], '/', function () {});

Роут на любой HTTP метод
Route::any('/', function () {});


Роуты редиректов

по умолчанию код 302
Route::redirect('/here', '/there');

указать свой код
Route::redirect('/here', '/there', 301);

всегда код 301
Route::permanentRedirect('/here', '/there');

Роуты возвращающие вьюху
Route::view('/url', 'viewname');
Route::view('/url', 'viewname', ['param' => 'value']);
Route::view('/url', 'viewname')->with('param', 'value'));


Параметры роутов

Route::get('user/{id}', function ($id) {});

Route::get('user/{id1}/{id2}', function ($id1, $id2) {});

Необязательные параметры
Route::get('user/{id?}', function ($id = null) {});


Ограничения параметров регулярками

Route::get('user/{id}/{name}', function ($id, $name) {})
  ->where('id', '[A-Za-z]+');
  ->where('id', '[0-9]+');
  ->where(['id' => '[0-9]+', 'name' => '[A-Za-z]+']);
  
Ограничения параметров регулярками, на глобальном уровне

в RouteServiceProvider

public function boot() {
  Route::pattern('id', '[0-9]+');
  Route::pattern('name', '[A-Za-z]+');
  parent::boot();
}

Позволить косую черту / в роутах
Работает только для последнего сегмента

Route::get('user/{id}', function ($id) {})
  ->where('id', '.*');


Именованные роуты

Route::get('user/profile', function () {})
  ->name('profile');

Урлы и редиректы на именованные роуты

{{route('profile')}}
{{route('profile', $id)}}

<form action='{{route('profile')}}'>
<form action='{{route('profile', $id)}}'>

route('profile');
route('profile', ['id' => 1]);

route('profile', ['id' => 1, 'photos' => 'yes']);
/user/1/profile?photos=yes

redirect()->route('profile');


Группировка роутов
для задания им одного набора МВ или неймспейсов

Метод Route::group

МВ для группы роутов
Route::middleware(['first', 'second'])->group(function () {
  Route::get('/', function () {});
  Route::get('user/profile', function () {});
});

Неймспейсы для группы контроллеров
по умолчанию у контроллеров пространство App\Http\Controllers

Route::namespace('Admin')->group(function () {});

Роуты субдоменов
Route::domain('{account}.myapp.com')->group(function () {
  Route::get('user/{id}', function ($account, $id) {});
});


Префиксы роутов
Например для роутов админки /admin/users, /admin/models

Route::prefix('admin')->group(function () {
  Route::get('users', function () {});
  Route::get('models', function () {});
});

Префиксы роутов /admin.users, /admin.models

Route::name('admin.')->group(function () {
  Route::get('users', function () {})->name('users');
  Route::get('models', function () {})->name('models');
});

Привязка роута и Eloquent модели

неявная привязка (по столбику ID). если модель не найдена то вернет 404 HTTP
Route::get('api/users/{user}', function (App\User $user) {$user->email;});

явная привязка по столбику slug
Route::get('api/posts/{post:slug}', function (App\Post $post) {$post;});

для связанных моделей
Route::get('api/users/{user}/posts/{post:slug}', function (User $user, Post $post) {$post;});

Задать столбец по умолчанию, отличный от ID
В модели Eloquent написать:

public function getRouteKeyName() {
  return 'slug';
}

Явная привязка роута и Eloquent модели

в RouteServiceProvider
public function boot() {
  parent::boot();
  Route::model('user', App\User::class);
}

явная привязка по столбику ID. если модель не найдена то вернет 404 HTTP
Route::get('profile/{user}', function (App\User $user) {$user->email;});

Настройка логики разрешения для привязки
public function boot() {
  parent::boot();
  Route::bind('user', function ($value) {
    return App\User::where('name', $value)->firstOrFail();
  });
}

ИЛИ

Изменить метод resolveRouteBinding в Eloquent модели
public function resolveRouteBinding($value, $field = null) {
  return $this->where('name', $value)->firstOrFail();
}

Резервные роуты
Указать роут, когда не совпал ни один роут
обычно это 404
его написать в конце

Route::fallback(function () {});


Лимиты скорости на роутах
МВ throttle для ограничения скорости
назначить на роут или группу роутов

Route::middleware('auth:api', 'throttle:60,1')->group(function () {
  Route::get('/user', function () {});
});

60 - колво запросов
1 - минута

Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () {
  Route::get('/user', function () {});
});

rate_limit - атрибут в модели User в БД

Route::middleware('throttle:10|60,1')->group(function () {});

10 - для гостя
60 - для авторизованного

Route::middleware('auth:api', 'throttle:10|rate_limit,1')->group(function () {
  Route::get('/user', function () {});
});

10 - для гостя
rate_limit - для авторизованного

Для разных сегментов урла (default и deletes) разные ограничения

Route::middleware('auth:api')->group(function () {

  Route::middleware('throttle:60,1,default')->group(function () {
    Route::get('/servers', function () {});
  });

  Route::middleware('throttle:60,1,deletes')->group(function () {
    Route::delete('/servers/{id}', function () {});
  });
});


HTML форма
не имеет методов PUT, PATCH, DELETE
когда задаём роуты с методами PUT, PATCH, DELETE, то добавить скрытое поле _method

<form>
  <input type='hidden' name='_method' value='PUT'>
  ИЛИ
  @method('PUT')
</form>


Получить текущий роут
$route = Route::current();
$name = Route::currentRouteName();
$action = Route::currentRouteAction();
if ($request->route()->named('profile')) {}

Cross-Origin Resource Sharing (CORS)
-------------------------------------------------

THE BASICS -> MIDDLEWARE

Мидлваре (МВ) - это механизм фильтрации HTTP запросов
Например аутентификации юзеров, чтобы пропустить дальше или редирект на страницу логина
МВ как серия слоёв через которые проходит HTTP запрос, до попадания в приложение
МВ есть для CORS, логирования
МВ разрешаются через СК, зависимости писать в конструкторе МВ

Папка
app/Http/Middleware

Создать МВ
php artisan make:middleware NameMiddleware

главный метод
public function handle($request, Closure $next) {

  редирект
  if (условие) {
    return redirect('home');
  }

  пропуск далее в приложение
  $next($request);

  }
}

Выполнение МВ до или после запроса

public function handle($request, Closure $next) {
  тут действия МВ будут выполняться ДО обработки запроса
  return $next($request);
}

public function handle($request, Closure $next) {
  $response = $next($request);
  тут действия МВ будут выполняться ПОСЛЕ обработки запроса
  return $response;
}

Глобальный список МВ
app/Http/Kernel.php в $middleware


МВ только для 1 роута

сначала положить сюда
app/Http/Kernel.php в $routeMiddleware
'namemiddleware' => '\App\Http\Middleware\NameMiddleware'

потом просоединить к роуту
Route::get('/', function () {})
  ->middleware('namemiddleware');
  
Несколько МВ к роуту

Route::get('/', function () {})
  ->middleware(['namemiddleware', 'namemiddleware2']);

Можно не ключ а имя класса
Route::get('/', function () {})
  ->middleware(\App\Http\Middleware\NameMiddleware::class);

Назначим МВ группе роутов, но отменим для одного роута из группы
Route::middleware([CheckAge::class])->group(function () {
  Route::get('/', function () {});
  Route::get('admin/profile', function () {})->withoutMiddleware([CheckAge::class]);
});

Можно положить несколько МВ в группу
app/Http/Kernel.php в  $middlewareGroups

в СП RouteServiceProvider группы web и api уже присоединены к роутам которые будут в файлах web.php и api.php

Группы МВ присоединяются к роутам также как отдельные МВ

Сортировка порядка выполнения МВ
app/Http/Kernel.php в $middlewarePriority

В МВ можно передать параметры. например чтобы проверить роль юзера

public function handle($request, Closure $next, $role) {}

и передать этот параметр в роут
Route::get('/', function () {})
  ->middleware('namemiddleware:roleName, roleStatus');

Оконечное МВ
МВ которое должно выполнить работу, после посылки HTTP браузеру.
Сервер должен исполнять FastCGI. Добавить МВ в роут или глобально в массив app/Http/Kernel.php.

public function terminate($request, $response) {
  тут код
}

При вызове terminate, будет новый инстанс МВ из СК. Если хотим этот же - регистрируем МВ в СК как singleton в методе register в AppServiceProvider

public function register() {
  $this->app->singleton(TerminableMiddleware::class);
}
-------------------------------------------------

THE BASICS -> CSRF PROTECTION

CSRF - это Cross Site Request Forgery, подделка межсайтового запроса.
Когда запросы отправляются из левого места, а не из авторизованной админки.
CSRF токен автоматически генерируется на основе сессий и кладётся в куку и сессию.
МВ VerifyCsrfToken входит в группу 'web', проверяет токен.
CSRF отключается на тестах.

HTML форма

<form>
  @csrf
</form>

в форме будет вставлено
<input type="hidden" name="_token" value="aznbfeYbmUCKfO...">

в куке XSRF-TOKEN будет
eyJpdiI6InBjOWdxYTI...


JavaScript приложения
Яваскрипт HTTP-библиотека должна аттачить токен к запросам.
Axios в resources/js/bootstrap.js, автоматически отправляет заголовок X-XSRF-TOKEN из куки с именем XSRF-TOKEN.

Исключить урлы из проверки CSRF
Обычно такие роуты исключаются из МВ группы 'web' в RouteServiceProvider в routes/web.php
Можно исключить, добавив такие роуты в $except в МВ VerifyCsrfToken.

protected $except = [
  'stripe/*',
  'http://example.com/foo/bar',
  'http://example.com/foo/*'
];

X-CSRF-TOKEN
Дополнительная защита
<meta name='csrf-token' content='{{csrf_token()}}'>

При использовании jQuery для AJAX запросов, руками добавлять заголовок
$.ajaxSetup({
  headers: {
    'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content');
  }
});

X-XSRF-TOKEN
CSRF токен сохраняется в куке XSRF-TOKEN.
Axios и Angular автоматически помещают своё значение в заголовок X-XSRF-TOKEN.
-------------------------------------------------

THE BASICS -> CONTROLLERS

Логику писать в контроллерах
контроллеры это группа связанных запросов
если нет extends Controller, то нет методов МВ, validate, dispatch

Папка контроллеров
app/Http/Controllers

Неймспейсы

Если контроллер такой
App\Http\Controllers\Photos\AdminController

То роут такой
Route::get('foo', 'Photos\AdminController@method');


Контроллер
class UserController extends Controller {
  public function show($id) {}
}

Роут
Route::get('user/{id}', 'UserController@show');


Контроллер с 1 методом
class UserController extends Controller {
  public function __invoke($id) {}
}

Роут
Route::get('user/{id}', 'UserController');


Создать контроллер с 1 методом
php artisan make:controller UserController --invokable
-------------------------

МВ на Контроллер

Назначить в роуте
Route::get('profile', 'UserController@show')->middleware('auth');

Назначить в конструкторе Контроллера
это лучше

public function __construct() {
  $this->middleware('auth');
  $this->middleware('log')->only('index');
  $this->middleware('subscribed')->except('store');
}

В конструкторе можно создать МВ на лету, не создавая отдельный класс МВ
$this->middleware(function ($request, $next) {
  return $next($request);
});
-------------------------

Контроллеры с готовыми методами
index, create, store, show, edit, update, destroy

1. контроллер с привязкой к модели (использовать этот)
php artisan make:controller NameController --model=ModelName

2. ресурсный контроллер с привязкой к модели
php artisan make:controller NameController --model=ModelName --resource

оба генерят одинаковый код. в методы внедрена модель
----------

3. ресурсный контроллер

php artisan make:controller NameController --resource

в методах нет модели
-------------------------

Роуты на ресурсный контроллер
index, create, store, show, edit, update, destroy

Route::resource('websites', NameController::class);

GET|HEAD  websites                websites.index   App\Http\Controllers\NameController@index
POST      websites                websites.store   App\Http\Controllers\NameController@store
GET|HEAD  websites/create         websites.create  App\Http\Controllers\NameController@create
GET|HEAD  websites/{website}      websites.show    App\Http\Controllers\NameController@show
PUT|PATCH websites/{website}      websites.update  App\Http\Controllers\NameController@update
DELETE    websites/{website}      websites.destroy App\Http\Controllers\NameController@destroy
GET|HEAD  websites/{website}/edit websites.edit    App\Http\Controllers\NameController@edit


урлы для админки
Route::prefix('backend')->name('backend.')->group(function () {
    Route::resource('websites', NameController::class);
});
GET|HEAD  websites                backend.websites.index   App\Http\Controllers\NameController@index
-------------------------

Роуты на ресурсный контроллер. пачкой
Route::resources([
  'photos' => 'PhotoController',
  'posts' => 'PostController'
]);

Роуты на ресурсный контроллер. выбрать или исключить

Route::resource('photos', 'PhotoController')
  ->only(['index', 'show']);

Route::resource('photos', 'PhotoController')
  ->except(['create', 'store']);


Роуты для ресурсных Контроллеров для API
не будет роутов create и edit

Route::apiResource('photos', 'PhotoController');

Роуты для ресурсных Контроллеров для API. пачкой
Route::apiResources([
  'photos' => 'PhotoController',
  'posts' => 'PostController'
]);
--------------------

Ресурсный контроллер для API
не будет роутов create и edit

php artisan make:controller api/PhotoController --api


Роуты для вложенных ресурсов
фото + комменты

/photos/{photo}/comments/{comment}
Route::resource('photos.comments', 'PhotoCommentController');

Роуты для ресурсов вложенных неглубоко
В урле не нужен ID родителя а только ID потомка

Route::resource('photos.comments', 'CommentController')
  ->shallow();
  
Будут созданы методы index, create, store, show, edit, update, destroy

Именованные роуты для ресурсных Контроллеров

Route::resource('photos', 'PhotoController')
  ->names(['create' => 'photos.build']);

Именованные роуты с параметрами для ресурсных Контроллеров

/users/{admin_user}
Route::resource('users', 'AdminUserController')
  ->parameters(['users' => 'admin_user']);

Область видимости роутов для ресурсных Контроллеров

Route::resource('users.posts', PostsController::class)
  ->scoped();
  
Route::resource('users.posts', PostsController::class)
  ->scoped(['post' => 'slug']);

Локализация ресурсных урлов с English на другой язык
методы index, create, store, show, edit, update, destroy

в AppServiceProvider

public function boot() {
  Route::resourceVerbs([
    'create' => 'crear',
    'edit' => 'editar'
  ]);
}

Регаем роут
Route::resource('fotos', 'PhotoController');

Это даст урлы
/fotos/crear
/fotos/{foto}/editar

Дополнительные контроллеры ресурсов
Когда хотим добавить еще роуты на ресурсный контроллер кроме роутов по умолчанию

Их лучше объявлять до вызова Route::resource
В таком порядке:

Route::get('photos/popular', 'PhotoController@method');
Route::resource('photos', 'PhotoController');

Внедрение зависимостей в Контроллер

В конструктор
СК используется для разрешения всех Контроллеров
любые зависимости можно в конструктор

public function __construct(UserRepository $users) {
  $this->users = $users;
}

В другие методы
public function store(Request $request, $id) {
  $name = $request->name;
}

Роут
Route::put('user/{id}', 'UserController@update');

Кеширование роутов
Роуты на основе замыканий (Closure) не кешируются
Все роуты конвертить в классы
Кеширование даёт прибавку в скорости в 100 раз

Создать файл кеша всех роутов
в bootstrap/cache/routes.php

php artisan route:cache

Удалить файл кеша всех роутов
php artisan route:clear
-------------------------------------------------

THE BASICS -> HTTP REQUESTS

Объект запроса

Получить объект в контроллере
class UserController extends Controller {
  public function store(Request $request) {}
}

Получить объект в роуте
Route::get('/', function (Request $request) {});

Контроллер и Роут с параметром
Route::put('user/{id}', 'UserController@update');
public function update(Request $request, $id) {}

Путь
$request->path();

Проверка на путь (паттерн * на совпадение)
if ($request->is('admin/*')) {}

Урл
$request->url(); без query string
$request->fullUrl(); с query string

Метод
$request->method();
if ($request->isMethod('post')) {}
-------------------------

Запросы и Ответы стандарта PSR-7

Поставить либы
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7

Получить запрос
use Psr\Http\Message\ServerRequestInterface;
Route::get('/', function (ServerRequestInterface $request) {});
-------------------------

Обрезка и нормализация ввода

МВ TrimStrings и ConvertEmptyStringsToNull стоят в глобальном стеке
Обрезают пробелы строк, пустые строки выставляют в NULL
Можно убрать это, закоментив классы в App\Http\Kernel в $middleware

Все данные
$request->request;
$request->all();
$request->input();
request();

Одно поле
неважно get, post, query string

$request->input('name'); 
$request->input('name', 'defaultvalue');

request('name');
request('name', 'defaultvalue');

$request->name; сначала ищет в теле запроса, потом в параметрах роута


Доступ к массивам
$request->input('products.0.name');
$request->input('products.*.name');

Параметры из Query String
$request->query('name');
$request->query('name', 'defaultvalue');
$request->query();

Получить JSON
Для запросов Content-Type application/json
$request->input('user.name');

Получить boolean на чекбоксы и радиобуттоны
$request->boolean('archived');
вернёт true для 1, "1", true, "true", "on", "yes"

Сабмит чекбокса в базу
<input name='checkboxName' type='checkbox' value='1'>
'checkboxName' => $request->has('checkboxName');
чекбокс стоит - встанет 1. чекбокс не стоит - встанет 0

Получить части данных
$request->only(['username', 'password']);
$request->only('username', 'password');
$request->except(['credit_card']);
$request->except('credit_card');

Проверка на наличие
if ($request->has('name')) {}
if ($request->has(['name', 'email'])) {} должны быть все
if ($request->hasAny(['name', 'email'])) {} должен быть любой из
if ($request->filled('name')) {} есть и не равно пустоте
if ($request->missing('name')) {} нет

Старый ввод в форму

ввод в форму сохраняется в сессию после сабмита формы
чтобы опять заполнить поля формы когда на форме ошибки

Это автоматический механизм, если используем встроенную валидацию Validation

Сохранение текущего ввода

$request->flash();
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');

Сохранение текущего ввода и редирект

redirect('form')->withInput();
redirect('form')->withInput(
  $request->except('password')
);

Получить старый ввод
$request->old('username');

Вставка старого ввода на форму
хелпер old()

<input name='name' value='{{old('name')}}'>
<input name='name' value='{{$data->name || old('name', 0) == 1 ? 'checked'}}'>

Получить куки
куки зашифрованы и подписаны кодом аутентификации
их не может изменить клиент

$request->cookie('name');
Cookie::get('name'); используя Ф

Добавить куки
response('HelloWorld')->cookie('name', 'value', $minutes);
response('HelloWorld')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);

Добавить куки в очередь
Куки будут прикреплены к Ответу перед отправкой в ​​браузер.
Cookie::queue(Cookie::make('name', 'value', $minutes));
Cookie::queue('name', 'value', $minutes);

Создание куки
$cookie = cookie('name', 'value', $minutes);
response('Hello World')->cookie($cookie); прикрепляем к ответу

Удалить истёкшую куку
Cookie::queue(Cookie::forget('name'));

Прикрепить к Ответу истёкшую куку
$cookie = Cookie::forget('name');
return response('Hello World')->withCookie($cookie);

Получить загруженные файлы
$request->file('photo');
$request->photo;

Проверка на наличие файла
if ($request->hasFile('photo')) {}

Проверка что файл корректно загружен
if ($request->file('photo')->isValid()) {}

Путь и расширение файла
$request->photo->path();
$request->photo->extension(); угадывает расширение по контенту

Сохранение загруженных файлов
Уникальное имя файла генерится автоматически.

$request->photo->store('pathtofolder'); переносит файл в папку
$request->photo->store('pathtofolder', 'dickname'); укажем диск

Задать имя файла
$request->photo->storeAs('pathtofolder', 'filename.jpg');
$request->photo->storeAs('pathtofolder', 'filename.jpg', 'dickname');

Настройка доверенных прокси для балансировщиков нагрузки типа AWS Elastic Load
МВ TrustProxies массив прокси в $proxies.
protected $proxies = ['192.168.1.1', '192.168.1.2'];
protected $headers = Request::HEADER_X_FORWARDED_AWS_ELB;

Для других балансировщиков нагрузки типа Amazon AWS где нет IP адресов
protected $proxies = '*'; доверять всем прокси
-------------------------------------------------

THE BASICS -> HTTP RESPONSES

Хелпер Response

Роуты и контроллеры возвращают Ответ в браузер
Возвращается полный инстанс Ответа Response или вьюха
Полный Response позволяет задать свои коды ответа и заголовки


Route::get('/', function () {return 'Hello World';}); строка
Route::get('/', function () {return [1, 2, 3];}); массив как json

Route::get('home', function () {

  return response('Hello World', 200)
    ->header('Content-Type', 'text/plain');

  return response($content)
    ->header('Content-Type', $type)
    ->header('X-Header-One', 'Header Value')
    ->header('X-Header-Two', 'Header Value');

  return response($content)
    ->withHeaders([
      'Content-Type' => $type,
      'X-Header-One' => 'Header Value',
      'X-Header-Two' => 'Header Value'
    ]);

});

Кеширование МВ Cache-Control
Можно кеширование сразу группы роутов.
Если задан etag, то MD5 хеш содержимого будет автоматически установлен в ETag.

Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
  Route::get('privacy', function () {});
  Route::get('terms', function () {});
});

Прикрепление кук к Ответу

response($content)
  ->cookie('name', 'value', $minutes);

response($content)
  ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly);

Прикрепление кук к Ответу, используя Фасад Cookie для установки в очередь

Cookie::queue(Cookie::make('name', 'value', $minutes));
Cookie::queue('name', 'value', $minutes);

Шифрование кук
Куки зашифрованы и подписаны соответствующим МВ.

Защиту можно отключить, добавив куку в массив в App\Http\Middleware\EncryptCookies
protected $except = ['cookie_name'];


Редиректы

return redirect('home/dashboard');

на предыдущую страницу
return back()
return back()->withInput();
return Redirect::back()

на именованный роут
return redirect()->route('login');

на именованный роут с параметром
выдаст profile/{id}
return redirect()->route('profile', ['id' => 1]);


Заполнение параметров роута моделями Eloquent
редирект на роут с ID юзера и привязкой к модели $user. выдаст profile/{id}

redirect()->route('profile', [$user]);

Указать свой столбик вместо ID
redirect()->route('profile/{id:slug}', [$user]);

В модели Eloquent написать
public function getRouteKey() {
  return $this->slug;
}

Редирект на метод контроллера
redirect()->action('HomeController@index');
redirect()->action('UserController@profile', ['id' => 1]);

для лары 8
redirect()->action([UserController::class, 'index']);

Редирект на другой домен
redirect()->away('https://www.google.com');

Редирект со старым вводом
редирект на новый урл и запись данных в сессию

Редирект с сообщением
Route::post('user/profile', function () {
  return redirect('dashboard')->with('message', 'ok');
});

Потом на другой странице вывести
@if (session('message'))
  <div class='alert alert-success'>
    {{session('message')}}
  </div>
@endif

Вернуть вьюху
Использовать хелпер View, если не нужно задавать заголовки и коды ответа.
response()->view('hello', $data, 200);

Вернуть JSON
Автоматически вернёт Ответ Content-Type application/json.
response()->json(['name' => 'Abigail', 'state' => 'CA']);

JSON метод можно комбинировать с колбеком
response()
  ->json(['name' => 'Abigail', 'state' => 'CA'])
  ->withCallback($request->input('callback'));

Скачать файл
создание Ответа который заставит браузер скачать файл

response()->download($pathToFile);
response()->download($pathToFile, $customfilename, $customheaders);
response()->download($pathToFile)->deleteFileAfterSend();

Потоковые загрузки
Отправить строковый ответ, как загружаемый ответ, без записи на диск

response()->streamDownload(function () {
  echo GitHub::api('repo')
    ->contents()
    ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');

Файловый ответ (PDF, image) без скачивания
Просто отобразит в браузере.

response()->file($pathToFile);
response()->file($pathToFile, $headers);

Макросы для Ответа
Написать макрос Ответа и аттачить его к роутам и контроллерам.

ResponseMacroServiceProvider
public function boot() {
  Response::macro('macroname1', function ($value) {
    return Response::make(strtoupper($value));
  });
}

Вызвать так
response()->macroname1('foo');
-------------------------------------------------

THE BASICS -> VIEWS

Вьюхи содержат HTML, Blade, PHP
в папке views можно не писать приставку .blade к вьюхам
в blade {{$test}} это аналог <?= $test ?>

Папка вьюх
resources/views

Хелпер View
Фасад View

Вьюха
resources/views/greeting.blade.php


переменная
{{$name}}

любой php код
{{var_dump(1)}}

все переменные
{{dd($__data)}}
		

Вывод вьюхи

Route::get('/', function () {
  return view('greeting', ['name' => 'James']);
  return View::make('greeting', ['name' => 'James']);
});

Пути до вьюх
resources/views/admin/profile.blade.php
view('admin.profile');

Проверка наличия вьюхи
if (View::exists('admin')) {}

Выбрать первую существующую вьюху из массива
view()->first(['admin1', 'admin2']);
View::first(['admin1', 'admin2']);

Передача данных во вьюху

массив
view('greetings', $dataarray);

поштучно
view('greeting')
  ->with('name1', 'Victoria1')
  ->with('name2', 'Victoria2');


Передача данных всем вьюхам

AppServiceProvider
public function boot() {
  View::share('key', 'value');
}
-------------------------

Композиторы Вьюх

Это замыкания или методы класса, которые вызываются когда рендерится вьюха
Когда нужно вставлять данные при каждом рендеринге вьюхи
Композиторы нужны когда вьюха выводится на разных роутах и контроллерах и требует данные
Композиторы разрешаются через СК, можно указать любые зависимости в конструкторе Композитора

Создать СП
php artisan make:provider NameServiceProvider

config/app.php 'providers'
\App\Providers\NameServiceProvider::class


class NameServiceProvider extends ServiceProvider {

  public function register() {}

  Композиторы
  public function boot() {

    для 1 вьюхи
    View::composer('signup', function ($view) {
      $view->with('param', 'value');
    });

    для нескольких вьюх
    View::composer(['signup', 'signin'], function ($view) {
      $view->with('param', 'value');
    });

    для всех вьюх
    View::composer('*', function ($view) {
      $view->with('param', 'value');
    });

    на основе класса
    View::composer('signup', NameComposer::class);
	View::composer(['signup', 'signin'], NameComposer::class);
  }

  
  Креаторы
  public function boot() {

    для 1 вьюхи
    View::creator('signup', function ($view) {
      $view->with('param', 'value');
    });
	
    на основе класса
    View::creator('signup', NameCreator::class);
  }
	
}


Папка композиторов
app/Http/View/Composers

Папка креаторов
app/Http/View/Creators


Создать композитор

class NameComposer {
  public function compose(View $view) {
    $view->with('param', 'value');
  }
}

Создать креатор

class NameCreator {
  public function create(View $view) {
    $view->with('param', 'value');
  }
}

Вывод во вьюхе
{{$param}}

Посмотреть все переменные во вьюхе
dd($view->getData());
-------------------------

Создатели Вьюх

Создатели выполняются после создания экземпляра вьюхи
Композиторы выполняются после отображения вьюхи

Чем они отличаются. На примере одинаковых переменных

в Контроллере переменная
в Композиторе и Создателе такая же переменная
Композитор и Создатель перезаписывают переменные в Контроллере

если в Контроллере нет переменной, то берется из Композитора или Создателя
когда переменная есть в Композиторе и Создателе, то берется из Композитора
-------------------------

Оптимизация
Blade вьюхи компилируются на лету когда происходит Запрос

Скомпилировать все blade шаблоны
storage/framework/views

php artisan view:cache

Удалить все скомпилированные blade шаблоны
php artisan view:clear
-------------------------------------------------

THE BASICS -> URL GENERATION

Генерация урлов
Хелпер Url
Фасад URL
--------------------

Мои примеры

http://400.loc/catalog?category_id=10&brand_id=12&feature_id=

Эти методы:
в контроллере вызывать как $request->
во вьюхах вызывать как Request::

Request::segments(); массив сегментов
Request::segment(1); сегмент по индексу

Request::route(); объект роута
Request::route()->named('frontend.catalog.index'); проверка что имя роута такое
Request::routeIs('frontend.catalog.index'); проверка что имя роута такое

Request::getUri(); полный урл
Request::getBaseUrl(); пусто
Request::getRequestUri(); /catalog

Request::path(); catalog
Request::is('catalog'); проверка что в урле есть это
Request::url(); http://400.loc/catalog
Request::fullUrl(); http://400.loc/catalog
Request::method(); GET

Route::current()->named('frontend.catalog.index'); true
Route::currentRouteName(); frontend.catalog.index
Route::getCurrentRoute(); объект роута

Когда нужно чтобы пункт меню подсвечивался:
- на списке
- на формах создания и редактирования

@if(Request::routeIs($route) || Request::segment(2) == explode('.', $route)[1]) active @endif
--------------------

Создать урл
$post = App\Post::find(1);
url('posts/{$post->id}');
выдаст http://domain.com/posts/1
--------------------

Текущий урл

url()->current(); без query string
url()->full(); с query string
url()->previous(); предыдущий урл

URL::current();
URL::full();
URL::previous();
--------------------

Урлы на именованные роуты
Route::get('/post/{post}', function () {})->name('post.show');
route('post.show', ['post' => 1]); http://example.com/post/1

Урлы на именованные роуты, на основе модели Eloquent
route('post.show', ['post' => $post]);

Урлы на именованные роуты, на основе модели Eloquent, с дополнительными параметрами
Route::get('/post/{p}/comment/{c}', function () {})->name('comment.show');
route('comment.show', ['p' => 1, 'c' => 3]);
http://example.com/post/1/comment/3
--------------------

Подписанные урлы с хешем на именованные роуты
URL::signedRoute('unsubscribe', ['user' => 1]);

Подписанные временые урлы с хешем на именованные роуты
URL::temporarySignedRoute(
  'unsubscribe', now()->addMinutes(30), ['user' => 1]
);

Проверка подписанных урлов
if ($request->hasValidSignature()) {}

Проверка подписанных урлов через МВ

Регистрируем МВ
$routeMiddleware = ['signed' => \Illuminate\Routing\Middleware\ValidateSignature::class];

Присоединяем к роуту
Route::post('/unsubscribe/{user}', function (Request $request) {})
  ->name('unsubscribe')
  ->middleware('signed');
--------------------

Урлы на методы контроллера
action('HomeController@index');
action([HomeController::class, 'index']);
action('UserController@profile', ['id' => 1]);

для лары 8
action([UserController::class, 'index']);
Redirect::action([UserController::class, 'index']);
--------------------

Глобальные параметры для роутов

Параметр locale укажем в МВ
public function handle($request, Closure $next) {
  URL::defaults(['locale' => $request->user()->locale]);
}

Роут
Route::get('/{locale}/posts', function () {})
  ->name('post.index');
-------------------------------------------------

THE BASICS -> HTTP SESSION

HTTP приложения не сохраняют состояние между запросами
Сессии обеспечивают это сохранение
Конфиг config/session.php
Можно свои драйверы сессий
Драйверы это хранилища сессий

file(по умолчанию) - в storage/framework/sessions
cookie - в зашифрованных куках
database - в базе
memcached
redis
array - хранятся в php массиве и не сохраняются (этот драйвер для тестирования)

Драйвер database

Таблица
Schema::create('sessions', function ($table) {
  $table->string('id')->unique();
  $table->foreignId('user_id')->nullable();
  $table->string('ip_address', 45)->nullable();
  $table->text('user_agent')->nullable();
  $table->text('payload');
  $table->integer('last_activity');
});

Запустить миграцию
php artisan session:table
php artisan migrate

Драйвер redis
composer predis/predis
В конфиге в параметре connection указать тип соединения.


Работа с сессиями через 2 метода.
Хелпер Session, объект Запроса Request. Они не отличаются.

Получить данные через Request

public function show(Request $request, $id) {

  $value = $request->session()->get('key');

  $value = $request->session()->get('key', 'defaultvalue'); если ключа нет вернет defaultvalue

  $value = $request->session()->get('key', function () {
    return 'defaultvalue'; через замыкание чтобы вернуть что-то, исходя из логики написанной тут в функции
  });

}

Получить данные через Session

Route::get('home', function () {

  $value = session('key'); получить

  $value = session('key', 'defaultvalue');

  session(['key' => 'value']); сохранить

});

Получить все данные
$request->session()->all();

Проверка наличия данных
if ($request->session()->has('users')) {} данные есть, и не NULL
if ($request->session()->exists('users')) {} ключ есть, даже если данные NULL

Сохранить в сессию
$request->session()->put('key', 'value'); Request
session(['key' => 'value']); хелпер

Сохранить массив
$request->session()->push('user.teams', 'developers');
добавит в массив user.teams значение 'developers'

Получить и удалить данные
$request->session()->pull('key', 'defaultvalue');

Сохранить в сессию до следующего запроса
$request->session()->flash('status', 'Temporary');

Сохранить в сессию для нескольких запросов
$request->session()->reflash(); пересохранит данные дальше на следующий запрос
$request->session()->keep(['username', 'email']); сохранит только определенные данные дальше на следующий запрос

Удалить данные
$request->session()->forget('key');
$request->session()->forget(['key1', 'key2']);
$request->session()->flush(); удалит всё

Пересоздать Session ID
Для предотвращения атаки session fixation.
Если используем LoginController, то пересоздание Session ID автоматически.

Пересоздать Session ID вручную
$request->session()->regenerate();

Блокировка сессии
В пределах 1 сеанса не допускать паралельной записи в сессию с разных мест.

Для драйверов atomic locks
memcached, dynamodb, redis, database.

На роуты блокировку

Route::post('/profile', function () {})->block($lockSeconds = 10, $waitSeconds = 10)

Route::post('/order', function () {})->block($lockSeconds = 10, $waitSeconds = 10)

Запросы к роутам будут строго последовательны.
$lockSeconds - максимальная длительность блокировки.
$waitSeconds - сколько секунд ждать, после попытки получить блокировку.
-------------------------------------------------

THE BASICS -> VALIDATION

Фасад Validator
Базовый класс ValidatesRequests
Метод validate в классе Http\Request

Если валидация не прошла, будет исключение и сформирован Ответ
Для html формы редирект, для AJAX ответ JSON массив


public function store(Request $request) {

  правила валидации через разделитель
  $validatedData = $request->validate([
    'title' => 'required|unique',
	'name' => 'required',
  ]);

  правила валидации массивом
  $validatedData = $request->validate([
    'title' => ['required', 'unique'],
	'name' => ['required'],
  ]);

  сохранить сообщения об ошибках в именованном пакете ошибок
  $validatedData = $request->validateWithBag('post', [
    'title' => ['required', 'unique']
  ]);

  bail остановит на первом правиле которое не прошло
  остальные не проверяются
  порядок строго как записано
  $request->validate([
    'title' => 'bail|required|unique:posts|max:255',
  ]);

  для вложенных полей
  $request->validate([
    'author.name' => 'required',
    'author.description' => 'required',
]);

  тут код после валидации
}

Вывод ошибок
Если валидация не прошла, то редирект назад и сохранение ошибок в Flash Session (FS)
Ошибки в $errors инстанса Support\MessageBag
$errors связана с вьюхами через МВ ShareErrorsFromSession, доступна в вьюхах

МВ TrimStrings и ConvertEmptyStringsToNull всегда включены в классе App\Http\Kernel

Правило nullable
publish_at может быть null или корректной датой

$request->validate([
  'publish_at' => 'nullable|date',
]);

AJAX запросы
Метод validate отдаст массив JSON с ошибками и код ответа 422

Форма Запроса

Форма запроса это отдельный класс с правилами валидации
Форма Запроса запускается ДО запуска метода Контроллера store

Если валидация не прошла, то редирект назад или массив JSON с кодом 422, сохранение ошибок во FS
-------------------------

Класс формы запроса

любые зависимости разрешается через СК
добавить Форму Запроса в метод сохранения данных в Контроллер

Создать
app/Http/Requests/BrandRequest.php

php artisan make:request BrandRequest

Правила валидации
public function rules() {
  return [
    'title' => 'required|unique'
  ];
}

BrandRequest импорить в контроллер вместо стандартного Request
public function store(BrandRequest $request) {

  тут валидация уже прошла
  
  получим валидированные данные
  $validated = $request->validated();
}

Хук after
позволяет дописать следующую проверку или добавить сообщения об ошибках
метод withValidator получает инстанс Validator со всеми методами, до валидации правил

public function withValidator($validator) {
  $validator->after(function ($validator) {
    if ($this->somethingElseIsInvalid()) {
      $validator->errors()->add('field', 'error message');
    }
  });
}
-------------------------

Аторизация Формы Запросов
логика проверки что авторизованный юзер имеет право на действия с ресурсами
или просто вернуть true

Route::post('comment/{comment}');

public function authorize() {

  получим комммент по id из роута
  $comment = Comment::find($this->route('comment'));

  если вернулся false то вернется код HTTP 403 и метод Контроллера не будет выполнен
  return $comment && $this->user()->can('update', $comment);

  тут добавить любые зависимости, ибо разрешается через СК
}
-------------------------

Создать валидатор вручную

public function store(Request $request) {

  передаем данные и правила валидации
  $validator = Validator::make($request->all(), [
    'title' => 'required|unique',
  ]);

  проверяем
  if ($validator->fails()) {
  
    ошибки
    $validator->errors
	
    return redirect('post/create')
	  
	  кладем ошибки во FS
	  метод принимает $validator, MessageBag, массив
      ->withErrors($validator)
      ->withInput();
  }
}

Редирект

Validator::make($request->all(), [
  'title' => 'required|unique'
])->validate();

Редирект и ошибки в именованный пакет

Validator::make($request->all(), [
    'title' => 'required|unique'
])->validateWithBag('post');
-------------------------

Очистить подготовить изменить данные перед валидацией
protected function prepareForValidation() {
  $this->merge([
    'slug' => Str::slug($this->slug)
  ]);
}
-------------------------

Именованные пакеты ошибок

когда много форм на 1 странице
разложить ошибки на подмассивы каждый для своей формы

redirect('register')->withErrors($validator, 'bagname1');

Получить доступ к пакету
{{$errors->bagname->first('email')}}
-------------------------

Работа с сообщениями об ошибках

После вызова инстанса Validator метода errors, получаем инстанс MessageBag
MessageBag содержит много методов для работы с ошибками
$errors доступна во вьюхах и является инстансом MessageBag

Проверка на наличие сообщениЙ для Поля
if ($errors->has('email')) {}

Получить первое сообщение для Поля
$errors = $validator->errors();
$errors->first('email');

Получить все сообщения для Поля
foreach ($errors->get('email') as $error) {}

Получить все сообщения для Поля которое является массивом
foreach ($errors->get('emails.*') as $error) {}

Получить все сообщения для всех Полей
foreach ($errors->all() as $error) {}

@if ($errors->any())
  @foreach ($errors->all() as $error)
    {{$error}}
  @endforeach
@endif
-------------------------

Изменить сообщения

Свои сообщения об ошибках

public function messages() {
  return [
    формат 'имя.правило'
    'name.required' => 'Название бренда обязательно :attribute',
  ];
}

в messages() заполнитель :attribute будет заменен именем Поля из attributes()

Заполнители полей

public function attributes() {
  return [
    'name' => 'Заголовок',
  ];
}

Заполнители
:attribute :other :size :input :min :max :values

Установка сообщения в языковых файлах

в языковой файл resources/lang/xx/validation.php добавить сообщение в $custom
'custom' => [
  'email' => [
    'required' => 'We need to know your e-mail address'
  ]
];

Установка заполнителей в языковых файлах

в языковой файл resources/lang/xx/validation.php добавить заполнители в $attributes
'attributes' => [
  'email' => 'email address'
];

Установка заполнителей в валидаторах созданных вручную

$customAttributes = ['email' => 'email address'];
$validator = Validator::make($input, $rules, $messages, $customAttributes);
-------------------------

Сложный пример

$request->validate([
  creditCard обязателен если payment установлен в cc
  'creditCard' => 'required_if:payment,cc',
]);


Заполнитель для cc

в языковой файл resources/lang/xx/validation.php добавить в $values

'values' => [
  'payment' => [
    'cc' => 'credit card'
  ],
];
-------------------------

Правила валидации

accepted - yes, on, 1, true
active_url - A, AAAA запись dns_get_record
after:date - после даты N
after_or_equal:date - после или равно дате N
alpha - только буквы
alpha_dash - букво-цифры, знаки - и _
alpha_num - букво-цифры
array - PHP array

bail - остановка валидации после первой же ошибки
before:date - до даты N
before_or_equal:date - до или равно дате N
between:min,max -
boolean - true, false, 1, 0, "1", "0"

confirmed - совпадения для двух полей password и password_confirmation

date - должно быть датой
date_equals:date - должно быть равно дате N
date_format:format - дата должна быть нужного формата
different:field - поле должно иметь другое значение, чем поле field
digits:value - должно быть числовым
digits_between:min,max - должно быть числовым и от min до max
dimensions:min_width,max_width,min_height,max_height,width,height,ratio - файл должен быть картинкой с заданными параметрами. есть метод Rule::dimensions
distinct - массив без дублей значений

email - должно быть почтой. email:rfc,dns - валидаторы RFCValidation и DNSCheckValidation. всего 5 валидаторов
ends_with:foo,bar - должно заканчиваться одним из значений
exclude_if:anotherfield,value - поле будет исключено из данных Запроса, если поле anotherfield равно value
exclude_unless:anotherfield,value - поле будет исключено из данных Запроса, если поле anotherfield НЕравно value
exists:table[,column] - поле должно существовать в таблице БД. Можно указать свой столбец. Можно указать тип соединения. Можно указать Eloquent модель. Есть метод Rule::exists

file - поле должно быть успешно загруженным файлом
filled - поле не должно быть пустым, если оно присутствует

gt:field - поле должно быть больше чем поле field
gte:field - поле должно быть больше или равно чем поле field

image - поле должно быть картинкой jpeg, png, bmp, gif, svg, webp
in:foo,bar - поле должно быть одним из значений. Есть метод Rule::in
in_array:anotherfield.* - поле должно существовать в значениях другого поля
integer - целое число
ip - IP адрес
ipv4 - IPv4 адрес
ipv6 - IPv6 адрес

json - JSON строка

lt:field - поле должно быть меньше поля field
lte:field - поле должно быть меньше или равно полю field

max:value - поле должно быть меньше или равно значению value
mimetypes:image/png,video/mpeg - файл должен быть MIME типом. угадывание по контенту внутри файла
mimes:png,mpeg - файл должен быть MIME типом. угадывание по контенту внутри файла
min:value - поле должно быть равно value

not_in:foo,bar - поле НЕдолжно быть одним из значений. Есть метод Rule::notIn
not_regex:pattern - поле не должно совпадать регулярке. под капотом preg_match. Если внутри будет | то правила валидации указывать массивом
nullable - поле может быть NULL
numeric - поле должно быть цифровым

password - поле должно быть аутентификационным паролем юзера
present - поле должно быть во входных данных и оно не пустое

regex:pattern - поле должно совпадать регулярке. под капотом preg_match. Если внутри будет | то правила валидации указывать массивом

required - поле должно быть во входных данных и оно не пустое (не NULL, '', [])

required_if:anotherfield,value - поле должно быть во входных данных и оно не пустое, если поле anotherfield равно значению value. Есть метод Rule::requiredIf

required_unless:anotherfield,value - поле должно быть во входных данных и оно не пустое, если поле anotherfield НЕравно значению value.

required_with:foo,bar - поле должно быть во входных данных и оно не пустое, если присутствует любое из других указанных полей

required_with_all:foo,bar -
поле должно быть во входных данных и оно не пустое, если присутствуют ВСЕ другие указанные поля

required_without:foo,bar - поле должно быть во входных данных и оно не пустое, если отсутствует любое из других указанных полей

required_without_all:foo,bar - поле должно быть во входных данных и оно не пустое, если отсутствуют ВСЕ другие указанные поля

same:field - поле должно быть равно полю field

size:value - поле должно иметь указанный размер. для строк это колво букв. для чисел это число. для массива это колво элементов. для файлов это размер в Кб.

starts_with:foo,bar - поле должно начинаться с одного из заданных значений

string - поле должно быть строкой

sometimes - если поле есть в выходных данных

timezone - поле должно быть таймзоной из php timezone_identifiers_list

unique:table,column,except,idColumn - поле не должно существовать в БД. можно указать Eloquent модель. можно указать тип соединения. есть метод Rule::unique

url - поле должно быть урлом

uuid - поле должно быть валидным UUID по RFC 4122
-------------------------

Условное добавление правил валидации

Пропуск валидации для поля, когда другие поля имеют значения

Метод exclude_if

[
  'field1' => 'bool',
  'field2' => 'exclude_if:field1,false',
  'field3' => 'exclude_if:field1,false',
];

field2 и field3 не будут валидироваться, если поле field1 false


Метод exclude_unless

[
  'field1' => 'bool',
  'field2' => 'exclude_unless:field1,true',
  'field3' => 'exclude_unless:field1,true',
];

Валидация поля если оно присутствует
sometimes - если поле есть в выходных данных

[
  'email' => 'sometimes|required',
];

Комплексная условная проверка

сложные проверки
например required для поля, если другое поле > 100
два поля должны иметь значение, если другое поле присутствует

[
  'email' => 'required|email',
  'games' => 'required|numeric',
];

$v->sometimes('reason', 'required|max:500', function ($input) {
  return $input->games >= 100;
});

В sometimes передаем условно-проверяемое поле 'reason' и его правила валидации

Если в замыкании возвращается true, то правила валидации будут добавлены.

Для нескольких полей

$v->sometimes(['reason', 'cost'], 'required', function ($input) {
  return $input->games >= 100;
});

$input - инстанс класса Support\Fluent, там есть доступ к вводу и файлам.
-------------------------

Валидация массивов

На форме массив инпутов
валидация 1 элемента

[
  'photos.profile' => 'required|image',
];

На форме массив инпутов
валидация всех элементов

[
  'person.*.email' => 'email|unique:users',
  'person.*.first_name' => 'required_with:person.*.last_name',
];

Свои сообщения об ошибках при валидации массивов
'custom' => [
  'person.*.email' => [
    'unique' => 'Each person must have a unique e-mail address',
  ]
];
-------------------------

Свои правила валидации

1. Создать класс правил валидации

php artisan make:rule NameRule
app/Rules/NameRule.php

Метод passes
логика проверки
вернуть true или false

Метод message
сообщения об ошибках
хелпер trans даст локализованное сообщение об ошибке

Прикрепляем класс
$request->validate([
  'name' => ['required', 'string', new NameRule],
]);

2. Замыкания

$validator = Validator::make($request->all(), [
  'title' => [ 'required', function ($attribute, $value, $fail) {
      if ($value === 'foo') {
        $fail($attribute.' is invalid');
      }
    }
  ]
]);

3. Расширения

Метод extend в Фасаде Validator
использовать в СП

public function boot() {

  передадим замыкание
  Validator::extend('foo', function ($attribute, $value, $parameters, $validator) {
    return $value == 'foo';
  });

  передадим класс и метод
  Validator::extend('foo', 'FooValidator@validate');
  
  добавим свои сообщения об ошибках
  Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) {
    return str_replace(...);
  });
}

4. Неявные Расширения

Когда поля нет или значение пустое
валидация не запускаются

$rules = ['name' => 'unique:users,name'];
$input = ['name' => ''];
Validator::make($input, $rules)->passes(); отдаст true

Чтобы валидация запускалась на пустом поле

Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {
  return $value == 'foo';
});

Неявные объекты правил

Чтобы валидация вида Объект Rule запускался на пустых полях, реализовать интерфейс
Contracts\Validation\ImplicitRule
-------------------------------------------------

THE BASICS -> ERROR HANDLING

Обработка и логирование, ошибок и исключений

В config/app.php $debug - сколько ошибок показать юзеру, берет значение из APP_DEBUG в .env
Локально APP_DEBUG = true, для продакшена false

App\Exceptions\Handler

Метод Report
Для логирования исключений и отправки в сторонние сервисы Flare, Bugsnag, Sentry

public function report(Throwable $exception) {
  if ($exception instanceof CustomException) {свой ответ}
  parent::report($exception);
}

Контекст журнала
Дополнительная контекстная инфа типа ID юзера
В методе context добавить свой набор. Эта инфа будет включена в логи.

protected function context() {
  return array_merge(parent::context(), [
    'foo' => 'bar'
  ]);
}

Хелпер Report
Логировать исключение, но продолжить приложение дальше, не отображая страницу ошибки

try {
  валидация данных
} catch (Throwable $e) {
  report($e);
  return false;
}

Игнорирование исключений по типу
В массиве $dontReport сложить эти исключения. Они не будут логироваться.
Исключение 404 не логируется. Можно добавить свои типы исключений.

Метод Render
Конверт исключения в HTTP Ответ для браузера

public function render($request, Throwable $exception) {

  проверяем тип исключения и отдаём свой Ответ
  if ($exception instanceof CustomException) {
    return response()->view('errors.custom', [], 500);
  }

  return parent::render($request, $exception);
}

Отчетные и отображаемые исключения

Можно свой класс Исключений
Все зависимости разрешаются через СК

HTTP Исключения

Хелпер Abort поднимает исключение (HttpException) с указанным кодом ответа

abort(404);
abort(401);
abort(403, 'мессага');
abort(500);

Создать шаблоны для всех кодов ошибок
php artisan vendor:publish --tag=laravel-errors

из папки \vendor\laravel\framework\src\Illuminate\Foundation\Exceptions\views]
будет скопировано в resources/views/errors

Свои страницы ошибок для HTTP Исключений
лежат в resources/views/errors/404.blade.php

Внутри доступна переменная $exception как инстанс HttpException
<h2>{{$exception->getMessage()}}</h2>
-------------------------------------------------

THE BASICS -> LOGGING

Ведение логов на файлах
на основе библиотеки Monolog
конфиг config/logging.php
по умолчанию канал stack
Фасад Log

Имя канала
по умолчанию имя канала равно значению среды - local, production

зададим своё

'stack' => [
  'driver' => 'stack',
  'name' => 'channel-name',
  'channels' => ['single', 'slack']
];

Драйверы
stack, single, daily, slack, papertrail, syslog, errorlog, monolog, custom

Настройка каналов Single и Daily
параметры bubble, permission, locking

Настройка канала Papertrail
параметры url, port

Настройка канала Slack
параметры url

Построение логов Stacks
драйвер stack позволяет комбинировать много каналов в один канал

'channels' => [

  'stack' => [
    'driver' => 'stack',
    'channels' => ['syslog', 'slack'] канал stack агреггирует 2 канала: syslog и slack
  ],

  'syslog' => [
    'driver' => 'syslog',
    'level' => 'debug'
  ],

  'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => 'Laravel Log',
    'emoji' => ':boom:',
    'level' => 'critical'
    ]
];

Уровень логов
level - минимальный уровень
все уровни: emergency, alert, critical, error, warning, notice, info, debug

Пишем в лог
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

Все мессаги будут записаны в дефолтовый канал который указан в config/logging.php

Контекстная инфа
передать дополнительную инфу
Log::info('User failed to login.', ['id' => $user->id]);

Запись в нужный канал
записать мессагу в канал отличный от канала по умолчанию

Log::channel('slack')->info('Something happened');
Log::stack(['single', 'slack'])->info('Something happened'); в несколько каналов

Свои каналы Monolog

Создать свою реализацию FormatterInterface
Создать каналы обработчика Monolog
Создать каналы через Фабрику
-------------------------------------------------

FRONTEND -> BLADE TEMPLATES

Blade - это движок PHP шаблонов, можно писать внутри PHP код
Шаблоны компилируются в PHP и кешируются
Шаблоны основаны на регулярных выражениях

Папка вьюх
resources/views


Лайот
resources/views/layouts/app.blade.php

<html>

  переменная
  <title>@yield('title')</title>
  <body>
  
    тут будет вьюха
    @yield('content')

  </body>
<html>


Вьюха
resources/views/child.blade.php

расширились от лайота
@extends('layouts.app')

переменная
@section('title')
    титл
@endsection

сама вьюха
@section('content')
  контент
@endsection


@yield для определения раздела в лайоте
вьюха расширяется от лайота через @extends
во вьюхе вставляем в раздел @section
@parent присоединит контент к контенту а не заменит


Вьюха по умолчанию если нет раздела
@yield('content', View::make('viewname'));


Отображение данных

экранирует через htmlspecialchars против XSS атак
{{$name}}

без экранирования
{{!! $name !!}}

Отобразить JSON
@json принимает все аргументы PHP json_encode

<script>
  var app = @json($array);
  var app = @json($array, JSON_PRETTY_PRINT);
</script>

HTML Entity кодирование
Blade и хелпер E автоматически делают двойное кодирование double encode HTML entities
Это можно отключить
AppServiceProvider

public function boot() {
  Blade::withoutDoubleEncoding();
}


Blade и JavaScript фреймворки

{{}}
JS фреймворки тоже используют эту конструкцию для переменных

@{{}}
в Blade писать так
символ @ отбрасывается и в JS фреймворк придет {{}}

Символ @ также используется для выхода из директив
@@json()
  код
@json()

Директива @verbatim
Для показа js переменных в большом шаблоне
Для оборачивания HTML, чтобы внутри каждой переменной не приставлять символ @

@verbatim
  {{name}}
@endverbatim


Операторы IF

Аналог IF(){} ELSEIF(){} ELSE{}
@if (условие) код @elseif (условие) код @else код @endif

Аналог IF(!){}
@unless (условие) код @endunless

Аналог PHP isset
@isset(условие) код @endisset

Аналог PHP empty
@empty(условие) код @endempty


Директивы аутентификации

@auth код @endauth
@auth('guardName') код @endauth
@guest код @endguest
@guest('guardName') код @endguest


Проверка на наличие и отсутствия раздела

@hasSection('navigation') @yield('navigation') @endif
@sectionMissing('navigation') @include('defaultNavigation') @endif


Директивы переменных среды

@production код @endproduction
@env('staging') код @endenv
@env(['staging', 'production']) код @endenv


Операторы Switch

@switch($i)

  @case(1)
    код
  @break

  @case(2)
    код
  @break

  @default
    код

@endswitch

Циклы

@for ($i = 0; $i < 10; $i++) {{$i}} @endfor
@foreach ($users as $user) {{$user->id}} @endforeach
@forelse ($users as $user) {{$user->name}} @empty пусто @endforelse
@while (true) код @endwhile

Пропустить итерацию

@continue
@continue(условие)

Завершить цикл

@break
@break(условие)

Переменная цикла
внутри цикла доступна $loop

свойства $loop
index, iteration, remaining, count, 
first, last, even, odd, depth, parent


Доступ к $loop в вложенном цикле

@foreach ($users as $user)
  @foreach ($user->posts as $post)
    @if ($loop->parent->first)
	  код
    @endif
  @endforeach
@endforeach


Комменты в коде Blade
удаляются при компилировании
{{--коммент--}}


Вставка PHP в шаблон Blade
@php
  код
@endphp

Шаблон скомпилировать 1 раз
для скриптов

@once
  @push('scripts')
    <script>
      код
    </script>
  @endpush
@endonce


Формы

Поле CSRF
скрытое поле для токена

<form>
  @csrf
</form>


Метод отправки формы
у аттрибута method нет методов PUT, PATCH, DELETE
поэтому указываем в скрытом поле _method

<form method="POST">
  @method('PUT')
</form>


Вывод ошибок валидации

Поле
<input class="@error('title') is-invalid @enderror">

Ошибка
@error('title')
  {{$message}}
@enderror


Поле
<input class="@error('title', 'createpostform') is-invalid @enderror">

Ошибка в именованном пакете ошибок
когда на 1 странице много форм

@error('title', 'createpostform')
  {{$message}}
@enderror
--------------------

Компоненты

Компоненты на базе замыканий и классов
Компоненты это аналог @include
Компоненты позволяют привязку данных
Зависимости автоматически внедряются в СК

Папки компонентов
в этих папках компоненты обнаруживаются автоматически

app/View/Components - класс
resources/views/components - вьюха

Компонент на базе класса
php artisan make:component Alert

будет создано
app/View/Components/Alert.php
resources/views/components/alert.blade.php
-------------------------

Отображение компонентов во вьюхах

<x-alert/>
<x-user-profile/>
<x-inputs.button/>

Пути
точка как разделитель папок
App\View\Components\Inputs\Button.php
<x-inputs.button/>
-------------------------

Передача данных в компоненты

<x-alert type1="type1" type2="type2" id="id1" class='class1' />
<x-dynamic-component component="alert"/>

Параметры компонента

class Footer extends Component {

  свойства
  public function __construct($type1, $type2) {

    $this->type1 = $type1;
    $this->type2 = $type2;
  
    нейминг стиль camelCase
    $this->alertType = $alertType;
  }
  
  метод
  public function method1($option) {
    return $option;
  }
}  

Вывод во вьюхе компонента
{{$type1}}
{{$type2}}
{{$method1(333)}}
{{$attributes}}
{{$id}}
{{$class}}
{{$attributes->merge(['class'=>'class2'])}}
{{$attributes->merge(['class' => $attributes->prepends('class2')])}}
{{$attributes->filter(fn ($value, $key) => $key == 'class')}}
{{$attributes->whereStartsWith('i')}}
{{$attributes->whereStartsWith('i')->first()}}

Сверху вьюхи
@props(['class'])
то что в массиве считать переменными. остальное упадет в {{$attributes}}

нейминг стиль kebab-case
<x-alert alert-type="danger" />  
-------------------------

Доступ к имени компонента, аттрибутам, слотам
внутри класса компонента

public function render() {
  return function (array $data) {
    dd($data);
  };
}
-------------------------

Дополнительные аттрибуты

Атрибуты не указанные в конструкторе компонента, будут в общем пакете $attributes
Внутри аттрибутов не работают @директивы

тег
<x-alert type="error" :message="$message" class="aaa"/>

вьюха
<div {{$attributes}}></div>

вывод
<div class="aaa"></div>
-------------------------

Аттрибуты по умолчанию и объединение

Для аттрибутов можно указать значения по умолчанию
Можно добавить дополнительные значения в аттрибуты

тег
<x-alert class='aaa'/>

вьюха
{{$attributes->merge(['class'=>'bbb'])}}

вывод
class="bbb aaa"
-------------------------

Слияние аттрибутов
всех которые не class


Не будет перезаписан

тег
<x-alert id="100"/>

вьюха
{{$attributes->merge(['id'=>200])}}

вывод
id="100"


Будет добавлен

тег
<x-alert id="100"/>

вьюха
{{$attributes->merge(['id' => $attributes->prepends('200')])}}

вывод
id="200 100"
-------------------------

Фильтрация аттрибутов

вернуть true чтобы оставить аттрибут в $attributes

тег
<x-alert class='aaa' id="100"/>

вьюха
{{$attributes->filter(fn ($value, $key) => $key == 'id')}}
{{$attributes->filter(fn ($value, $key) => $key == 'class')}}

вывод
id="100"
class="aaa"


получить аттрибуты начинающиеся с заданной строки
{{$attributes->whereStartsWith('string')}}

показать значение 1го аттрибута в массиве аттрибутов
{{$attributes->whereStartsWith('string')->first()}}
--------------------

Слоты

Слот это способ передать контент из тега компонента во вьюху компонента
Можно много слотов в разных местах компонента
Можно получить внутри слота доступ к данным компонента

Слот

тег
<x-alert>
  slotslot
</x-alert>

вьюха
{{$slot}}

вывод
slotslot


Именованный слот

тег
<x-alert>

  <x-slot name="xslot1">
    xslot1
  </x-slot>

  <x-slot name="xslot2">
    xslot2
  </x-slot>
  
</x-alert>

вьюха
{{$xslot1}}
{{$xslot2}}

вывод
xslot1 xslot2
-------------------------

Из слота получить методы и свойства компонента

метод компонента
public function method2($option) {
  return $option;
}

слот внутри тега компонента
<x-slot name="xslot3">
  {{$component->method2('method2')}}
</x-slot>

вьюха компонента
{{$xslot3}}

вывод
method2
-------------------------

Инлайновые компоненты
для малых компонентов
только класс без вьюхи

Создать компонент
php artisan make:component Alert --inline
app/View/Components/Alert.php

метод
public function render() {
  return <<<'blade'
    <div>Alert</div>
  blade;
}

тег
<x-alert/>
-------------------------

Анонимные компоненты
это компоненты с одной вьюхой и без класса

создать вьюху
resources/views/components/alert.blade.php

тег
<x-alert/>

тег с аттрибутами
<x-alert a1="a1" a2="a2" class='a3'/>

в вьюхе указать что есть переменные а что "всё остальное"
@props(['a1', 'a2'])

всё что в массиве - станет переменными и будет доступно как {{$a1}}
остальное упадет в {{$attributes}}

задать значение по умолчанию
@props(['a1' => 'a11'])
-------------------------

Динамические компоненты

вывести компонент на лету как имя переменной

<x-dynamic-component component="alert"/>
-------------------------

Директива @include
подключать вьюху в другую вьюху
все переменные родительской вьюхи доступны для подключаемой вьюхи
@include для многоразового использования HTML как PHP include

передать данные во вьюху
@include('signup', ['param' => 'value'])

подключить вьюху которой может не быть
@includeIf('signup')

выводить вьюху по условию
@includeWhen($boolean, 'signup')
@includeUnless($boolean, 'signup')

включить 1ю существующую вьюху из массива
@includeFirst(['signup', 'signin'])


Директива @inject

получить в переменную сервис из СК

@inject('metrics', 'App\Services\MetricsService')
{{$metrics->monthlyRevenue()}}


Создание blade директивы

AppServiceProvider 
public function boot() {
  Blade::directive('datetime', function ($param) {
    return "<?php echo $param ?>";
  });
}

выполнить
view:clear

вывод
@datetime($param)



Создание blade IF директивы

AppServiceProvider
public function boot() {
  Blade::if('disk', function ($value) {
    return config('filesystems.default') === $value;
  });
}

вывод
@disk('local')
  код
@elsedisk('s3')
  код
@else
  код
@enddisk

@unlessdisk('local')
  код
@enddisk
-------------------------

Алиас для вьюхи для быстрого доступа
Blade::include('includes.input', 'input');

вывод массивов
@each('view', $jobs, 'job', 'viewempty')
не наследуют переменные родительской вьюхи

@push
@stack
@prepend
@inject
-------------------------

Написание пакетов

1. Компоненты автоматически обнаруживаются в папках
речь про view components

app/View/Components
resources/views/components

2. Компоненты регистрируются в СП
речь про Blade components
или view components расположенные в других папках

public function boot() {
  Blade::component('package-alert', AlertComponent::class);
}

<x-package-alert/>

3. Компонент загружаемый автоматически
используя вендорный неймспейс
пакет Nightshade
компоненты Calendar и ColorPicker

public function boot() {
  Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
}

<x-nightshade::calendar />
<x-nightshade::color-picker />
-------------------------

Стеки

именованные стеки
для вывода в лайотах и вьюхах
js для отдельных вьюх

добавить вниз
@push('name1')
  <script src="/js.js"></script>
@endpush

добавить вверх
@prepend('name1')
  <script src="/js.js"></script>
@endprepend

вывод
@stack('name1')
-------------------------------------------------

FRONTEND -> LOCALIZATION

Фасад App
Хелпер __()

Папка языковых файлов
resources/lang

resources/lang/en/messages.php
resources/lang/ru/messages.php
resources/lang/es/messages.php

Языковые файлы возвращают массив
return [
  'welcome' => 'Welcome',
];

Все языковые файлы
https://github.com/Laravel-Lang/lang
https://github.com/caouecs/lang
--------------------

Разделение на регионы

называть по стандарту ISO 15897
resources/lang/en_GB/messages.php
--------------------

Настройка локали
в config/app.php указать 'locale'

Локаль по умолчанию, когда для текущей нет строки перевода
в config/app.php указать 'fallback_locale'
--------------------

Установка локали
App::setLocale('ru');

Определить текущую локаль
$locale = App::currentLocale()
$locale = App::getLocale()
if (App::isLocale('en')) {}
--------------------

Создать перевод
в resources/lang/es.json
{"Привет": "Hello"}
--------------------

Получить перевод

Формат "файл.ключ"
__('messages.welcome');
{{__('messages.welcome')}}

Формат "файл.мессага"
__('messages.Привет');
{{__('messages.Привет')}}

@lang('messages.welcome')
@lang('messages.Привет')
--------------------

Заполнители внутри строк перевода
регистр важен

'welcome' => 'Welcome, :name'
'welcome' => 'Welcome, :Name'
'welcome' => 'Welcome, :NAME'

вывод строки
__('messages.welcome', ['name' => 'dayle']);
--------------------

Плюрализация (множественное число)

Форматы строк
'apples' => 'There is one apple|There are many apples',
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',

Вывод
trans_choice('messages.apples', 10);

С заполнителями
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',
trans_choice('time.minutes_ago', 5, ['value' => 5]);

Сторонние пакеты с языковыми файлами
эти файлы можно менять, перенеся сюда
resources/lang/vendor/{packagename}/{en|ru|uk}/messages.php
-------------------------------------------------

FRONTEND -> SCAFFOLDING

Легкий старт с Bootstrap, React, Vue
Laravel Mix компилирует SASS, Less, Vue
Либы Lodash и Axios уже стоят

Установка
composer require laravel/ui
php artisan ui bootstrap
php artisan ui vue
php artisan ui bootstrap --auth
php artisan ui vue --auth

появится файл package.json
в нём писать все js зависимости как в composer.json

Установить зависимости из package.json
npm install

Запуск компиляции
npm run dev

webpack обработает инструкции из webpack.mix.js

Поставить наблюдателя для перекомпиляции
npm run watch

Компоненты Vue
в папке resources/js/components
компоненты регистрируются в app.js
-------------------------------------------------

FRONTEND -> COMPILING ASSETS

Laravel Mix использует Webpack для компиляции css и js

Конфиг
webpack.mix.js
--------------------

Установка NodeJS
https://nodejs.org/en/download
node -v
npm -v

В корне проекта package.json (аналог composer.json)

Установка зависимостей из package.json
npm install

Запуск mix команд
npm run dev

Запуск mix команд и минификация
npm run production

Наблюдение
npm run watch

Папки
public/css
public/js
--------------------

Less в css

mix.less('resources/less/app.less', 'public/css')
   .less('resources/less/admin.less', 'public/css/admin');

своё имя файла
mix.less('resources/less/app.less', 'public/css/styles.css');

свои настройки
mix.less('resources/less/app.less', 'public/css', {
  strictMath: true
});
--------------------

Sass в css

mix.sass('resources/sass/app.scss', 'public/css')
   .sass('resources/sass/admin.scss', 'public/css/admin');

своё имя
mix.sass('resources/sass/app.scss', 'public/css/styles.css');

свои настройки
mix.sass('resources/sass/app.scss', 'public/css', {
  precision: 5
});
--------------------

Stylus в css

mix.stylus('resources/stylus/app.styl', 'public/css');

плагин
npm install rupture

mix.stylus('resources/stylus/app.styl', 'public/css', {
  use: [
    require('rupture')()
  ]
});
--------------------

PostCSS преобразователь css

плагин Autoprefixer добавляет префиксы css3
mix.sass('resources/sass/app.scss', 'public/css')
  .options({
    postCss: [
      require('postcss-css-variables')()
    ]
});
--------------------

Объединение css в 1 файл

mix.styles([
  'public/css/vendor/normalize.css',
  'public/css/vendor/videojs.css'
  ], 
  'public/css/all.css'
);
--------------------

Работа с относительными url

было
{background: url('images/example.png');}

example.png перемещается в public/images

стало
{background: url(images/example.png?d41d8);}

Отключить перезапись url

mix.sass('resources/sass/app.scss', 'public/css')
  .options({
    processCssUrls: false
});
--------------------

Source Maps

включить
mix.js('resources/js/app.js', 'public/js')
  .sourceMaps();
--------------------

Синтаксис ES2015, модули, компиляция vue, минификацию

mix.js('resources/js/app.js', 'public/js');
--------------------

Убрать js вендоров из объединения в 1 файл

mix.js('resources/js/app.js', 'public/js')
  .extract(['vue']);

public/js/manifest.js
public/js/vendor.js либы
public/js/app.js код

подключить
<script src="/js/manifest.js"></script>
<script src="/js/vendor.js"></script>
<script src="/js/app.js"></script>
--------------------

React
пропустил
--------------------

Vanilla JS

минификация и объединение в 1 файл
mix.scripts([
  'public/js/admin.js',
  'public/js/dashboard.js'
  ], 'public/js/all.js'
);

минификация и объединение в 1 файл, старый код в новый ES2015
mix.babel([
  'public/js/admin.js',
  'public/js/dashboard.js'
  ], 'public/js/all.js'
);
--------------------

Настройка Webpack

Слить несколько конфигов
mix.webpackConfig({
  resolve: {
    modules: [
      path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js')
    ]
  }
});

Скопировать в корень node_modules/laravel-mix/setup/webpack.config.js
в package.json проставить все настройки с флагом --config чтобы ссылались на этот файл в корне
--------------------

Копирование папок и файлов в другое место

mix.copy('node_modules/foo/bar.css', 'public/css/bar.css');
mix.copyDirectory('resources/img', 'public/img');
--------------------

Кеширование

Добавить хеш чтобы скинуть кеш браузеров
mix.js('resources/js/app.js', 'public/js')
  .version();

Вьюха
<script src="{{mix('/js/app.js')}}"></script>
<link href='{{mix("/css/app.css")}}' rel='stylesheet'>

Проверка
public/mix-manifest.json
{ "/js/app.js": "/js/app.js?id=539...", "/css/app.css": "/css/app.css?id=5eb..."}

Кеширование только для продакшена
mix.js('resources/js/app.js', 'public/js');
if (mix.inProduction()) {
  mix.version();
}
--------------------

Скомпилированные ресурсы в CDN

в config/app.php урл до CDN
'mix_url' => env('MIX_ASSET_URL', null)

урлы будут такие
https://cdn.example.com/js/app.js?id=196
--------------------

BrowserSync

плагин для браузера
автоматический f5

установить
npm install -g browser-sync

включить
mix.browserSync('my-domain.test');

запустить
npm run watch
--------------------

Переменные среды

вставка переменных в Mix
такие переменные с префиксом MIX_

получить доступ
process.env.MIX_SENTRY_DSN_PUBLIC

если переменная меняется, то перезапустить
npm run watch
--------------------

Уведомления ОС

Системные уведомления в ОС когда выполняются задачи

Отключить
mix.disableNotifications();
-------------------------------------------------

SECURITY -> AUTHENTICATION

Фасад Auth

Гуарды - как определять что юзер залогинен. через сессию
Провайдеры - как извлечь юзера из базы. из какой таблицы

В контроллерах аутентификации быть не должно
Проверку аутентификации делают через МВ и вешают на роуты

Конфиг
config/auth.php

Галка "запомнить меня"
password 60-255 символов
remember_token для токена

Редирект после логина
в RouteServiceProvider
public const HOME = '/adminpanel';

Для логина используется поле почты
это можно поменять в LoginController
public function username() {
  return 'username';
}

Свой гуард прописать
в LoginController, RegisterController, ResetPasswordController

protected function guard() {
  return Auth::guard('guard-name');
}

Изменить набор полей, метод сохранения юзера в БД, - в классе RegisterController
В методе create вызывается запись App\User через Eloquent

для юзеров уже есть модель App\Models\User.php
она используется по умолчанию для аутентификации

Но модель можно заменить на 'database' и юзать query builder


логинимся
если логин пароль прошел
то ставится сессионная кука в браузер

для всего юзаются фасады Auth и Session

Залогиненный юзер
Auth::user();
Auth::id();
$request->user();
if (Auth::check()) {}


есть готовое МВ Auth для определения что юзер залогинен
auth => Illuminate\Auth\Middleware\Authenticate

в auth.php есть гуарды $guards
К роуту можно прикрепить Гуард из списка auth.php

для auth указать какой гуард юзать
Route::get('profile', function () {})
->middleware('auth:admins');

прикрепить к роуту
Route::get('profile', function () {})
  ->middleware('auth');

прикрепить к контроллеру
public function __construct() {
  $this->middleware('auth');
}

Редирект незалогиненного на страницу логина
app/Http/Middleware/Authenticate.php

protected function redirectTo($request) {
  return route('login');
}

Проверка пароля
на особо важных страницах, например биллинге

МВ password.confirm присоединить к роуту

Route::get('/settings/security', function () {})
  ->middleware(['auth', 'password.confirm']);

Потом проверка не делается 3 часа. Это можно изменить в auth.password_timeout

Контроль попыток логина

трейт ThrottlesLogins включен в контроллер LoginController
После нескольких попыток логина, бан на 1 мин

Ручная АУ юзеров

public function authenticate(Request $request) {

  $credentials = $request->only('email', 'password'); данные из формы

  проверка выборкой из БД. пароль уже хеширован для проверки
  if (Auth::attempt($credentials)) {
    return redirect()->intended('dashboard'); в методе intended урл редиректа куда потом направит
  }

  дополнительные условия для проверки
  if (Auth::attempt(['email' => $email, 'password' => $password, 'ban' => 0])) {
  }

}

юзаем фасад Auth
if (Auth::attempt([логин, пароль])) {
  $request->session()->regenerate();
  return redirect()->intended('dashboard');
}

метод intended вернет на урл, который открыли до редиректа на форму логина

по умолчанию указан провайдер App\Models\User.php в config/auth.php

укажем какой гуард юзать при логине
Auth::guard('admins')->attempt($credentials)

в auth.php есть гуарды $guards

если стоит кука remember_me "запомнить меня" то стирание основной куки логина - не разлогинивает. вообщем это бесконечная штука

логиним экземпляр юзера App\Models\User.php
экземпляр уже реализует эту хрень Contracts\Auth\Authenticatable для логина

Auth::login($user, $remember = true);

указать гуард
Auth::guard('admin')->login($user);

логиним по ID из базы
Auth::loginUsingId(1, $remember = true);

разлогин

Auth::logout();
$request->session()->invalidate();
$request->session()->regenerateToken();
return redirect('/');

ДОБАВИТЬ СВОЙ ГУАРД
в AuthServiceProvider в методе boot()

ДОБАВИТЬ СВОЙ ПРОВАЙДЕР
в AuthServiceProvider в методе boot()


поставить Laravel Breeze 

Доступ к гуардам
Если разные гуарды для разных частей приложения
Все гуарды в конфиге списком auth.php

if (Auth::guard('admin')->attempt($credentials)) {}

Разлогин
Auth::logout();
$request->session()->invalidate();
$request->session()->regenerateToken();
return redirect('/');


Галочка "Запомнить меня"
в таблице users поле remember_token
$remember ставить в true

логинимся
Auth::attempt(['email' => $email, 'password' => $password], $remember = true))

ставится кука вида
remember_web_59ba* = eyJpdiI6IlJXTXZGMF*

Проверка на наличие того, что юзер поставил галочку "Запомнить меня"
по факту проверка специальной куки

if (Auth::viaRemember()) {}

Другие методы АУ

Логиним экземпляр юзера
Auth::login($user);
Auth::login($user, true); с галочкой Запомнить меня

Auth::guard('admin')->login($user); с указанием гуарда

Auth::loginUsingId(1); по ID юзера
Auth::loginUsingId(1, true); по ID юзера и с галочкой

if (Auth::once($credentials)) {} логин для 1 запроса. без кук и сессий

HTTP Basic АУ
Добавить МВ auth.basic к роуту
По умолчанию используется поле email как username
Для FastCGI дополнительные настройки в .htaccess

Route::get('profile', function () {})->middleware('auth.basic');

HTTP Basic АУ без сохранения состояния
Нужна для API. пропустил


Разлогин для других устройств, кроме текущего
По факту инвалидация всех других сессий, кроме текущей

раскоментить МВ в app/Http/Kernel.php
'web' => [\Illuminate\Session\Middleware\AuthenticateSession::class];

Auth::logoutOtherDevices($password); этот метод требует вбива пароля.

Добавление своих гуардов
пропустил

Добавление своих провайдеров
пропустил

События
Можно добавить прослушиватели, на события АУ в EventServiceProvider: События Registered, Attempting, Authenticated, Login, Failed, Validated, Verified, Logout, CurrentDeviceLogout, OtherDeviceLogout, Lockout, PasswordReset.
-------------------------------------------------

SECURITY -> AUTHORIZATION

Авторизация (АВ) это разрешение юзеру действий над ресурсом
Реализуется через Гейты (Г) и Политики (П)

Гейты - это как роуты, основаны на замыканиях, применяются к абстрактным действиям
Политики - это как контроллеры, применяются на модель или ресурс

Гейты
Фасад Gate

передаем юзера $user и опционально модель в AuthServiceProvider

Gate::define('update-post', function ($user) {
  return $user->isAdmin;
});

Gate::define('update-post', function ($user, $post) {
  return $user->id === $post->user_id;
});

Gate::define('update-post', 'App\Policies\PostPolicy@update');

Разрешаем или запрещаем действия
$user передаётся туда сам

if (Gate::allows('update-post')) {}
if (Gate::allows('update-post', $post)) {}
if (Gate::denies('update-post', $post)) {}

Разрешаем или запрещаем действия массово

if (Gate::any(['update-post', 'delete-post'], $post)) {}
if (Gate::none(['update-post', 'delete-post'], $post)) {}

Проверка разрешения Юзер-Действие
if (Gate::forUser($user)->allows('update-post', $post)) {}
if (Gate::forUser($user)->denies('update-post', $post)) {}

Авторизовать или выбросить исключение
Если юзеру не разрешено действие то выплюнет HTTP 403

Gate::authorize('update-post', $post);

Передать дополнительный контекст

Gate::define('create-post', function ($user, $category, $extraFlag) {
  return $category->group > 3 && $extraFlag === true;
});

if (Gate::check('create-post', [$category, $extraFlag])) {}

Методы Гейта
allows, denies, check, any, none, authorize, can, cannot

Директивы Blade
@can, @cannot, @canany

Ответ Гейта
Возвращает boolean. Можно вернуть ответ Response с текстом ошибки.

Gate::define('edit-settings', function ($user) {

  return $user->isAdmin
    ? Response::allow()
    : Response::deny('You must be a super administrator.');

});

Gate::allows вернет boolean. Поэтому поймать такой ответ можно

$response = Gate::inspect('edit-settings', $post);

if ($response->allowed()) {

  } else {
    echo $response->message();
}

Метод before
запускается ДО всех проверок

Gate::before(function ($user, $ability) {
  if ($user->isSuperAdmin()) {
    return true;
  }
});

Метод after
запускается ПОСЛЕ всех проверок

Gate::after(function ($user, $ability, $result, $arguments) {
  if ($user->isSuperAdmin()) {
    return true;
  }
});

Если before и after возвращают true, то проверка прошла глобально.
Это нужно например чтобы выдать все права админу.

Политики
Политики - это классы которые организуют логику доступа для модели или ресурса.
В блоге модель Post и политика PostPolicy.
Политики в app/Policies.
Политики разрешаются через СК, поэтому можно добавить любые зависимости.

Создать политику
php artisan make:policy PostPolicy

создать с CRUD (viewAny, view, create, update, delete, restore, forceDelete)
php artisan make:policy PostPolicy --model=Post

Регистрация политики
тут AuthServiceProvider

в массиве $policies = [Post::class => PostPolicy::class];
тут связь Eloquent Модели и Политики

Автопоиск политики
Политики зареганные явно, имеют приоритет над авто-найденными политиками.
Альтернатива регистрации руками.
Через наименования User и UserPolicy.
Можно написать свою логику автопоиска политики в методе Gate::guessPolicyNamesUsing.

В политику добавляем методы для каждого действия, которое оно разрешает или запрещает
Все методы: viewAny, view, create, update, delete, restore, forceDelete

class PostPolicy {
  public function update(User $user, Post $post) {
    return $user->id === $post->user_id; проверка что Юзер может редактировать Пост. что это его пост
  }
}


Что политика возвращает в Ответ
Вернем не boolean а полный Ответ

public function update(User $user, Post $post) {
  return $user->id === $post->user_id
    ? Response::allow()
    : Response::deny('You do not own this post.');
}

ловим ответ

$response = Gate::inspect('update', $post);
if ($response->allowed()) {} else {
  echo $response->message();
}

Все Г и П возвращают false если запрос от не аутентифицированного юзера.
Такие запросы можно пропускать тоже.

public function update(?User $user, Post $post) {
  return optional($user)->id === $post->user_id;
}

Фильтры политик. Вообщем полный доступ для админа. Метод before как в Гейтах

public function before($user, $ability) {
  if ($user->isSuperAdmin()) {
    return true;
	return false; полный запрет
	return NULL; авторизация будет выполняться методами политики
  }
}

Авторизация действий используя Политики

1. Через модель User. модель User содержит эти 2 метода

if ($user->can('update', $post)) {} метод update модели post
if ($user->cant('update', $post)) {}

Если для данной модели зарегистрирована политика, метод can автоматически вызовет соответствующую политику и вернет результат.

Если для модели не зарегистрирована политика, метод can попытается вызвать гейт на основе замыкания, соответствующий заданному имени действия.

Действия не требующие моделей
if ($user->can('create', Post::class)) {}

2. через МВ
МВ авторизует действия, до того как запрос достигнет роута или контроллера.
В App\Http\Kernel, МВ Illuminate\Auth\Middleware\Authorize стоит с ключом can.

Route::put('/post/{post}', function (Post $post) {})->middleware('can:update,post');

can это МВ
update это действие которое хотим авторизовать
post это параметр маршрута который передаем Политике. по факту передадим модель Post

Если юзер не авторизован для выполнения этого действия, то вернется ответ HTTP 403

Действия не требующие моделей

Route::post('/post', function () {})->middleware('can:create,App\Post');

3. через метод контроллера authorize()
вернет HTTP 403 если нет авторизации. Как и метод can, этот метод принимает имя действия, которое вы хотите разрешить, и соответствующую модель. Если действие не авторизовано.

public function update(Request $request, Post $post) {
  $this->authorize('update', $post);
}

Действия не требующие моделей

public function create(Request $request) {
  $this->authorize('create', Post::class);
}

Авторизация Контроллеров Ресурсов
использовать метод authorizeResource в конструкторе контроллера ресурсов.
этот метод прикрепляет МВ can к методам контроллера ресурсов

public function __construct() {
  $this->authorizeResource(Post::class, 'post'); прикрепили модель и роут
}

ресурсный контроллер должен быть создан с флагом --model

4. через шаблоны Blade
директивы @can, @cannot

@can('update', $post)
  юзер может изменять пост
@elsecan('create', App\Post::class)
  юзер может создавать пост
@endcan

@cannot('update', $post)
  юзер НЕможет изменять пост
@elsecannot('create', App\Post::class)
  юзер НЕможет создавать пост
@endcannot

@canany(['update', 'view', 'delete'], $post)
  юзер может изменять, просматривать, удалять пост
@elsecanany(['create'], \App\Post::class)
  юзе может создавать пост
@endcanany

@can, @cannot аналог @if и @unless. Можно переписать так

@if (Auth::user()->can('update', $post))
  юзер может изменять пост
@endif

@unless (Auth::user()->can('update', $post))
  юзер НЕможет изменять пост
@endunless

Действия не требующие моделей
@can('create', App\Post::class)
  юзер может создавать пост
@endcan

@cannot('create', App\Post::class)
  юзер Неможет создавать пост
@endcannot

Передача дополнительного контекста

public function update(User $user, Post $post, int $category) {
  return $user->id === $post->user_id && $category > 3;
}

и потом вызвать политику так:
$this->authorize('update', [$post, $request->input('category')]);
-------------------------------------------------

SECURITY -> EMAIL VERIFICATION

Готовые методы отправки и верификации пользователей при реге
Модель App\User должна расширять контракт Contracts\Auth\MustVerifyEmail

Новые юзеры получают на почту письмо со ссылкой
К событию Auth\Events\Registered присоединен слушатель SendEmailVerificationNotification в EventServiceProvider

Столбик users.email_verified_at с датой верификации юзера

Добавить роут Auth::routes(['verify' => true]);
Класс Auth\VerificationController содержит всю логику верификации по почте

МВ verified разрешает доступ к роуту только проверенным юзерам
Route::get('profile', function () {})
  ->middleware('verified');

Вьюхи готовы
composer require laravel/ui
php artisan ui vue --auth

шаблон resources/views/auth/verify.blade.php

Редирект после верификации
VerificationController:
protected $redirectTo = '/dashboard';

События
Есть набор событий при отправке почты юзеру и дальнейшей верификации.
-------------------------------------------------

SECURITY -> ENCRYPTION

Методы
OpenSSL с AES-256, AES-128, AES-256-CBC с подписью MAC

Фасад Crypt


Сгенерировать application key
config/app.php 'key' вбить руками

или командой
php artisan key:generate


Зашифровать
Crypt::encryptString($value);

Расшифровать
если не удалось, будет выброшено исключение DecryptException

Crypt::decryptString($value);
-------------------------------------------------

SECURITY -> HASHING

Для хеширования паролей
Фасад Hash

в LoginController и RegisterController по умолчанию Bcrypt

Конфиг
config/hashing.php

Драйверы
Bcrypt, Argon2 (Argon2i (требует PHP 7.2), Argon2id (требует PHP 7.3))

Хешируем

Hash::make($value);
Hash::make($value, ['rounds' => 12]); сложность для Bcrypt

Hash::make($value, ['memory' => 1024, 'time' => 2, 'threads' => 2]); сложность для Argon2

Проверка хеша
if (Hash::check('passwordfromForm', $passwordfromDBasHash)) {}

Проверка необходимости повторного хеширования пароля
Это нужно когда изменилась "сложность" и требуется перехешировать пароль на новый хеш

if (Hash::needsRehash($hashed)) {
  Hash::make($value);
}
-------------------------------------------------

SECURITY -> RESETTING PASSWORDS

Готовый набор для сброса пароля

composer require laravel/ui
php artisan ui vue --auth
php artisan migrate

база должна сохранять password reset токен
токен годен 1 час
изменить можно в config/auth.php 'expire'

контракт Contracts\Auth\CanResetPassword
класс App\User
вьюхи resources/views/auth/passwords

вся логика тут
Auth\ForgotPasswordController
Auth\ResetPasswordController

редирект после сброса пароля
ResetPasswordController
$redirectTo = '/dashboard';

Настройка Гуарда Аутентификации
в auth.php
в ResetPasswordController указать свой гуард

protected function guard() {
  return Auth::guard('guard-name'); мой гуард
}

Брокеры паролей
в auth.php
в ForgotPasswordController и ResetPasswordController

public function broker() {
  return Password::broker('name'); свой брокер
}

Класс уведомлений для отправки почты юзеру

модель User
public function sendPasswordResetNotification($token) {
  $this->notify(new ResetPasswordNotification($token));
}
-------------------------------------------------

DIGGING DEEPER -> ARTISAN CONSOLE

Artisan - это command line interface (CLI)
Фасад Artisan

список всех команд
php artisan list

хелп по команде
php artisan help commandName

Tinker - это пакет REPL (read-eval-print-loop) на базе пакета PsySH
уже стоит
писать код в консоли как php -a

установка Tinker вручную
composer require laravel/tinker

войти в Tinker
php artisan tinker

опубликовать файл конфига
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

Белый список команд
clear-compiled, down, env, inspire, migrate, optimize, up

в tinker.php добавить свои команды в свойство 'commands'

Чтобы Tinker не присваивал классам псевдонимы
в tinker.php добавить классы в свойство 'dont_alias'

Классы команд разрешаются через СК, поэтому можно любые зависимости.

Создать команду
в app/Console/Commands

php artisan make:command CommandName

заполнить свойства
$signature = 'email:send {user}';
$description = 'description description';

исполнение в методе
public function handle(DripEmailer $drip) {
  $drip->send(User::find($this->argument('user')));
}

Команды на базе Замыканий

Роуты на основе замыканий - альтернатива контроллерам.
Команды на основе замыканий - альтернатива командам на классах.

в app/Console/Kernel.php в методе commands грузим routes/console.php
в этом файле определять роуты на базе замыканий но только через Artisan::command

Сигнатура метода

Artisan::command('build {project}', function ($project) {

  в замыкании получаем аргументы и опции команды
  $this->info("Building {$project}!");
});

Artisan::command('email:send {user}', function (DripEmailer $drip, $user) {
  $drip->send(User::find($user));
});


Описание

Artisan::command('build {project}', function ($project) {
  $this->info("Building {$project}!");
})->describe('Build the project');

Аргументы

$signature = 'email:send {user}'; аргумент user обязателен
email:send {user?} аргумент user НЕобязателен
email:send {user=foo} аргумент user со значением по умолчанию

Опции
идут с дефисами --

$signature = 'email:send {user} {--queue}'; опция без значения это флаг
php artisan email:send 1 --queue; запуск

'email:send {user} {--queue=}'; опция со значением
php artisan email:send 1 --queue=default; запуск

email:send {user} {--queue=default}; опция со значением по умолчанию

Шорткат для опции
email:send {user} {--Q|queue}; --Q это краткая запись опции --queue

Ввод массивов

email:send {user*}
php artisan email:send foo bar

email:send {user} {--id=*}
php artisan email:send --id=foo --id=bar


Описание для аргументов и опций

$signature = 'email:send
  {user : The ID of the user}
  {--queue= : Whether the job should be queued}';

Получить аргументы и опции

public function handle() {

  $userId = $this->argument('user');
  $arguments = $this->arguments();

  $queueName = $this->option('queue');
  $options = $this->options();
}

Запрос на ввод

public function handle() {
  $name = $this->ask('What is your name?');
  $password = $this->secret('What is the password?');
}

Запрос на подтверждение

if ($this->confirm('Do you wish to continue?')) {}; ввести y или yes

Автозаполнение ввода

$this->anticipate('What is your name?', ['Taylor', 'Dayle']);

замыкание будет вызываться при печатании каждой буквы
$this->anticipate('What is your name?', function ($input) {});

Множественный выбор из вариантов

$this->choice(
  'What is your name?',
  ['Taylor', 'Dayle'],
  $defaultIndex, значение выбора по умолчанию
  $maxAttempts = null, колво попыток выбора
  $allowMultipleSelections = false позволить множественный выбор
);

Вывод результата
каждый будет своим цветом

public function handle() {
  $this->line('Display this on the screen'); без цвета
  $this->info('Display this on the screen'); синий
  $this->comment('Display this on the screen');
  $this->question ('Display this on the screen');
  $this->error('Display this on the screen'); красный
}

Вывод результата таблицей

$headers = ['Name', 'Email'];
$users = App\User::all(['name', 'email'])->toArray();
$this->table($headers, $users);

Прогресс бар

$bar = $this->output->createProgressBar(count($users));
$bar->start();

foreach ($users as $user) {
  $this->performTask($user);
  $bar->advance();
}

$bar->finish();

Регистрация команд

команды в app/Console/Commands зареганы автоматически.
Для других папок сделать так

protected function commands() {
  $this->load(__DIR__.'/Commands');
  $this->load(__DIR__.'/MoreCommands');
}

или

добавить в app/Console/Kernel.php
$commands = [
  Commands\SendEmails::class
];

Вызов команд вне CLI
из роута или контроллера.
Artisan::call принимает команду, класс, параметры

Route::get('/foo', function () {

  $exitCode = Artisan::call('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

});

или

Artisan::call('email:send 1 --queue=default');

Поставить команду в очередь чтобы работало в фоновом режиме

Route::get('/foo', function () {

  Artisan::queue('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

});

Указать соединение и очередь

Artisan::queue('email:send', [
  'user' => 1,
  '--queue' => 'default'
])->onConnection('redis')
  ->onQueue('commands');

Передать опции как массивы

Route::get('/foo', function () {

  $exitCode = Artisan::call('email:send', [
    'user' => 1,
	'--id' => [5, 13]
  ]);

});

Передать булево значение

$exitCode = Artisan::call('migrate:refresh', [
  '--force' => true
]);

Вызов команд из других команд

public function handle() {

  $this->call('email:send', [
    'user' => 1,
	'--queue' => 'default'
  ]);

}

Подавить вывод в консоль
$this->callSilent('email:send', [
  'user' => 1,
  '--queue' => 'default'
]);

Кастомизация Stub
чтобы править рутовые команды Artisan.
папка /stubs.
править сами шаблоны.
Все изменения сделанные руками, отразятся во всех командах Artisan::make

php artisan stub:publish
-------------------------------------------------

DIGGING DEEPER -> BROADCASTING

Вещание событий через вебсокеты
Изменения c сервера приходят (вещаются) через вебсокеты в клиентскую js либу Laravel Echo
Вещание событий происходит через создание события через создание задачи в очереди
События вещаются по каналам, публичным или приватным
Хелпер broadcast

Конфиг
config/broadcasting.php

Драйверы вещания на стороне сервера
платные Pusher Channels, Ably
бесплатный laravel-websockets, Redis
для отладки log
для выключения Null

СП
в config/app.php в $providers
раскоментить App\Providers\BroadcastServiceProvider
в этом файле роуты
--------------------

Установка Laravel Echo и Pusher JS

npm install laravel-echo
npm install pusher-js
npm run dev
--------------------

Концепт

Запуск события
EventName::dispatch($user);

В классе события EventName
интерфейс ShouldBroadcast

В классе события EventName
укажем канал
public function broadcastOn() {
  return new PrivateChannel('users.'.$this->user->id);
}

Укажем как авторизовывать приватные каналы
в routes/channels.php

Прослушиваем событие
метод private для приватных каналов
метод listen прослушивает событие EventName

Echo.private(`users.${userId}`)
  .listen('EventName', (event) => {
    console.log(event);
});
--------------------

Класс события EventName, метод broadcastOn
должен возвращать канал или массив каналов

public function broadcastOn() {

  публичный канал
  return new Channel('users.' . $this->user->id);
  
  приватный канал
  return new PrivateChannel('users.' . $this->user->id);
  
  канал присутствия
  return new PresenceChannel('users.' . $this->user->id);
}

--------------------

Название вещания

по умолчанию равно имени класса EventName

задать свой в классе события
public function broadcastAs() {
  return 'server.created';
}

.listen('.server.created', function (event) {});
--------------------

Данные для вещания

модель User передается в js как массив
можно дополнительно добавить данные

public function broadcastWith() {
  return ['data' => $data];
}
--------------------

Очередь и Соединение для События

Событие помещается в очередь по умолчанию в соединение по умолчанию, определенное в конфиге:
queue.php

Задать свои очередь и соединение, в классе События
public $connection = 'redis';
public $queue = 'default';
--------------------

Запустить событие в очередь sync

Событие отправится сразу, без постановки в очередь
Класс события должен реализовать интерфейс ShouldBroadcastNow, вместо ShouldBroadcast

class EventName implements ShouldBroadcastNow {}
--------------------

Вещание по условию

public function broadcastWhen() {
  return false | true;
}
--------------------

Авторизация приватных каналов

Роуты для авторизации приватных каналов
в BroadcastServiceProvider.php

Это создаст роут /broadcasting/auth в группе МВ 'web'
Broadcast::routes();
Broadcast::routes($attributes);

Можно поменять роут /broadcasting/auth
window.Echo = new Echo({
  broadcaster: 'pusher',
  authEndpoint: '/broadcasting/auth2'
});

Логика авторизации
в routes/channels.php

Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
  return (int)$user->id === (int)$id;
});

можно передать зависимости
Broadcast::channel('App.Models.User.{id}', function (User $user, Order $order) {});

Назначить гуарды

Broadcast::channel('channel', function () {}, ['guards' => ['web', 'admin']]);
--------------------

Каналы на основе замыкания

в routes/channels.php
--------------------

Каналы на основе классов

Создать канал
php artisan make:channel ChannelName

Папка каналов
App/Broadcasting

Регистрация канала
в routes/channels.php
Broadcast::channel('users.{user}', ChannelName::class);

Логика авторизации в методе join
public function join(User $user, Order $order) {
  return $user->id === $order->user_id;
}
--------------------

Вещание события

Класс События должен быть с интерфейсом ShouldBroadcast
Событие ставится в очередь

Отправить событие
EventName::dispatch($user));

Отправить событие "всем другим"
broadcast(new EventName($user))->toOthers();

Номер сокета соединения в Laravel Echo
var socketId = Echo.socketId();

в Axios номер сокета автоматически передается из заголовка X-Socket-ID со всеми запросами к серверу
--------------------

Прослушивание события

метод .channel получает публичный канал
метод .private получает приватный канал
метод .listen прослушивает событие

Echo.channel(`users.${this.user.id}`)
  .listen('EventName', (event) => {
    console.log(event.user.name);
});


Прослушивание нескольких событий на 1 канале
Echo.private(`users.${this.user.id}`)
  .listen(...)
  .listen(...)
  .listen(...);
--------------------

Покинуть канал
Echo.leaveChannel(`users.${this.user.id}`);

Покинул канал и связанные каналы
Echo.leave(`users.${this.user.id}`);
--------------------

Пространство имен для классов Событий

По умолчанию
App\Events

Задать своё
window.Echo = new Echo({
  broadcaster: 'pusher',
  namespace: 'App.Events2'
});

Указывать полный путь
Echo.channel('orders')
  .listen('.Namespace\\Event\\Class', (e) => {
});
--------------------

Каналы присутствия

каналы присутствия являются приватными
но все знают кто подписан на канал
для создания комнат в чате

далее пропустил
--------------------

События на клиенте

Создать событие
Echo.private(`chat.${roomId}`)
  .whisper('typing', {
    name: this.user.name
});

Прослушать событие
Echo.private(`chat.${roomId}`)
  .listenForWhisper('typing', (event) => {
    console.log(event.name);
});
--------------------

Уведомления

это связь вещания событий с Уведомлениями
для создания уведомлений без обновления страницы

соответствующий раздел Уведомлений
https://laravel.com/docs/8.x/notifications#broadcast-notifications

Echo.private(`App.Models.User.${userId}`)
  .notification((notification) => {
    console.log(notification.type);
});
-------------------------------------------------

WEBSOCKETS

Вебсокеты это постоянный канал браузер<->сервер
Браузер и сервер друг другу асинхронно отправляют сообщения

Вебсокеты работают по протоколу WS, он похож на HTTP
Урлы ws:// или wss://
Порты 80 и 443

Сначала установка соединения по HTTP GET запросу (заголовки upgrade: websocket, уникальный ключ)
Ответ сервера будет HTTP с кодом 101 (заголовки upgrade: websocket, уникальный ключ)
Потом устанавливается прямое TCP соединение между браузером и сервером

Для поддержания соединения используются запросы ping-pong (кадры типа ping, pong)

Данные передаются кадрами (фреймами). Типы кадров: текстовые, бинарные, управляющие
Заголовки сокетов передаются в бинарном нетекстовом виде
Соединение разрывается любой из сторон, передачей управляющего кадра close
--------------------

1. Laravel-websockets

это сервер вебсокетов на php, на основе библиотеки Ratchet
сервер вебсокетов это Ratchet на порту 6001
это альтернатива использованию Node.JS и Javascript
в нём реализован протокол сервиса Pusher и Pusher API
он заменяет платный Pusher
по умолчанию вещание событий из Ларавел идёт на платные сервера Pusher
канал присутствия не позволяет отправку сообщений, только уведомляет присутствует ли пользователь на канале

Установить
composer require beyondcode/laravel-websockets

Установится
beyondcode/laravel-websockets
cboden/ratchet
evenement/evenement
paragonie/random_compat
paragonie/sodium_compat
pusher/pusher-php-server
ratchet/rfc6455
react/cache
react/dns
react/event-loop
react/http
react/promise
react/promise-stream
react/promise-timer
react/socket
react/stream
ringcentral/psr7
symfony/psr-http-message-bridge


Опубликовать миграцию
будет создан файл миграции 0000_00_00_000000_create_websockets_statistics_entries_table.php

php artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="migrations"

Накатить миграцию
будет создана таблица для статистики для панели отладки вебсокетов websockets_statistics_entries

php artisan migrate

Опубликовать конфиг
будет создан файл config\websockets.php

php artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="config"


Настройки

Драйвер вещания
в .env BROADCAST_DRIVER=pusher

Сервер вебсокетов куда будут вещаться события
в config/broadcasting.php

'host' => '127.0.0.1',
'port' => 6001,
'scheme' => 'http'

Настройки SSL
в /config/websockets.php в блоке 'ssl'
в config/broadcasting.php в блоке 'pusher' => 'scheme' => 'https'

Авторизация в Puser
в .env добавить любые данные
PUSHER_APP_ID=123
PUSHER_APP_KEY=123
PUSHER_APP_SECRET=123

Поддержка сообщений клиент<->клиент
сообщения вебсокетов работают как клиент->сервер->другие клиенты
прямая связь клиент<->клиент используется вместо отправки событий на сервер, для событий типа "юзер печатает..."
в /config/websockets.php 'enable_client_messages' => true

Включить статистику
в /config/websockets.php
'enable_statistics' => true

Очистить статистику
php artisan websockets:clean

Панель отладки
https://beyondco.de/docs/laravel-websockets/debugging/dashboard

урл панели отладки
/laravel-websockets
изменить в config/websockets.php в $path на 'ru/laravel-websockets'
открыть http://domain.loc/ru/laravel-websockets

в .env должно быть
APP_ENV=local
APP_URL=http://domain.com

Установить супервизор
apt install supervisor
--------------------

2. Laravel Echo

это js библиотека на стороне браузера
реализован протокол сервиса Pusher
библиотека получает вещаемые события с сервера

Установка
npm install laravel-echo
npm install pusher-js

Настройки

Хост и порт
в resources/js/bootstrap.js

добавить
wsHost: window.location.hostname,
wsPort: 6001,

true для SSL
forceTLS: false,

отключить отправку статистики в сервис Pusher
disableStats: true,
--------------------

3. Рабочий процесс

Посмотреть роуты
php artisan route:list

Перекомпиляция ресурсов
npm run watch

Сброс кеша конфигов
php artisan config:cache

Запустить сервер вебсокетов
php artisan websockets:serve

Запустить обработчик очереди задач
php artisan queue:listen
--------------------

4. Понимание процесса

"Сервер на php (Laravel)" отправляет Сообщение на "Сервер вебсокетов (Laravel-websockets)"

Сообщение отправляется в какой-то канал
3 типа каналов: публичный, приватный, присутствия

"Либа на js (Laravel Echo)" забирает Сообщения с "Сервера вебсокетов (Laravel-websockets)"

Если канал приватный, то "Сервер вебсокетов (Laravel-websockets)" отправляет post http запрос на "Сервер на php (Laravel)" для проверки аутентификации на урл broadcasting/auth

Аутентификация канала работает на связке session + csrf


Создать событие
php artisan make:event NameEvent

Добавить к классу события, интерфейс:
ShouldBroadcast для постановки события в очередь (в таблицу jobs)
ShouldBroadcastNow для мгновенной отправки события

Событие рассылается на какой-то канал или массив каналов

Задать очередь
метод broadcastQueue()
свойство broadcastQueue
свойство queue

Задать драйвер
свойство connection

Метод broadcastAs()
задать имя вещания. или это будет имя класса NameEvent

Метод broadcastOn()
задать имя канала ChatChannel. или задать массив каналов

публичный канал return new Channel('ChatChannel');
приватный канал return new PrivateChannel('ChatChannel.' . $this->user->id);


Передача данных в событие, через публичные свойства:
public $user;
public $message;
public function __construct(User $user, $message) {
  $this->user = $user;
  $this->message = $message;
}

Передача данных в событие, через метод broadcastWith()


Отправляем событие
NameEvent::dispatch($user, $message);
broadcast(new NameEvent($user, $message))->toOthers(); - это проверить
event(new NameEvent($user, $message));

ID юзера на странице
<input name='user_id' type='hidden' value='{{$user->id}}'>

Слушаем публичный канал
window.Echo
  .channel('ChatChannel')
  .listen('ChatEvent', (event) => {
});

ChatChannel из метода broadcastOn()
ChatEvent из метода broadcastAs()


Слушаем приватный канал
window.Echo
  .private('ChatChannel.' + document.querySelector('form input[name=user_id]').value)
  .listen('ChatEvent', (event) => {
});

Создание роута
для урла broadcasting/auth
этот урл для post http запроса для проверки аутентификации для приватного канала
app/Providers/BroadcastServiceProvider.php
Broadcast::routes();

Проверка аутентификации для приватного канала
routes/channels.php
Broadcast::channel('ChatChannel.{id}', function ($user, $id) {
  return (int)$user->id === (int)$id;
});
--------------------

5. Панель отладки

урл
http://400.loc/ru/laravel-websockets

канал
ChatChannel

событие
App\Events\ChatEvent

нагрузка 
{
  "array": [1],
  "boolean": true,
  "string": "hello",
  "null": null,
  "number": 123,
  "object": {"a": "b"}
}

в другом окне открываем страницу чата
--------------------

6. Роуты пакета

GET|POST
broadcasting/auth
Illuminate\Broadcasting\BroadcastController@authenticate 
web

GET
laravel-websockets
BeyondCode\LaravelWebSockets\Dashboard\Http\Controllers\ShowDashboard  
web, BeyondCode\LaravelWebSockets\Dashboard\Http\Middleware\Authorize

GET
laravel-websockets/api/{appId}/statistics
BeyondCode\LaravelWebSockets\Dashboard\Http\Controllers\DashboardApiController@getStatistics
web, BeyondCode\LaravelWebSockets\Dashboard\Http\Middleware\Authorize

POST
laravel-websockets/auth
BeyondCode\LaravelWebSockets\Dashboard\Http\Controllers\AuthenticateDashboard
web, BeyondCode\LaravelWebSockets\Dashboard\Http\Middleware\Authorize

POST
laravel-websockets/event
BeyondCode\LaravelWebSockets\Dashboard\Http\Controllers\SendMessage
web, BeyondCode\LaravelWebSockets\Dashboard\Http\Middleware\Authorize

POST
laravel-websockets/statistics
BeyondCode\LaravelWebSockets\Statistics\Http\Controllers\WebSocketStatisticsEntriesController@store
web, BeyondCode\LaravelWebSockets\Statistics\Http\Middleware\Authorize
-------------------------------------------------

DIGGING DEEPER -> CACHE

Фасад Cache
Хелпер Cache

Конфиг
config/cache.php

драйверы
Memcached, Redis, File, Database
--------------------

Драйвер Database

Schema::create('cache', function ($table) {
  $table->string('key')->unique();
  $table->text('value');
  $table->integer('expiration');
});

Создать миграцию для таблицы cache для кеша
php artisan cache:table

драйвер Memcached
https://pecl.php.net/package/memcached

конфиг config/cache.php

'memcached' => [
  [
    'host' => '127.0.0.1',
    'port' => 11211,
    'weight' => 100
  ],
];

драйвер Redis
composer predis/predis


доступ к разным хранилищам
Cache::store('file')->get('foo');
Cache::store('redis')->get('foo');
Cache::store('database')->get('foo');

получить данные
Cache::get('key');
Cache::get('key', 'defaultvalue');
Cache::get('key', function () {
  return DB::table(...)->get(); тут свою логику писать
});

проверка на наличие
if (Cache::has('key')) {}

инкремент и декремент значения
на 1 или $amount

Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);

получить данные, а если их нет то сохранить и получить
Cache::remember('users', $seconds, function () {
  return DB::table('users')->get();
});

получить данные, а если их нет то сохранить навсегда и получить
Cache::rememberForever('users', function () {
  return DB::table('users')->get();
});

получить данные и удалить
$value = Cache::pull('key');

сохранить данные
Cache::put('key', 'value'); на бесконечно
Cache::put('key', 'value', $seconds); на N секунд
Cache::put('key', 'value', now()->addMinutes(10)); на N секунд

сохранить данные, если их нет
Cache::add('key', 'value', $seconds);

сохранить данные навсегда
Cache::forever('key', 'value');

удалить данные
Cache::forget('key');

удалить, указав 0 или отрицательное значение TTL
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);

удалить все данные
Cache::flush();


хелпер Cache

получить данные
cache('key');

сохранить данные
cache(['key' => 'value'], $seconds);
cache(['key' => 'value'], now()->addMinutes(10));

функция Cache
cache()->remember('users', $seconds, function () {
  return DB::table('users')->get();
});

Теги кеша
Тегами группировать связанные элементы.
Не поддерживаются драйверами file, dynamodb, database.

сохранить
Cache::tags(['people', 'artists'])->put('John', $john, $seconds);
Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);

получить
$john = Cache::tags(['people', 'artists'])->get('John');
$anne = Cache::tags(['people', 'authors'])->get('Anne');

удалить
Cache::tags(['people', 'authors'])->flush();
Cache::tags('authors')->flush();

Атомарная блокировка
Чтобы гарантировать последовательность операций над кешем.
На драйверах memcached, dynamodb, redis, database, array.

для драйвера database

Schema::create('cache_locks', function ($table) {
  $table->string('key')->primary();
  $table->string('owner');
  $table->integer('expiration');
});

$lock = Cache::lock('foo', 10);

if ($lock->get()) {
  лок на 10сек
  $lock->release();
}

Cache::lock('foo')->get(function () {
  тут лок пока идёт работа
});

если блокировка недоступна прямо сейчас, то указать сколько секунд ждать

$lock = Cache::lock('foo', 10);

try {

  $lock->block(5);
  тут код если блокировка получена

} catch (LockTimeoutException $e) {

  блокировка не получена

} finally {

  optional($lock)->release();

}

Cache::lock('foo', 10)->block(5, function () {
  тут код если блокировка получена
});

Поставить блокировку в одном процессе а снять в другом
$this->owner токен

1 процесс
$podcast = Podcast::find($id);
$lock = Cache::lock('foo', 120);

if ($result = $lock->get()) {
  ProcessPodcast::dispatch($podcast, $lock->owner());
}

2 процесс
Cache::restoreLock('foo', $this->owner)->release();

снять блокировку без токена
Cache::lock('foo')->forceRelease();

Свой драйвер кеша

реализовать контракт Contracts\Cache\Store

зарегать драйвер
Cache::extend('mongo', function ($app) {
  return Cache::repository(new MongoStore);
});

События кеша
CacheHit, CacheMissed, KeyForgotten, KeyWritten
-------------------------------------------------

DIGGING DEEPER -> COLLECTIONS

Класс Support\Collection для работы с массивами.
Хелпер Collect.
Коллекции неизменяемы, каждый метод возвращает новый инстанс коллекции, исходный массив не изменяется.
Модели Eloquent возвращают коллекции.

создать коллекцию
$collection = collect([1, 2, 3]);

В класс Collection можно на лету внедрять свои методы. Расширим коллекцию новым методом

Collection::macro('toUpper', function () {
  return $this->map(function ($value) {
    return Str::upper($value);
  });
});

$collection = collect(['first', 'second']);
$upper = $collection->toUpper();


Методы коллекций

all() - вернет базовый массив
average(), avg() - вернет среднее значение, можно по ключу

chunk() - разбивает на несколько мелких коллекций
collapse() - сливает коллекции в одну коллекцию
combine() - сливает ключи одной коллекции, со значениями другой коллекции
collect() - возвращает новый инстанс Collection. копию из А в Б
concat() - добавляет массив или коллекцию, в конец существующей коллекции
contains(), containsStrict() - определяет, есть ли в коллекции значение, или пара ключ-значение. строго и нестрого
count() - колво элементов коллекции
countBy() - колво вхождений каждого значения в коллекцию
crossJoin() - декартово произведение всех вариантов

dd() - как var_dump(); exit
dump() - как var_dump()
diff() - вернет значения из первой коллекции, которых нет во второй коллекции
diffAssoc() - вернет пары ключи-значения из первой коллекции, которых нет во второй коллекции
diffKeys() - вернет пары ключи-значения из первой коллекции, которых нет во второй коллекции. сравнение на основе ключей
duplicates(), duplicatesStrict() - возвращает дубли из коллекции. вместе с ключами. массив будет ассоциативный. строго и нестрого

each() - перебор элементов коллекции
eachSpread() - перебор элементов коллекции когда элементы это подмассивы
every() - проверит что ВСЕ элементы обладают критерием истинности. для пустой коллекции вернет true
except() - вернет коллекцию, за исключением указанных ключей

filter() - фильтрует коллекцию и возращает коллекцию в которой элементы проходят критерий истинности
first() - вернет первый элемент, проходящий критерий истинности
firstWhere() - вернет первую пару ключ-значение, проходящую критерий истинности
flatMap() - перебирает коллекцию и может изменять элемент, возвращая новую коллекцию измененных элементов
flatten() - многомерную коллекцию сглаживает в одну плоскую
flip() - меняет местами ключи и значения
forget() - удаляет элемент по ключу. модифицирует коллекцию. а не возвращает новую
forPage() - разбивает коллекцию. N номер страницы, M колво элементов

get() - получить элемент коллекции по ключу
groupBy() - группировка коллекций по ключу

has() - проверяет есть ли элемент/элементы в коллекции

implode() - объединяет коллекции в коллекции
intersect() - удалит всё из первой коллекции, чего нет во второй коллекции. сохраняя ключи
intersectByKeys() - удалит всё из первой коллекции, каких ключей нет во второй коллекции
isEmpty() - проверка что коллекция пуста
isNotEmpty() - проверка что коллекция НЕпуста

join() - сливает коллекцию со строкой

keyBy() - собирает коллекции по ключу и соответствующие значения делает ключами
keys() - вернет все ключи коллекции

last() - возвращает последний элемент, соответствующий критерию истинности

macro() - расширяет коллекции. позволяет добавить новый метод в коллекцию (класс Collection), на лету
make() - создает новый инстанс коллекции
map() - обходит коллекцию и передает каждый элемент в колбек. колбек модифицирует и возвращает, образуя новую коллекцию измененных элементов. не изменяет вызываемую коллекцию. возвращает новую. как большинство методов тут.
mapInto() - обходит коллекцию, передавая значение в конструктор класса
mapSpread() - обходит коллекцию, передавая значение в колбек, в котором можно изменить и вернуть. создавая новую коллекцию
mapToGroups() - группировка в колбеке
mapWithKeys() - группировка в колбеке
max() - вернет максимальное значение по выборке по ключу
median() - вернет медианное значение по выборке по ключу
merge() - сливает коллекции. если ключи совпадают то перезапишет. если ключи цифровые то просто добавит всю коллекцию в конец оригинальной коллекции
mergeRecursive() - рекурсивно сливает коллекции. если ключи совпадают то будет создан подмассив значений с этим ключом
min() - вернет минимальное значение по выборке по ключу
mode() - вернет самое "частое" значение

nth() - создаст коллекцию, состоящую из каждого N-го элемента

only() - вернет коллекцию с заданными ключами

pad() - заполняет массив элементами до заданного размера. аналог PHP array_pad
partition() - отделить элементы прошедшие проверку критерием истинности, от остальных
pipe() - обходит коллекцию и возвращает результат
pluck() - извлекает в массив все значения для заданного ключа
pop() - удаляет и возвращает последний элемент коллекции
prepend() - добавляет элемент в начало коллекции
pull() - удаляет и возвращает элемент из коллекции по ключу
push() - добавляет элемент в конец коллекции
put() - добавит ключ и значение в коллекцию

random() - возвращает случайный элемент коллекции
reduce() - уменьшает коллекцию к одному значению, передавая результат каждой итерации в следующую итерацию
reject() - фильтрует коллекцию через колбек. если колбек вернет true то элемент удаляется
replace(), replaceRecursive() - аналог merge, перезаписывает элементы с одинаковыми строковыми и числовыми ключами
reverse() - меняет порядок элементов, сохраняя ключи

search() - поиск значения в коллекции, возвращает ключ
shift() - удаляет и возвращает первый элемент из коллекции
shuffle() - рандомно перемешивает
skip() - возвращает новую коллекцию без первых N членов. вырезает от начала и до N
skipUntil() - возвращает новую коллекцию c членами которые прошли критерий истины
skipWhile() - пропустит элементы для которых колбек true и вернет новую коллекцию
slice() - возвращает часть коллекции, начиная от заданного индекса. сохранит ключи
some() - псевдоним contains()
sort() - сортировка коллекции. сохраняет ключи. аналог PHP uasort
sortDesc() - как sort() но в обратном порядке
sortBy() - сортирует коллекцию по ключу. сохраняет ключи
sortByDesc() - как sortBy() но в обратном порядке
sortKeys() - сортировка на основе ключей
sortKeysDesc() - как sortKeys() но в обратном порядке
splice() - возвращает срез начиная с указанного индекса
split() - разбивает на подмассивы
sum() - сумма всех элементов

take() - вернет новую коллекцию с заданным числом элементов
takeUntil() - возвращает элементы пока колбек true (или false? судя по коду - false)
takeWhile() - возвращает элементы пока колбек false
tap() - позволяет внедриться между методами и что-то сделать с коллекцией, не затрагивая саму коллекцию
times() - создает новую коллекцию вызывая колбек N раз
toArray() - конвертит коллекцию и вложенные объекты - в массив PHP
toJson() - конвертит коллекцию в JSON
transform() - обходит коллекцию и вызывает колбек на каждый элемент. элементы будут изменены. изменяет саму коллекцию

union() - сливает коллекции. если во второй коллекции есть такие же ключи как в первой. то останется то, что в первой
unique(), uniqueStrict() - возвратит уникальные элементы. ключи будут сохранены. сравнение строго и нестрого
unless() - колбек будет выполняться до тех пор, пока первый аргумент будет true. when() - обратный для unless()
unlessEmpty() - аналог whenNotEmpty()
unlessNotEmpty() - аналог whenEmpty()
unwrap() - передали значения, получили коллекцию

values() - сбросит ключи

when() - колбек будет выполняться до тех пор, пока первый аргумент будет true. unless() - обратный для when()
whenEmpty() - колбек будет выполняться пока коллекция пустая. whenEmpty() - обратный для whenNotEmpty()
whenNotEmpty() - колбек будет выполняться пока коллекция Непустая. whenNotEmpty() - обратный для whenEmpty()
where(), whereStrict() - фильтрует коллекцию с помощью пары ключ-значение. строго и нестрого
whereBetween() - диапазон
whereIn(), whereInStrict() - вхождения. строго и нестрого
whereInstanceOf() - фильтрует по классу
whereNotBetween() - фильтрует вне приделов диапазона
whereNotIn(), whereNotInStrict() - фильтрует Невхождения. строго и нестрого
whereNotNull() - фильтрует на Неравенство NULL
whereNull() - фильтрует на равенство NULL
wrap() - делает из значения коллекцию

zip() - слияние значений массива со значениями коллекции в соответствующих индексах

Методы высокого порядка
это методы, внутри которых цикл.

average, avg, contains, each, every, filter, first, flatMap, groupBy, keyBy, map, max, min, partition, reject, skipUntil, skipWhile, some, sortBy, sortByDesc, sum, takeUntil, takeWhile, unique.

User::where('votes', '>', 500)->get();
$users->each->markAsVip(); вызовет метод markAsVip() для каждого объекта в коллекции

User::where('group', 'Development')->get();
$users->sum->votes; вызовет метод votes() для каждого объекта в коллекции

Ленивые коллекции
Основаны на генераторах PHP.
Чтобы работать с большими коллекциями без потребления памяти.
Перерабатывая массив частями.

Создать ленивую коллекцию
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {
    yield $line;
  }
});

Прочитать 10к моделей Eloquent

1. используя обычные коллекции
1 запрос к бд и получение всех объектов

App\User::all()->filter(function ($user) {
  return $user->id > 500;
});

2. используя ленивые коллекции.
1 запрос к бд, но получение по 1 объекту
потом запускается filter()

$users = App\User::cursor()->filter(function ($user) {
  return $user->id > 500;
});

foreach ($users as $user) {
  echo $user->id;
}

Почти все методы класса Collection доступны для LazyCollection класса.
Кроме методов которые изменяют саму коллекцию (shift, pop, prepend, итд)

Отдельные методы ленивых коллекций
tapEach() - аналог each()
remember() - вернет новую ленивую коллекцию которая будет помнить все значения которые уже были перечислены
-------------------------------------------------

DIGGING DEEPER -> EVENTS

На 1 событие N слушателей
шаблон Observer (наблюдатель)
хелпер Event
слушатели разрешаются через СК, поэтому любые зависимости

Папка событий (СОБ)
app/Events

Папка слушателей (СЛУ)
app/Listeners
--------------------

Регистрация СОБ и СЛУ

1. в EventServiceProvider.php в массиве
$listen = [
  'EventName' => ['ListenerName']
];
ключи это СОБ, значения это СЛУ

2. в EventServiceProvider.php в методе
public function boot() {

  на базе класса
  Event::listen(EventName::class, [ListenerName::class, 'handle']);
  
  на базе замыкания
  Event::listen(function (EventName $event) {});
  
  слушать много СОБ одним СЛУ
  Event::listen('event.*', function ($eventName, array $data) {});
  
  поставить в очередь
  Event::listen(queueable(function (EventName $event) {}));
  
  задать соединение и очередь
  Event::listen(queueable(function (EventName $event) {})
    ->onConnection('connectionName')
	->onQueue('queueName')
	->delay(now()->addSeconds(10)));

  если задача не выполнена
  Event::listen(queueable(function (EventName $event) {})
    ->catch(function (EventName $event, Throwable $e) {
	  queued listener failed
	}));
}

3. в EventServiceProvider.php включить автоматическое обнаружение
public function shouldDiscoverEvents() {
  return true;
}
сканируется папка СОБ и СЛУ. можно добавить свою папку СЛУ
--------------------

Посмотреть все СОБ и СЛУ

php artisan event:list
--------------------

Создать СОБ и СЛУ
1. сначала вбить в EventServiceProvider.php
2. потом php artisan event:generate

Создать СОБ
php artisan make:event EventName

Создать СЛУ
php artisan make:listener ListenerName --event=EventName
--------------------

На продакшене

Создать кеш списка событий и слушателей
php artisan event:cache

Удалить кеш списка событий и слушателей
php artisan event:clear
--------------------

Класс События
это контейнер данных, который держит нужные событию, данные

Класс Слушателя
получает объект События, в своём методе handle
--------------------

Остановить распространение СОБ среди других СЛУ

в СЛУ в методе handle() вернуть false
--------------------

СЛУ в очереди

класс СЛУ должен реализовать интерфейс ShouldQueue
--------------------

Настройка очереди

в классе СЛУ свойства: $connection, $queue, $delay
--------------------

Задать очередь на лету

public function viaQueue() {
  return 'listeners';
}
--------------------

Поставить в очередь по условию

public function shouldQueue(EventName $event) {
  return true | false;
}
--------------------

Получить доступ к очереди вручную

методы delete, release
--------------------

Обработка неудачных задач

public function failed(EventName $event, $exception) {}
--------------------

Максимальное колво попыток выполнить задачу

в классе СЛУ
public $tries = 5;
--------------------

Максимальное время в течении которого будут попытки

public function retryUntil() {
  return now()->addMinutes(N);
}
--------------------

Отправка события

EventName::dispatch($user);
event(new EventName($user));
--------------------

Подписчики на события

класс Подписчика
в котором много методов-подписчиков на разные события
чтобы несколько СЛУ были в 1 классе
класс подписчика регистрировать в EventServiceProvider.php в $subscribe
-------------------------------------------------

DIGGING DEEPER -> FILE STORAGE

Абстракция файловой системы
на основе либы PHP Flysystem

Конфиг
config/filesystems.php

хелпер Asset
Фасад Storage

Диски
local, public, s3

Драйвера
local, s3

Места хранения
storage_path('app'), storage_path('app/public')
	
Папка публичного доступа
storage/app/public

Символическая ссылка public/storage => storage/app/public
php artisan storage:link

Символические ссылки в конфиге
'links' => [
  public_path('storage') => storage_path('app/public'),
  public_path('images') => storage_path('app/images'),
];

Вывести в шаблоне
<img src="{{asset('storage/'. $brand->file)}}">
<img src="{{Storage::url($brand->file)}}">
						

драйвер Local
все операции проводятся относительно root установленного в конфиге
по умолчанию это storage/app
пермишены на папки 0755 на файлы 0644. настраивается в конфиге

Storage::disk('local')->put('file.txt', 'Contents');

драйверы FTP, SFTP, Amazon S3
примеры конфигов в мане

composer league/flysystem-sftp
composer league/flysystem-aws-s3-v3
composer league/flysystem-cached-adapter - для увеличения производительности

Кеширование для диска
настройки конфига: cache, disk, expire, prefix

Частые процедуры

сохранить
Storage::put('avatars/1', $fileContents); на диск по умолчанию
Storage::disk('s3')->put('avatars/1', $fileContents); на выбранный диск

получить
Storage::get('file.jpg');
Storage::disk('s3')->exists('file.jpg'); проверка на наличие
Storage::disk('s3')->missing('file.jpg'); проверка на отсутствие

скачать
Storage::download('file.jpg');
Storage::download('file.jpg', $name, $headers); $name имя файла которое увидит юзер

урлы файлов
Storage::url('file.jpg');

временные урлы файлов для Amazon S3

Storage::temporaryUrl(
  'file.jpg', now()->addMinutes(5),
  ['ResponseContentType' => 'application/octet-stream']
);

урл хоста
в конфиге 'url' => env('APP_URL').'/storage'

размер файла
Storage::size('file.jpg');
Storage::lastModified('file.jpg');

сохранить
Storage::put('file.jpg', $contents);
Storage::put('file.jpg', $resource); с поддержкой потока

потоковый стриминг
Storage::putFile('photos', new File('/path/to/photo')); сгенерит уникальное имя и расширение на основе MIME
Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg'); указать своё имя
Storage::putFile('photos', new File('/path/to/photo'), 'public'); указать видимость для Amazon S3

писать в файл в начало или конец
Storage::prepend('file.log', 'Prepended Text');
Storage::append('file.log', 'Appended Text');

копирование и перемещение
Storage::copy('old/file.jpg', 'new/file.jpg');
Storage::move('old/file.jpg', 'new/file.jpg');

загрузка файла
Storage::putFile('avatars', $request->file('avatar')); сгенерит уникальное имя и расширение на основе MIME
или
$request->file('avatar')->store('avatars'); сгенерит уникальное имя и расширение на основе MIME

указать своё имя файла
Storage::putFileAs('avatars', $request->file('avatar'), $request->user()->id);
$request->file('avatar')->storeAs('avatars', $request->user()->id);

удалить непечатаемые и недопустимые символы из путей и имен файлов
League\Flysystem\Util::normalizePath

указать диск при сохранении

$request->file('avatar')->store(
  'avatars/'.$request->user()->id,
  's3'
);

$request->file('avatar')->storeAs(
  'avatars',
  $request->user()->id,
  's3'
);

оригинальное имя и расширение загруженного файла
$request->file('avatar')->getClientOriginalName();
$request->file('avatar')->extension();

Видимость файла
это абстракция за которой простой пермишен ФС
public, private

Storage::put('file.jpg', $contents, 'public'); установить при сохранении
Storage::getVisibility('file.jpg'); получить для уже сохраненных
Storage::setVisibility('file.jpg', 'public'); установить для уже сохраненных

сохранить с видимостью public

$request->file('avatar')->storePublicly('avatars', 's3');

$request->file('avatar')->storePubliclyAs(
  'avatars',
  $request->user()->id,
  's3'
);

удалить файлы
Storage::delete('file.jpg');
Storage::delete(['file.jpg', 'file2.jpg']);
Storage::disk('s3')->delete('folder_path/file_name.jpg'); с указанием диска

получить файлы в папке
Storage::files($directory); только файлы
Storage::allFiles($directory); файлы из подпапок тоже

получить папки в папке
$directories = Storage::directories($directory); папки
$directories = Storage::allDirectories($directory); папки из подпапок тоже

создать папку
Storage::makeDirectory($directory);

удалить папку
Storage::deleteDirectory($directory);

Свой адаптер
например dropbox
composer require spatie/flysystem-dropbox

создать СП

public function boot() {
  Storage::extend('dropbox', function ($app, $config) {
    $client = new DropboxClient(
      $config['authorization_token']
    );
  return new Filesystem(new DropboxAdapter($client));
  });
}

зарегать СП в config/app.php
прописать драйвер в config/filesystems.php
-------------------------------------------------

DIGGING DEEPER -> HELPERS

Хелперы - это глобальные вспомогательные функции

Массивы и Объекты

Arr::accessible - проверка что это массив
Arr::add - добавить в массив новую пару ключ-значение если данный ключ не существует
Arr::collapse - сливает массивы в один массив
Arr::crossJoin - сливает массивы возвращая декартово произведение всех возможных вариантов
Arr::divide - разбивает массив на массив ключей и массив значений
Arr::dot - сливает многомерный массив в одиномерный массив используя точку
Arr::except - удаляет из массива пару ключ-значение, по ключу
Arr::exists - проверяет что ключ существует в массиве
Arr::first - вернет первый элемент, прошедший критерий истины, если не нашел то вернет значение по умолчанию
Arr::flatten - сливает многомерный массив в одиномерный массив (забирает все значения)
Arr::forget - удаляет пару ключ-значение, по ключу. использует точку как глубину захода в подмассивы
Arr::get - получает значение, по ключу. использует точку как глубину захода в подмассивы, если не нашел то вернет значение по умолчанию
Arr::has - проверяет, существует ли элемент, или ВСЕ переданные элементы
Arr::hasAny - проверяет, существует ли ЛЮБОЙ элемент, в переданных элементах
Arr::isAssoc - проверяет что массив ассоциативный
Arr::last - вернет последний элемент, прошедший критерий истины, если не нашел то вернет значение по умолчанию
Arr::only - вернет только указанные пары ключ-значение, по ключам
Arr::pluck - извлекает все значения, по ключу. из подмассивов. в итоговом массиве ключами могут быть другие значения
Arr::prepend - добавить элемент или пару ключ-значение, в начало массива
Arr::pull - возвращает и удаляет пару ключ-значение, по ключу. если ключа нет то вернет значение по умолчанию
Arr::query - преобразует массив в строку запроса query string
Arr::random - возвращает случайное значение из массива. можно указать колво возвращаемых значений
Arr::set - установка значения, по ключу. используя точку чтобы добраться вглубь вложенных подмассивов
Arr::shuffle - рандомно перемешать
Arr::sort - сортировка по значению. сортировка в Замыкании
Arr::sortRecursive - рекурсивная сортировка
Arr::where - фильтрует массив используя Замыкание
Arr::wrap - оборачивает значение в массив

data_fill - заполняет значениями, по ключу, используя точки. внутри подмассивов. если его там нет. если есть то не перезапишет
data_get - извлекает значения, по ключу, используя точки. внутри подмассивов. если ключ не найден, вернет значение по умолчанию
data_set - заполняет значениями, по ключу, используя точки. внутри подмассивов. если оно там есть то перезапишет. если заполнить только то, что не существует, то 4й аргумент в false

head - вернет первый элемент массива
last - вернет последний элемент массива


Пути

app_path - путь до /app
base_path - путь до /domain.loc
config_path - путь до /config
database_path - путь до /database
mix - путь до mix файла
public_path - путь до /public
resource_path - путь до /resources
storage_path - путь до /storage

Строки

__ - перевод строки из языкового файла. по ключу или фразе
class_basename - вернет имя класса удалив неймспейс
e - запускает PHP htmlspecialchars с double_encode в true
preg_replace_array - последовательная замена в строке по шаблону регулярки, но замены в виде массива

Str::after - в строке вернёт всё, после указанной подстроки
Str::afterLast - в строке вернёт всё, после последнего вхождения указанной подстроки
Str::ascii - строку в ASCII
Str::before - в строке вернёт всё, до указанной подстроки
Str::beforeLast - в строке вернёт всё, до последнего вхождения указанной подстроки
Str::between - вернет часть строки между двумя подстроками
Str::camel - преобразует camel_case в CamelCase
Str::contains - проверит содержит ли строка, подстроку (или любую подстроку из массива подстрок). регистр важен
Str::containsAll - проверит содержит ли строка, все подстроки из массива подстрок. регистр важен
Str::endsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), концом строки
Str::finish - добавит в конец строки, подстроку. если ее еще там нет
Str::is - проверяет, соответствует ли строка, шаблону. в шаблоне есть знак *
Str::isAscii - проверит является ли строкой 7 bit ASCII
Str::isUuid - проверит является ли строка UUID
Str::kebab - преобразует CamelCase в camel-case
Str::length - длинна строки
Str::limit - обрежет строку до N символов. может добавить в конец троеточие
Str::lower - строку в нижний регистр
Str::orderedUuid - генерирует timestamp first UUID
Str::padBoth - на основе PHP str_pad. оборачивает строку, подстроками с двух сторон
Str::padLeft - на основе PHP str_pad. оборачивает строку, подстроками слева
Str::padRight - на основе PHP str_pad. оборачивает строку, подстроками справа
Str::plural - преобразует единственное число во множественное. работает только для англ. можно передать колво объектов для правильности
Str::random - случайная строка заданной длинны. на основе PHP random_bytes
Str::replaceArray - заменяет заполнители (?) в строке, последовательно, используя массив подстрок для замен
Str::replaceFirst - заменяет первое вхождение в строке, на подстроку
Str::replaceLast - заменяет последнее вхождение в строке, на подстроку
Str::singular - преобразует множественное число в единственное. работает только для англ
Str::slug - генерирует слуг (slug) из строки. можно указать разделитель для слов
Str::snake - преобразует CamelCase в camel_case
Str::start - добавляет подстроку в начало, в строке. если этой подстроки там нет
Str::startsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), началом строки
Str::studly - преобразует camel_case в CamelCase
Str::substr - возвращает часть строки с индекса N и длинной M
Str::title - делает все слова строки с большой буквы
Str::ucfirst - делает первый символ строки с большой буквы
Str::upper - делает все символы большими
Str::uuid - генерирует UUID версии 4
Str::words - обрежет строку до N слов. может добавить в конец троеточие

trans - перевод строки из языкового файла. по ключу
trans_choice - перевод строки из языкового файла с интонацией (числом для глаголов множественного числа). по ключу

Свободные строки
ООП интерфейс с цепочками вызовов

after - в строке вернёт всё, после указанной подстроки
afterLast - в строке вернёт всё, после последнего вхождения указанной подстроки
append - добавит подстроку к строке, с конца
ascii - строку в ASCII

basename - вернет имя класса удалив неймспейс, или просто последнюю часть из строки а/b/c, или указанную подстроку
before - в строке вернёт всё, до указанной подстроки
beforeLast - в строке вернёт всё, до последнего вхождения указанной подстроки

camel - преобразует camel_case в CamelCase
contains - проверит содержит ли строка, подстроку (или любую подстроку из массива подстрок). регистр важен
containsAll - проверит содержит ли строка, все подстроки из массива подстрок. регистр важен

dirname - вернет родительскую папку, из строки которая является путем. можно указать какую родительскую папку по уровню вернуть

endsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), концом строки
exactly - проверит равны ли строки
explode - разбивает строку по разделителю, в массив (коллекцию)

finish - добавит в конец строки, подстроку. если ее еще там нет

is - проверяет, соответствует ли строка, шаблону. в шаблоне есть знак *
isAscii - проверит является ли строкой 7 bit ASCII
isEmpty - проверка что пустая строка
isNotEmpty - проверка что Непустая строка

kebab - преобразует CamelCase в camel-case

length - длинна строки
limit - обрежет строку до N символов. может добавить в конец троеточие
lower - строку в нижний регистр
ltrim - обрежет строку слева от пустых символов, или указанных символов

match - возвратит подстроку, которая соответствует регулярке
matchAll - возвратит массив подстрок, которые соответствует регулярке

padBoth - на основе PHP str_pad. оборачивает строку, подстроками с двух сторон
padLeft - на основе PHP str_pad. оборачивает строку, подстроками слева
padRight - на основе PHP str_pad. оборачивает строку, подстроками справа
plural - преобразует единственное число во множественное. работает только для англ. можно передать колво объектов для правильности
prepend - добавить подстроку, в начало строки

replace - заменяет подстроку на подстроку
replaceArray - заменяет заполнители (?) в строке, последовательно, используя массив подстрок для замен
replaceFirst - заменяет первое вхождение в строке, на подстроку
replaceLast - заменяет последнее вхождение в строке, на подстроку
replaceMatches - замена на подстроку по регулярке. может через Замыкание обрабатывая каждую подмаску
rtrim - обрежет строку справа от пустых символов, или указанных символов

singular - преобразует множественное число в единственное. работает только для англ
slug - генерирует слуг (slug) из строки. можно указать разделитель для слов
snake - преобразует CamelCase в camel_case
split - разбивает строку на массив подстрок, используя регулярки. аналог explode
start - добавляет подстроку в начало, в строке. если этой подстроки там нет
startsWith - проверит, является ли подстрока (или любая подстрока из массива подстрок), началом строки
studly - преобразует camel_case в CamelCase
substr - возвращает часть строки с индекса N и длинной M

title - делает все слова строки с большой буквы
trim - обрежет строку с обоих сторон от пустых символов, или указанных символов

ucfirst - делает первый символ строки с большой буквы
upper - делает все символы большими

when - вызывает Замыкание, если условие истинно, и другое замыкание если условие ложно
whenEmpty - вызывает Замыкание, если строка пуста. Замыкание может вернуть значение
words - обрежет строку до N слов. может добавить в конец троеточие

Урлы

action - генерирует урл для контроллер+действие+параметры роута
asset - генерирует урл для ресурса типа картинки итд. в .env установить ASSET_URL
route - генерирует абсолютный урл для именованного роута. можно передать параметры. можно относительный урл
secure_asset - генерирует урл для ресурса типа картинки итд. используя HTTPS
secure_url - генерирует полный урл HTTPS для заданного пути
url - генерирует полный урл для заданного пути. еще есть url()->current(), url()->full(), url()->previous()

Разное

abort - генерация HTTP исключения с кодом ошибки, мессагой, заголовками
abort_if - генерация HTTP исключения с кодом ошибки, мессагой, заголовками. если условие true
abort_unless - генерация HTTP исключения с кодом ошибки, мессагой, заголовками. если условие false
app - вернет инстанс СК. можно передать класс или интерфейс чтобы разрешить его
auth - вернет инстанс Auth. альтернатива фасаду Auth. можно передать гуард к которому получить доступ

back - редирект назад
bcrypt - хеширует значение. альтернатива фасаду Hash
blank - проверяет значение на пустоту
broadcast - передаёт событие, слушателям

cache - вернет значение из кеша, или значение по умолчанию. можно писать в кеш. можно указать колво секунд кеширования
class_uses_recursive - вернет все трейты для класса и родительского класса
collect - создаст коллекцию из переданных значений
config - получить или установить значение из конфига (файлов конфига) в формате имяфайла.ключ. можно значения по умолчанию
cookie - создать куку
csrf_field - генерирует скрытое html поле с токеном
csrf_token - получить токен

dd - аналог var_dump(); exit;
dispatch - добавляет задачу в очередь задач
dispatch_now - выполняет задачу немедленно
dump - аналог var_dump();

env - возвращает переменые окружения из .env
event - отправляет событие, слушателям

factory - создает модель фабрики для тестирования или посева
filled - проверяет значение на НЕпустоту

info - пишет инфу в журнал log. можно передать контекстные данные
logger - пишет инфу уровня debug в журнал log. можно передать контекстные данные
method_field - генерирует глаголы HTTP для форм в скрытое поле
now - инстанс времени Carbon для текущего времени
old - вернет старый ввод в форму, из сессии. flash ввод
optional - доступ к свойствам и методам, переданного объекта. принимает Замыкание
policy - вернет Политику переданного класса

redirect - генерация HTTP редиректа с кодом, заголовками. на путь, на именованный роут
report - сообщит об исключении используя ваш обработчик исключений
request - вернет объект запроса Request. или значение по ключу
rescue - выполнит переданное Замыкание и поймает все исключения. исключения будут переданы в ваш обработчик report()
resolve - разрешает переданный класс или интерфейс, в СК
response - создаст объект ответа Response
retry - выполняет Замыкание N раз через M сек

session - получить или установить значения сессии

tap - принимает значение и Замыкание. и внутри Замыкания манипуляции
throw_if - генерит исключение если условие true
throw_unless - генерит исключение если условие false
today - инстанс времени Carbon для текущего времени
trait_uses_recursive - вернет все трейты для трейта
transform - выполняет Замыкание для переданного значения. если значение пустое то вернет значение по умолчанию

validator - создаст инстанс Validator. альтернатива фасаду Validator
value - вернет переданное значение. или результат работы Замыкания
view - вернет инстанс View

with - вернет переданное значение. или результат работы Замыкания
-------------------------------------------------

DIGGING DEEPER -> HTTP CLIENT

API для внешних HTTP запросов
На базе Guzzle
Фасад Http

Установить
composer require guzzlehttp/guzzle

Делать запросы

Http::get('http://test.com');
Http::get('http://test.com/users/1')['name']; если возвращается JSON то сразу получить элемент массива
Http::post
Http::put
Http::patch
Http::delete

Возвращается объект ответа Response, у которого есть методы

$response->body();
$response->json();
$response->status();
$response->ok();
$response->successful();
$response->failed();
$response->serverError();
$response->clientError();
$response->header($header);
$response->headers();

Передать данные в Запрос

Http::get('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдет как application/json
Http::post('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдет как application/x-www-form-urlencoded
Http::asForm()->post('http://test.com/users', [
  'name' => 'Taylor',
  'page' => 1
]);

уйдут сырые данные
Http::withBody(
  base64_encode($photo), 'image/jpeg'
)->post('http://test.com/photo');

отправить файлы в нескольких запросах
Http::attach(
  'attachment',
  file_get_contents('photo.jpg'),
  'photo.jpg'
)->post('http://test.com/attachments');

или

Http::attach(
  'attachment',
  fopen('photo.jpg', 'r'),
  'photo.jpg'
)->post('http://test.com/attachments');

Передать заголовки в Запрос

Http::withHeaders([
  'X-First' => 'foo',
  'X-Second' => 'bar'
])->post('http://test.com/users', [
  'name' => 'Taylor'
]);

Передать аутентификацию в Запрос

basic
Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);

digest
Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);

токен
Http::withToken('token')->post(...);

Ждать ответа N сек
Http::timeout(3)->get(...);

Попыток N и ждать ответа M млс
Http::retry(3, 500)->post(...);

Обработка ошибок

$response->successful(); код >= 200 and < 300
$response->failed(); код >= 400
$response->clientError(); код 400
$response->serverError(); код 500

Выбросить исключение

$response = Http::post);
$response->throw();
return $response['user']['id'];

Опции Guzzle
http://docs.guzzlephp.org/en/stable/request-options.html

передать опции

Http::withOptions([
  'debug' => true
])->get('http://test.com/users');

Тестирование
фасад Http метод fake

Http::fake(); пустые ответы с кодом 200

Http::fake([
  'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),
  'google.com/*' => Http::response('Hello World', 200, ['Headers']),
  '*' => Http::response('Hello World', 200, ['Headers']), на все остальные адреса будет эта заглушка
]);

серия поддельных ответов

Http::fake([
  'github.com/*' => Http::sequence()
    ->push('Hello World', 200)
    ->push(['foo' => 'bar'], 200)
    ->pushStatus(404),
]);

Http::fake([
  'github.com/*' => Http::sequence()
    ->push('Hello World', 200)
    ->push(['foo' => 'bar'], 200)
    ->whenEmpty(Http::response()),
]);

Http::fakeSequence()
  ->push('Hello World', 200)
  ->whenEmpty(Http::response());

Http::fake(function ($request) {
  return Http::response('Hello World', 200);
});

Проверка данных запросов

Http::fake();

Http::withHeaders([
  'X-First' => 'foo'
])->post('http://test.com/users', [
  'name' => 'Taylor',
  'role' => 'Developer'
]);

Http::assertSent(function ($request) {
  return
    $request->hasHeader('X-First', 'foo') &&
    $request->url() == 'http://test.com/users' &&
    $request['name'] == 'Taylor' &&
    $request['role'] == 'Developer';
});

Http::assertNotSent(function (Request $request) {
  return $request->url() === 'http://test.com/posts';
});

Http::assertNothingSent();
-------------------------------------------------

DIGGING DEEPER -> MAIL

На базе либы SwiftMailer
драйверы SMTP, Mailgun, Postmark, Amazon SES, Sendmail
в шаблонах Blade
Фасад Mail

Конфиг
config/mail.php

Папка почты
app/Mail

Папка шаблонов
resources/views/emails

Для драйверов на основе Api (Mailgun, Postmark) требуется
composer require guzzlehttp/guzzle
--------------------

Mailgun
пропустил

Postmark
пропустил

Amazon SES
пропустил
--------------------

Создать класс почты
php artisan make:mail mailName

Главный метод
build

Настройка заголовков From и Reply_to
в config/mail.php
--------------------

Письмо plain text

public function build() {
  return $this->view('emails.name')->text('emails.namePlain');
}
--------------------

Данные в шаблон


1. Через публичные свойства
public function __construct(User $user) {
    $this->user = $user;
}

В шаблоне
{{$user->email}}


2. Через метод with
public function __construct(User $user) {
    $this->user = $user;
}
public function build() {
  return $this->from('support@400.loc')
    ->view('emails.signupuser')
    ->with([
      'userId' => $this->user->id,
      'userEmail' => $this->user->email,
  ]);
}

В шаблоне
{{$userId}}
{{$userEmail}}
--------------------

Вложить файл

return $this->view('emails.viewname')
  ->attach('/path/to/file');

отображаемое имя и mime тип
return $this->view('emails.viewname')
  ->attach('/path/to/file', [
    'as' => 'name.pdf',
    'mime' => 'application/pdf',
]);
--------------------

Вложить файл с диска

return $this->view('emails.viewname')
  ->attachFromStorage('/path/to/file');

отображаемое имя и mime тип
return $this->view('emails.viewname')
  ->attachFromStorage('/path/to/file', 'name.pdf', [
    'mime' => 'application/pdf'
]);

с указанием диска
return $this->view('emails.viewname')
  ->attachFromStorageDisk('s3', '/path/to/file');
--------------------

Вложить данные сгенеренные на лету

return $this->view('emails.viewname')
  ->attachData($this->pdf, 'name.pdf', [
    'mime' => 'application/pdf',
]);
--------------------

Встроить inline картинку

<img src="{{$message->embed($pathToImage)}}">
--------------------

Встроить raw data картинку

<img src="{{$message->embedData($data, 'imagename.jpg')}}">
--------------------

Глубокая настройка SwiftMailer

public function build() {
  $this->view('emails.viewname');

  пишем свой функционал до отправки
  $this->withSwiftMessage(function ($message) {
    $message->getHeaders()
      ->addTextHeader('Custom-Header', 'HeaderValue');
  });
}
--------------------

Письмо markdown

Создать класс почты markdown
php artisan make:mail mailName --markdown=emails.viewname

Это создаст еще вьюху, внутри компоненты Blade и Markdown
resources/views/emails/viewname.blade.php

Пример
public function build() {
  return $this->from('example@example.com')
    ->markdown('emails.viewname', [
	  'data'=>$data
	]);
}
--------------------

Компоненты

Кнопка

@component('mail::button', [
  'url' => $url, 
  'color' => 'success'
])
ButtonName
@endcomponent


Панель

@component('mail::panel')
PanelText
@endcomponent


Таблица

@component('mail::table')
| Laravel       | Table         | Example  |
| ------------- |:-------------:| --------:|
| Col 2 is      | Centered      | $10      |
| Col 3 is      | Right-Aligned | $20      |
@endcomponent
--------------------

Экспорт компонентов

php artisan vendor:publish --tag=laravel-mail

Появится папка
resources/views/vendor/mail
--------------------

CSS компонентов

resources/views/vendor/mail/html/themes/default.css
--------------------

Свой CSS для компонентов

resources/views/vendor/mail/html/themes/myCSS.css

в config/mail.php

'markdown' => [
  'theme' => 'myCSS'
];

Или в классе $theme = 'myCSS';
--------------------

Отправка почты

На почту
Mail::to('email@email.com')->send(new mailName($user));

На массив почт
Mail::to(['email@email.com'])->send(new mailName($user));

На объект
Mail::to($user)->send(new mailName($user));

На коллекцию объектов
Mail::to($users)->send(new mailName($user));

В объекте должны быть аттрибуты email и name
--------------------

Отправка копий

Mail::to($user)
  ->cc($users)
  ->bcc($users)
  ->send(new mailName($user));
--------------------

Отправка в цикле

foreach (['email@email1.com', 'email@email2.com'] as $recipient) {
  Mail::to($recipient)->send(new mailName($user));
}

Метод to, принимая массив почт, забирает их все и рассылает. Поэтому в цикле нужно пересоздавать объект почтового класса. Иначе будут рассылаться предыдущим в цикле.
--------------------

Отправка с драйвера

драйвер по умолчанию в config/mail.php
'default' => env('MAIL_MAILER', 'smtp')

Mail::mailer('sendmail')
  ->to($user)
  ->send(new mailName($user));
--------------------

Отложить отправку

Mail::to($user)->later(now()->addMinutes(10), new mailName($user));
--------------------

Отправка в очередь

Mail::to($user)->queue(new mailName($user));
--------------------

Отправка в очередь по имени

Mail::to($user)->queue((new mailName($user))
  ->onConnection('connectionName')
  ->onQueue('queuename'));
--------------------

Отправка в очередь всегда

добавить интерфейс ShouldQueue
class mailName1 extends Mailable implements ShouldQueue {}
--------------------

Отладка письма

вывести как строку
echo (new mailName($user))->render();

вернуть вместо вьюхи	
return new mailName($user);
--------------------

Локализация

Mail::to($user)
  ->locale('ru')
  ->send(new mailName($user));
--------------------

Локаль юзера

Сохранять локаль юзера и подставить автоматически
class User extends Model implements HasLocalePreference {
  public function preferredLocale() {
    return $this->locale;
  }
}
Mail::to($user)
  ->send(new mailName($user));
--------------------

Отладка отправки

драйвер log
--------------------

События

в EventServiceProvider.php зарегать прослушивателей событий
protected $listen = [

  до отправки
  'Illuminate\Mail\Events\MessageSending' => ['App\Listeners\LogSendingMessage'],

  после отправки
  'Illuminate\Mail\Events\MessageSent' => ['App\Listeners\LogSentMessage'],
];
-------------------------------------------------

DIGGING DEEPER -> NOTIFICATIONS

Отправка уведомлений по разным каналам
трейт Notifiable включен в модель App\Models\User
Фасад Notification

Каналы
mail, database, sms, , broadcast, nexmo, slack

Все каналы
https://laravel-notification-channels.com

Папка уведомлений
app/Notifications
--------------------

Создать уведомление
php artisan make:notification NotificationName
--------------------

Отправить уведомление

1. Через трейт Notifiable и метод notify
2. Через фасад Notification
--------------------

Указать канал

public function via($notifiable) {
  return ['mail', 'database'];
}
--------------------

Отправить в очередь

1. Настроить очередь
2. Добавить в класс интерфейс ShouldQueue и трейт Queueable

class NotificationName extends Notification implements ShouldQueue {
  use Queueable;
}
--------------------

Отложить отправку

$user->notify((new NotificationName($invoice))
  ->delay(now()->addMinutes(10)));
  
$user->notify((new NotificationName($invoice))
  ->delay([
    'mail' => now()->addMinutes(5),
    'sms' => now()->addMinutes(10),
]));
--------------------

Отправить в соединение

public $connection = 'redis';
--------------------

Отправить в канал и очередь

public function viaQueues() {
  return [
    'mail' => 'mail-queue',
    'slack' => 'slack-queue',
  ];
}
--------------------

Отправить анониму

Notification::route('mail', 'email@email.com')
  ->route('nexmo', '555')
  ->route('slack', 'https://hooks.slack.com/services')
  ->notify(new NotificationName($invoice));
--------------------

Канал mail

Вызов
$user = User::find(5);
$user->notify(new NotificationName($user, 'message'));

Конструктор
public function __construct(User $user, $message) {
  $this->message = $message;
}

Без вьюхи это всегда markdown

Метод
public function toMail($notifiable) {
  return (new MailMessage)
    ->line('Это уведомление')
    ->action('Это ссылка', url('/'))
    ->line('Это линия')
    ->line('Это переменная ' . $this->message);
}

Вьюха
public function toMail($notifiable) {
  return (new MailMessage)->view('viewname', ['data' => $data]);
}

Вьюха plain text
public function toMail($notifiable) {
  return (new MailMessage)->view(['viewname', 'viewnamePlain'],
    ['data' => $data]
  );
}

Уведомление с красной кнопкой
public function toMail($notifiable) {
  return (new MailMessage)
    ->error()
    ->subject('subject')
    ->line('text');
}

Настройка отправителя
в config/mail.php поле from
задать своё
public function toMail($notifiable) {
  return (new MailMessage)
    ->from('email@email.com', 'Example')
    ->line('text');
}

Настройка получателя
автоматически ищет в объекте поле email
задать своё в модели
public function routeNotificationForMail($notification) {
  return $this->emailAddress;
  return [$this->emailAddress => $this->name];
}

Настройка заголовка
public function toMail($notifiable) {
  return (new MailMessage)
    ->subject('Subject')
    ->line();
}

Настройка драйвера почты
по умолчанию в config/mail.php
'default' => env('MAIL_MAILER', 'smtp')
задать свой
public function toMail($notifiable) {
  return (new MailMessage)
    ->mailer('postmark')
    ->line();
}

Экспорт шаблонов уведомлений
php artisan vendor:publish --tag=laravel-notifications
Появится папка
resources/views/vendor/notifications

Вложить файл
public function toMail($notifiable) {
  return (new MailMessage)
    ->greeting('Hello')
    ->attach('/path/to/file', [
      'as' => 'name.pdf',
      'mime' => 'application/pdf',
  ]);
}

Вложить данные сгенеренные на лету
public function toMail($notifiable) {
  return (new MailMessage)
    ->greeting('Hello!')
    ->attachData($this->pdf, 'name.pdf', [
      'mime' => 'application/pdf',
  ]);
}

Отладка
return (new NotificationName($user))->toMail($user);

Уведомления markdown

Создать
php artisan make:notification NotificationName --markdown=notifications.viewname

Это создаст еще вьюху, внутри компоненты Blade и Markdown
resources/views/notifications/viewname.blade.php

Пример
public function toMail($notifiable) {
  return (new MailMessage)
    ->subject('subject')
    ->markdown('notifications.viewname', ['data' => $data]);
}

Компоненты

Компоненты как у DIGGING DEEPER -> MAIL

Экспорт компонентов

php artisan vendor:publish --tag=laravel-mail

Появится папка
resources/views/vendor/mail

CSS компонентов

resources/views/vendor/mail/html/themes/default.css

Свой CSS для компонентов

resources/views/vendor/mail/html/themes/myCSS.css

В config/mail.php

'markdown' => [
  'theme' => 'myCSS'
];

Или в классе $theme = 'myCSS';

Или в методе
public function toMail($notifiable) {
  return (new MailMessage)
    ->theme('invoice')
    ->subject('subject')
    ->markdown('notifications.viewname', ['data' => $data]);
}
--------------------

Канал database

хранит уведомления в таблице notifications
трейт Notifiable включен в модель App\Models\User

Создать миграцию для таблицы notifications
php artisan notifications:table

Накатить миграцию
php artisan migrate

Методы класса
toDatabase или toArray

toArray используется каналом broadcast
лучше использовать toDatabase

эти данные пишутся в таблицу notifications
public function toDatabase($notifiable) {
  return [
    'data' => $data
  ];
}

Получить уведомления
$user = User::find(1);
foreach ($user->notifications as $notification) {
  echo $notification->data;
}

Получить непрочитанные уведомления
поле read_at пустое
$user = User::find(1);
foreach ($user->unreadNotifications as $notification) {
  echo $notification->data;
}

Отметить уведомления как прочитанные

Перебором в цикле
$user = User::find(1);
foreach ($user->unreadNotifications as $notification) {
  $notification->markAsRead();
}

Сразу все
$user->unreadNotifications->markAsRead();

Без извлечения из бд
$user = User::find(1);
$user->unreadNotifications()->update(['read_at' => now()]);

Удалить уведомления
$user->notifications()->delete();

Отладка
return (new NotificationName($user))->toDatabase($user);
--------------------

Канал broadcast

настроить Broadcasting
работает на основе вещания событий
реагирует из js либы на серверные события
все уведомления стоят в очереди
метод toBroadcast. или будет использован резервный метод toArray
возвращает JSON

public function toBroadcast($notifiable) {
  return new BroadcastMessage([
    'data' => $data
  ]);
}
--------------------

Настроить соединение и очередь

return (new BroadcastMessage($data))
  ->onConnection('sqs')
  ->onQueue('broadcasts');
--------------------

Настроить тип уведомлений

public function broadcastType() {
  return 'broadcast.message';
}
--------------------

Прослушать уведомления

формат канала {notifiable}.{id}
для юзера App\Models\User с ID 1 это будет канал App.Models.User.1

Echo.private('App.Models.User.' + userId)
  .notification((notification) => {
    console.log(notification.type);
});
--------------------

Настроить формат канала в модели

class User extends Authenticatable {
  public function receivesBroadcastNotificationsOn() {
    return 'users.'.$this->id;
  }
}
--------------------

Канал sms

Пакет Vonage и Nexmo
composer require laravel/nexmo-notification-channel
composer require nexmo/laravel

Конфиг в .env
NEXMO_KEY, NEXMO_SECRET

Конфиг в config/services.php
'nexmo' => [
  'sms_from' => '155',
];
--------------------

Форматирование уведомлений

public function toNexmo($notifiable) {
  return (new NexmoMessage)
    ->content('SMS message');
	->unicode(); если будут символы юникода
}
--------------------

Настройка отправителя

в config/services.php поле sms_from

задать своё
public function toNexmo($notifiable) {
  return (new NexmoMessage)
    ->content('SMS message')
    ->from('177');
}
--------------------

Настройка получателя в модели

class User extends Authenticatable {
  public function routeNotificationForNexmo($notification) {
    return $this->phone_number;
  }
}
--------------------

Канал slack

Настроить Incoming Webhook

Пакет
composer require laravel/slack-notification-channel
--------------------

Отправить уведомление

public function toSlack($notifiable) {
  return (new SlackMessage)
    ->content('text');
}
--------------------

Настроить отправителя и получателя

public function toSlack($notifiable) {
  return (new SlackMessage)
    ->from('Ghost', ':ghost:') имя и эмодзи
    ->to('#bots') канал или имя
    ->image('http://domain.com/image.png') лого
    ->content('text');
}
--------------------

Вложить файл

public function toSlack($notifiable) {
  return (new SlackMessage)
    ->error()
    ->content('text')
    ->attachment(function ($attachment) use ($url) {
      $attachment->title('title', $url)
        ->content('text [background.jpg]');
  });
}
--------------------

Вложить таблицу
пропустил
--------------------

Вложить markdown
пропустил
--------------------

Роуты для уведомлений slack

class User extends Authenticatable {
  public function routeNotificationForSlack($notification) {
    return 'https://hooks.slack.com/services/webhookURL';
  }
}
--------------------

Локализация

$user->notify((new InvoicePaid($invoice))->locale('ru'));

Notification::locale('ru')->send(
    $users, new InvoicePaid($invoice)
);
--------------------

Локализация когда язык в таблице юзера

class User extends Model implements HasLocalePreference {
  public function preferredLocale() {
    return $this->locale;
  }
}

$user->notify(new InvoicePaid($invoice));
--------------------

События уведомлений

Слушателей событий в EventServiceProvider.php
$listen = [
  'Illuminate\Notifications\Events\NotificationSent' => [
    'App\Listeners\LogNotification',
  ],
];

Создать класс слушателя
php artisan event:generate
--------------------

Свойства события

public function handle(NotificationSent $event) {
  $event->channel
  $event->notifiable
  $event->notification
  $event->response
}
--------------------

Создать свой канал
пропустил
--------------------

Создать свой драйвер
пропустил
-------------------------------------------------

DIGGING DEEPER -> PACKAGE DEVELOPMENT

Пакет - это способ добавить новый функционал. Содержит контроллеры-модели-вьюхи-роуты.
Универсальные пакеты типа Carbon, Behat добавлять через composer.

У контрактов и фасадов одинаковый уровень тестируемости.
Пакет для тестов https://github.com/orchestral/testbench

Автоматическое обнаружение пакета
Вручную config/app.php в $providers добавить СП пакета
Автоматически, добавив СП в composer.json в ключ 'extra'. Там же прописать фасады пакета.

Отключить Автоматическое обнаружение пакета
добавить в composer.json в ключ "extra" в подключ "dont-discover".
можно поставить "*" чтобы отключить обнаружение всех пакетов.

СП связывает пакет и фреймворк.
СП привязывает контроллеры-модели-вьюхи-роуты к СК

КОНФИГИ

опубликовать конфиги пакета в папку config
в СП написать

public function boot() {
  $this->publishes([
    __DIR__.'/path/to/config/courier.php' => config_path('courier.php'),
  ]);
}

Юзер запустит команду vendor:publish
это скопирует конфиги в нужную папку
конфиг пакета будет доступен как обычный в формате файл.ключ

config('courier.option');

В конфигах не использовать замыкания

дефолтовый конфиг
слить конфиг пакета с копией в папке app

public function register() {
  $this->mergeConfigFrom(
    __DIR__.'/path/to/config/courier.php', 'courier'
  );
}

РОУТЫ

загрузить роуты пакета
public function boot() {
  $this->loadRoutesFrom(__DIR__.'/routes.php');
}

МИГРАЦИИ

загрузить миграции пакета
чтобы они автоматически запускались командой php artisan migrate

public function boot() {
  $this->loadMigrationsFrom(__DIR__.'/path/to/migrations');
}

ФАБРИКИ

загрузить фабрики пакета (database factories)
public function boot() {
  $this->loadFactoriesFrom(__DIR__.'/path/to/factories');
}

их использовать так
factory(Package\Namespace\Model::class)->create();

ПЕРЕВОДЫ

загрузить переводы пакета (translation files)
public function boot() {
  $this->loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');
}

доступ в формате package::file.line
trans('courier::messages.welcome');

опубликовать переводы пакета в папке приложения resources/lang/vendor
public function boot() {

  $this->loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');

  $this->publishes([
    __DIR__.'/path/to/translations' => resource_path('lang/vendor/courier'),
  ]);
}

юзер запускает команду vendor:publish и переводы окажутся в нужной папке

ВЬЮХИ
загрузить вьюхи пакета

public function boot() {
  $this->loadViewsFrom(__DIR__.'/path/to/views', 'courier');

  $this->publishes([
    __DIR__.'/path/to/views' => resource_path('views/vendor/courier'),
  ]);
}

формат доступа package::view

view('courier::admin');

вьюхи лежат в папке пакета
командой vendor:publish перекидываются в папку app для изменения

КОМПОНЕНТЫ
загрузить компоненты пакета (view components blade)

public function boot() {
  $this->loadViewComponentsAs('courier', [
    Alert::class,
    Button::class,
  ]);
}

использовать так

<x-courier-alert />
<x-courier-button />

анонимные компоненты так
<x-courier::alert />

КОМАНДЫ ARTISAN
загрузить команды пакета чтобы юзать в Artisan CLI

public function boot() {
  if ($this->app->runningInConsole()) {
    $this->commands([
      FooCommand::class,
      BarCommand::class,
    ]);
  }
}

ПУБЛИЧНЫЕ АКТИВЫ
assets
image, css, js

public function boot() {
  $this->publishes([
    __DIR__.'/path/to/assets' => public_path('vendor/courier'),
  ], 'public');
}

команда vendor:publish опубликует ресурсы в папке public
можно тегирование
php artisan vendor:publish --tag=public --force
флаг --force даст обновление ресурсов при обновлении самого пакета

Тегирование группы ресурсов
публикация группы ресурсов отдельно по тегам

public function boot() {

  $this->publishes([
    __DIR__.'/../config/package.php' => config_path('package.php')
  ], 'config');

  $this->publishes([
    __DIR__.'/../database/migrations/' => database_path('migrations')
  ], 'migrations');
}
php artisan vendor:publish --tag=config
-------------------------------------------------

DIGGING DEEPER -> QUEUES

В очередь ставятся тяжелые фоновые задачи
Laravel Horizon это панель управления очередями на Redis
Фасад Queue

Драйверы
Beanstalk, Amazon SQS, Redis, Database, Synchronous (выполняет немедленно. для локальной разработки), Null (выключено)

Конфиг
config/queue.php

Папка задач
app/Jobs
--------------------

Соединение и Очередь

Соединение это запрос к службе очередей, через указанный драйвер

Задача отправляется в соединение, в очередь по умолчанию, или в указанную в 'queue'

В соединении может быть много очередей

Каждой очереди можно назначить приоритет

У разных очередей разное колво воркеров

Задачи запускают асинхронно
Логика задачи в методе handle()
СК автоматически разрешает зависимости в конструкторе класса задач
--------------------

Драйвер Database

все задачи будут в таблице

Создать миграцию для таблицы jobs
php artisan queue:table

Накатить миграцию
php artisan migrate
--------------------

Драйвер Redis

все задачи будут в таблице
пропустил
--------------------

Драйвер Amazon SQS

пропустил
--------------------

Драйвер Beanstalkd

пропустил
--------------------

Создать задачу

php artisan make:job JobName

class JobName implements ShouldQueue {

  public function __construct(User $user) {
    $this->user = $user;
	$this->user = $user->withoutRelations();
  }

  главный метод
  public function handle() {
  }
}
--------------------

МВ для задач

МВ оборачивает задачу логикой
чтобы разгрузить метод handle от логики
МВ для задач работает как МВ для роутов
например логика ограничение скорости

class JobName implements ShouldQueue {

  public function middleware() {
    return [new RateLimited];
  }

  public function handle() {
    Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {
      info('lock obtained');
      Handle job
      }, 
	  function () {
        could not obtain lock
        return $this->release(5);
      });
}

Папка МВ для задач
app/Jobs/Middleware

Пример МВ
class RateLimited {
  public function handle($job, $next) {
    Redis::throttle('key')
      ->block(0)->allow(1)->every(5)
      ->then(function () use ($job, $next) {
        lock obtained...
        $next($job);
      }, function () use ($job) {
        could not obtain lock
        $job->release(5);
      });
    }
}
--------------------

Отправить задачу

в очередь по умолчанию
JobName::dispatch($user);

в очередь nameQueue
JobName::dispatch($user)->onQueue('nameQueue');

это отправит задачу в таблицу jobs
--------------------

Отправить по условию

JobName::dispatchIf($userban == 1, $user);
JobName::dispatchUnless($userban === 0, $user);
--------------------

Отложить отправку

JobName::dispatch($user)->delay(now()->addMinutes(10));
--------------------

Отправить после прихода ответа в браузер

JobName::dispatchAfterResponse($user);

или

dispatch(function () {
  Mail::to('email@email.com')->send(new WelcomeMessage);
})->afterResponse();

для коротких задач
--------------------

Отправить синхронно
выполнит сразу без очереди

JobName::dispatchNow($user);
--------------------

Цепочки задач

список задач в нужной последовательности
если одна задача падает, то остальные не выполняются

Bus::chain([
  new JobName1,
  new JobName2,
  new JobName3,
])->dispatch();

Bus::chain([
    new JobName1,
    new JobName2,
    function () {
      User::update();
    },
])->dispatch();
--------------------

Удаление задачи

$this->delete()

не остановит цепочку задач
--------------------

Указать Соединение и Очередь

Bus::chain([
  new JobName1,
  new JobName2,
  new JobName3,
])
  ->onConnection('connectionName')
  ->onQueue('queueName')
  ->dispatch();
--------------------

Отправка цепочки не удалась

Bus::chain([
  new JobName1,
  new JobName2,
  new JobName2,
])->catch(function (Throwable $e) {
  chain has failed
})->dispatch();
--------------------

Отправить задачу в очередь nameQueue
JobName::dispatch($user)->onQueue('nameQueue');

Или указать в конструкторе
public function __construct() {
  $this->onQueue('nameQueue');
}
--------------------

Отправить задачу в соединение nameConnection
JobName::dispatch($podcast)->onConnection('nameConnection');

Или указать в конструкторе
public function __construct() {
  $this->onConnection('nameConnection');
}
--------------------

Колво попыток выполнения задачи

Через командную строку
php artisan queue:work --tries=N

В классе задачи
public $tries = N;

по умолчанию это 1 раз
потом задача будет считаться неудачной
--------------------

Пытаться выполнять задачу до указанного времени

public function retryUntil() {
  return now()->addSeconds(N);
}
--------------------

Пытаться выполнять задачу пока колво падений не будет N

public $maxExceptions = 3;
--------------------

Указать максимальное время выполнения задачи

Через командную строку
php artisan queue:work --timeout=N

В классе задачи
public $timeout = N;
--------------------

Вернуть задачу в очередь

public function handle() {
  $this->release();
  $this->release(N сек)
}
--------------------

Сделать задачу неудачной

public function handle() {
  $this->fail();
  $this->fail($exception);
}
--------------------

Пакетная обработка задач

Создать миграцию для таблицы job_batches
php artisan queue:batches-table

Накатить миграцию
php artisan migrate

Пропустил разделы
пакетные задачи
именованные пакеты
соединения и очереди
цепочки пакетов
добавить задачу в пакет
отладка пакетов
отмена выполнения пакетов
ошибки выполнения пакетных задач
--------------------

Задачи на базе замыкания

dispatch(function () use ($user) {
  $user->ban();
})->catch(function (Throwable $e) {
    job failed
});
--------------------

Обработчик задач

это фоновый демон. загружает код в память
изменили код, сделать рестарт обработчика
--------------------

Запуск обработчика очереди задач

В терминале
php artisan queue:work

С автоматическим обновлением измененного кода
php artisan queue:listen

В фоновом режиме
Supervisor
--------------------

Запуск нескольких обработчиков

В терминале
php artisan queue:work
php artisan queue:work
php artisan queue:work

В фоновом режиме
Supervisor 'numprocs' = N
--------------------

Указать соединение

php artisan queue:work connectionName

все соединения в config/queue.php
--------------------

Указать очередь

php artisan queue:work --queue=queueName
--------------------

Обработать 1 задачу
php artisan queue:work --once

Обработать N задач
php artisan queue:work --max-jobs=N

Обработать все задачи и выйти
php artisan queue:work --stop-when-empty

Обрабатывать задачи на протяжении N секунд и выйти
php artisan queue:work --max-time=N
--------------------

Пауза между задачами

php artisan queue:work --sleep=3
--------------------

Приоритеты

В config/queue.php
'queue' = low

В коде
dispatch((new Job)->onQueue('high'));

Командой
php artisan queue:work --queue=high,low
--------------------

Деплой на сервер

Рестарт обработчиков
php artisan queue:restart
--------------------

Сколько ждать перед новой попыткой выполнить задачу
параметр retry_after в config/queue.php

Сколько ждать выполнения задачи, а потом завершить неудачно
php artisan queue:work --timeout=N

Параметр retry_after на 5 сек длиннее чем timeout
--------------------

Настройка Supervisor

либа для Linux

Мануал
http://supervisord.org

Установка
sudo apt-get install supervisor

Конфиг
/etc/supervisor/conf.d

Запуск
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start
--------------------

Обработка неудачных задач

складываются в таблицу failed_jobs

Создать миграцию для таблицы failed_jobs
php artisan queue:failed-table

Накатить миграцию
php artisan migrate
--------------------

Сколько ждать перед новой попыткой выполнить задачу

В терминале
php artisan queue:work --backoff=N

В классе в свойстве
public $backoff = N;

В классе в методе
public function backoff() {
  return N;
  return [N, M, X];
}
--------------------

Очистка после неудачных задач

public function failed(Throwable $exception) {
 notification of failure
}
--------------------

Посмотреть неудачные задачи

php artisan queue:failed
--------------------

Выполнить неудачную задачу, список задач, все задачи

php artisan queue:retry 5
php artisan queue:retry 5 6 7 8 9 10
php artisan queue:retry --range=5-10
php artisan queue:retry all
--------------------

Удалить неудачную задачу, все задачи

php artisan queue:forget 5
php artisan queue:flush
--------------------

Модель передаётся в задачу

сериализуется в массив json и сохраняется в поле в бд

Если модель уже удалена, то задачу можно не выполнять
public $deleteWhenMissingModels = true;
--------------------

События задач

в AppServiceProvider.php
public function boot() {

  до выполнения задачи
  Queue::before(function (JobProcessing $event) {
    $event->connectionName
    $event->job
    $event->job->payload()
  });

  после выполнения задачи
  Queue::after(function (JobProcessed $event) {
    $event->connectionName
    $event->job
    $event->job->payload()
  });

  перед получением задачи из очереди
  Queue::looping(function () {
    while (DB::transactionLevel() > 0) {
      DB::rollBack();
    }
  });
  
  задача завершилась неудачно
  Queue::failing(function (JobFailed $event) {
    $event->connectionName
    $event->job
    $event->exception
  });
}
--------------------

Удалить задачи из очереди

php artisan queue:clear
php artisan queue:clear connectionName --queue=queueName
-------------------------------------------------

DIGGING DEEPER -> TASK SCHEDULING

обычно 1 крон = 1 задача
такие задачи вне Гит
и нужен ssh


Крон
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1

Все задачи в классе App\Console\Kernel в методе schedule

protected function schedule(Schedule $schedule) {

  используя замыкание
  $schedule->call(function () {
    DB::table('recent_users')->delete();
  })->daily();

  используя вызываемые классы
  $schedule->call(new DeleteRecentUsers)->daily();

  команды Artisan
  $schedule->command('emails:send Taylor --force')->daily();
  $schedule->command(EmailsCommand::class, ['Taylor', '--force'])->daily();

  очереди задач
  $schedule->job(new Heartbeat)->everyFiveMinutes();
  $schedule->job(new Heartbeat, 'heartbeats')->everyFiveMinutes();

  команды оболочки shell
  $schedule->exec('node /home/forge/script.js')->daily();
}

Настройки

cron('* * * * *');

everyMinute(), everyTwoMinutes(), everyThreeMinutes(), everyFourMinutes(), everyFiveMinutes(), everyTenMinutes(), everyFifteenMinutes(), everyThirtyMinutes()

hourly(), hourlyAt(17), everyTwoHours(), everyThreeHours(), everyFourHours(), everySixHours()

daily(), dailyAt('13:00'), twiceDaily(1, 13)

weekly(), weeklyOn(1, '8:00')

monthly(), monthlyOn(4, '15:00'), lastDayOfMonth('15:00')

quarterly(), yearly()

timezone('America/New_York')

weekdays(), weekends(), sundays(), mondays(), tuesdays(), wednesdays(), thursdays(), fridays(), saturdays(), days(array|mixed), between($start, $end), unlessBetween($start, $end), when(Closure), skip(Closure) environments($env), at()

Цепочки

$schedule->command('foo')
  ->weekdays()
  ->hourly()
  ->timezone('America/Chicago')
  ->between('8:00', '17:00');

$schedule->call(function () {})
  ->weekly()
  ->mondays()
  ->at('13:00');

Таймзона для всех задач
в app/Console/Kernel.php

protected function scheduleTimezone() {
  return 'America/Chicago';
}

Таймзона на лету
->timezone('America/New_York');


Дублирование задач
Задачи будут стартовать, даже если предыдущая не закончилась.
Чтобы предотвратить дублирование

$schedule->command('emails:send')->withoutOverlapping();

сколько минут ждать лок
$schedule->command('emails:send')->withoutOverlapping(10);


Выполнение 1 задачи на 1 сервере
если несколько серверов
драйвер кеша database, memcached, redis

$schedule->command('report:generate')
  ->fridays()
  ->at('17:00')
  ->onOneServer();


Паралельное выполнение задач
По умолчанию все задачи выполняются последовательно

работает только для command и exec
$schedule->command('analytics:report')
  ->daily()
  ->runInBackground();

В режиме обслуживания сайта задачи не выполняются
чтобы выполнялись

$schedule->command('emails:send')->evenInMaintenanceMode();

Вывод результата задачи

вывод в файл
$schedule->command('emails:send')->daily()->sendOutputTo($filePath);

вывод в файл. добавлять
$schedule->command('emails:send')->daily()->appendOutputTo($filePath);

отправить по почте
$schedule->command('foo')->daily()->sendOutputTo($filePath)->emailOutputTo('foo@example.com');

отправить по почте только в случае сбоя
$schedule->command('foo')->daily()->emailOutputOnFailure('foo@example.com');

данные методы только для методов command и exec
emailOutputTo, emailOutputOnFailure, sendOutputTo, appendOutputTo


Хуки

$schedule->command('emails:send')
  ->daily()
  ->before(function () {
    до начала выполнения
  })
  ->after(function () {
    задача выполнена
});

$schedule->command('emails:send')
  ->daily()
  ->onSuccess(function () {
    задача выполнена успешно
  })
  ->onFailure(function () {
    задача не выполнилась
});


Пинг урлов

требуется
composer require guzzlehttp/guzzle

пинг урла до и после выполнения задачи
$schedule->command('emails:send')
  ->daily()
  ->pingBefore($url)
  ->thenPing($url);

если условие true
$schedule->command('emails:send')
  ->daily()
  ->pingBeforeIf($condition, $url)
  ->thenPingIf($condition, $url);

если условие false
$schedule->command('emails:send')
  ->daily()
  ->pingOnSuccess($successUrl)
  ->pingOnFailure($failureUrl);
-------------------------------------------------

DATABASE -> REDIS

Redis это хранилище пар ключ-значение
composer require predis/predis
Фасад Redis
команды https://redis.io/commands

Для скорости поставить PhpRedis PHP extension PECL
Конфиг config/database.php в $redis

Соединение требует name, host, port, password, database
Или единый url

включить 'scheme' => 'tls' (TLS/SSL)
или будет 'tcp' по умолчанию

Настройка кластера серверов redis
в файле настроек в массиве clusters

Расширение Predis
REDIS_CLIENT = predis
поддерживает разные Соединения

Расширение PhpRedis
установлено по умолчанию
REDIS_CLIENT = phpredis

Чтобы использовать PhpRedis и Фасад Redis
чтобы не было конфликта
в app.php переименовать так
'RedisManager' => Illuminate\Support\Facades\Redis::class

Вызов команд

Redis::get('user:profile:'.$id);
Redis::set('name', 'Taylor');
Redis::lrange('names', 5, 10);
Redis::command('lrange', ['name', 5, 10]);

Выбрать соединение

Redis::connection();
Redis::connection('my-connection');

Отправка сразу много команд (pipelining)

Redis::pipeline(function ($pipe) {
  for ($i = 0; $i < 1000; $i++) {
    $pipe->set("key:$i", $i);
  }
});

Publish и Subscribe на каналы

public function handle() {
  Redis::subscribe(['test-channel'], function ($message) {
    echo $message;
  });
}

Route::get('publish', function () {
  Redis::publish('test-channel', json_encode(['foo' => 'bar']));
});


Подписка на много каналов

Redis::psubscribe(['*'], function ($message, $channel) {
  echo $message;
});

Redis::psubscribe(['users.*'], function ($message, $channel) {
  echo $message;
});
-------------------------------------------------

ОБНОВЛЕНИЕ LARAVEL 7 -> 8

мин версия PHP 7.3

Сидеры пространство имен Database\Seeders
Фабрики пространство имен Database\Factories

Папка database/seeds переименована в database/seeders

появился Laravel Jetstream

Collections метод isset изменился

Castable метод castUsing изменился

Dispatcher метод listen изменился

Eloquent события update и save работают для методов increment и decrement

Режим обслуживания. в public/index.php добавить код
define('LARAVEL_START', microtime(true));
if (file_exists(__DIR__.'/../storage/framework/maintenance.php')) {
  require __DIR__.'/../storage/framework/maintenance.php';
}

php artisan down
удалён параметр --message

php artisan serve
добавлен параметр --no-reload

класс Support\Manage свойство $app удалено
новое свойство $container

хелпер elixir удалён

Почта Mail метод sendNow удалён
использовать метод send

Пагинатор использует Tailwind CSS
вернуть Bootstrap в AppServiceProvider в boot() {Paginator::useBootstrap();}

очередь Queue
метод retryAfter и свойство retryAfter переименованы в backoff
свойство timeoutAt переименовано в retryUntil

когда используем withChain:
методы allOnQueue и allOnConnection удалены
методы onQueue и onConnection добавлены
в хелпере dispatch эти методы оставлены

в таблицу невыполненных задач failed_jobs добавить столбик uuid

Роуты

в RouteServiceProvider было $namespace = App\Http\Controllers
теперь $namespace = null

Контракт Session
новый метод pull

В классе тестирования TestResponse метод decodeResponseJson удален
использовать метод json

При сравнении json и массива

метод assertExactJson требует цифровые ключи и строгий порядок совпадения при сравнении

если не совпадают то использовать метод assertSimilarJson

Правила валидации unique и exists берут имя соединения из getConnectionName
-------------------------------------------------

COMPOSER.JSON

Внутри папка vendor, пакеты как бренд
Внутри папки пакета, еще пакеты

Папка пакетов
vendor

Создать composer.json
composer init
--------------------

Установить пакет
composer install packetname

Скачать пакеты
composer install

Список пакетов
composer show

Обновить пакеты
composer update
--------------------

Ключи

зависимости на продакшене
require

зависимости на разработке
require-dev
-------------------------------------------------

PACKAGE.JSON

Пакеты https://npmjs.com
У каждого пакета внутри есть package.json с зависимостями
В папке bin исполняемые файлы пакетов

Папка пакетов
node_modules

Создать package.json
npm init
--------------------

Установить пакет
npm install packetname

Скачать пакеты
npm install

Скачать пакеты для продакшена
npm install --production

Список пакетов
npm list
npm list --depth 0
npm list --depth 1

Проверить обновления
npm outdated

Обновить пакеты
npm up

Удалить пакет
npm uninstall packetname

Найти пакет
npm search packetname

Подключить пакет в js файле
require('packetname');
--------------------

Ключи

точка входа в проект
main

зависимости на продакшене
dependencies

зависимости на разработке
devDependencies
-------------------------------------------------

ЭКСПОРТ ИЗ MYSQL WORKBENCH В LARAVEL MIGRATION

1. скачать плагин. из Схемы в миграцию
https://github.com/beckenrode/mysql-workbench-export-laravel-5-migrations

MySQL Workbench - Scripting - Install Plugin
выбрать export-laravel-5-migrations.py

MySQL Workbench - Tools - Catalog - Export Laravel 5 Migration

2. использовать сервис. из SQL в миграции
https://adolfocuadros.com/sql_to_laravel

3. использовать пакет. из БД в миграции
https://github.com/Xethron/migrations-generator
-------------------------------------------------

НЕЙМИНГ

Таблица (мн) - brands
Таблица промежуточная (ед) - brand_site
Столбик таблицы (snake_case) - meta_title
Аттрибут модели (snake_case) - $model->meta_title
Первичный ключ - id
Внешний ключ (ед) - brand_id

Модель (ед) - php artisan make:model Brand
Связи модели hasOne, belongsTo (ед) - brandSite
Связи модели остальные (мн) - brandSites

Миграция (ед) - php artisan make:migration Brand
Фабрика (ед) - php artisan make:factory Brand
Сидер (ед) - php artisan make:seeder Brand

Контроллер (ед) - php artisan make:controller BrandController
Метод (camelCase) - getAll
Метод в ресурсном контроллере (table) - store
Метод в тестовом классе (camelCase) - testBrand

Роут(мн) - brands/1
Роут именованный (snake_case) - brands.show_active

Переменная (camelCase) - $brandSite
Коллекция (мн) - $brands= Brand::all()->get()
Объект (ед) - $user= User::find(1)

Файлы конфигов и языковые (snake_case) - articles_enabled

Вьюха (kebab-case) - brand-show.blade.php
Контракт, интерфейс (существительное или прилагательное) - BrandInterface
Трейт (прилагательное) - Brandable
-------------------------------------------------

ЛУЧШИЕ ПРАКТИКИ

Модель
работа с данными, логика, сортировки, условия, where
длинные условия разбивать на отдельные методы
куски where запросов выносить в методы scopename
eloquent лучше чем query builder лучше чем сырые запросы
использовать массовое заполнение
использовать нетерпеливую загрузку (проблема N+1)
каждая модель связана со своей таблицей
для даты использовать акцессоры и мутаторы в модели

Классы Request
валидация

Сервис классы
бизнес логика

Вьюхи
не выполнять запросы к модели
не встраивать css и js
не использовать php

Контроллер
текст выносить в константы, языковые файлы, конфиги
коллекция лучше массива
использовать IoC container или фасады вместо new Class (public function __construct(User $user) {$this->user = $user;} вместо $user = new User;)
использовать config() вместо env()
-------------------------------------------------

КОРОТКИЙ СИНТАКСИС

Session::get('cart')
session('cart')

Session::put('cart', $data)
session(['cart' => $data])

$request->session()->get('cart')
session('cart')

$request->input('name'), Request::get('name')
$request->name, request('name')

$request->has('value') ? $request->value : 'default';
$request->get('value', 'default')

return Redirect::back()
return back()

is_null($object->relation) ? null : $object->relation->id
optional($object->relation)->id

view('index')->with('title', $title)->with('client', $client)
view('index', compact('title', 'client'))

Carbon::now(), Carbon::today()
now(), today()

App::make('Class')
app('Class')

->where('column', '=', 1)
->where('column', 1)

->orderBy('created_at', 'desc')
->latest()

->orderBy('age', 'desc')
->latest('age')

->orderBy('created_at', 'asc')
->oldest()

->select('id', 'name')->get()
->get(['id', 'name'])

->first()->name
->value('name')
-------------------------------------------------

КОМАНДЫ ARTISAN

-V             Версия ларавел
clear-compiled Remove the compiled class file
db             Start a new database CLI session
down           Put the application into maintenance / demo mode
env            Display the current framework environment
help           Displays help for a command
inspire        Display an inspiring quote
list           Lists commands
migrate        Запустить все миграции
optimize       Cache the framework bootstrap files
serve          Запустить локальный сервер разработки
test           Run the application tests
tinker         Писать код в консоли как php -a
up             Bring the application out of maintenance mode

auth:clear-resets Flush expired password reset tokens

cache:clear  Flush the application cache
cache:forget Remove an item from the cache
cache:table  Создать миграцию для таблицы кеша

config:cache Создать кеш всех конфигов
config:clear Удалить кеш всех конфигов

db:seed Запустить все сидеры
db:wipe Удалить все таблицы

event:cache    Создать кеш списка событий и слушателей
event:clear    Удалить кеш списка событий и слушателей
event:generate Создать события и слушателей
event:list     Посмотреть все события и слушателей

key:generate Сгенерировать application key

make:cast         Create a new custom Eloquent cast class
make:channel      Создать канал
make:command      Создать команду Artisan
make:component    Создать компонент вьюхи
make:controller   Создать контроллер
make:event        Создать событие
make:exception    Создать исключение
make:factory      Создать фабрику
make:job          Создать задачу
make:listener     Создать слушателя
make:mail         Создать почту
make:middleware   Создать мидлваре
make:migration    Создать миграцию
make:model        Создать модель eloquent
make:notification Создать уведомление
make:observer     Создать наблюдателя
make:policy       Create a new policy class
make:provider     Создать сервис провайдер
make:request      Создать форму запроса
make:resource     Create a new resource
make:rule         Создать правила валидации
make:seeder       Создать сидер
make:test         Создать тест

migrate:fresh    Удалить все таблицы, запустить все миграции
migrate:fresh --seed Удалить все таблицы, запустить все миграции, засеять

migrate:install  Создать хранилище миграций
migrate:refresh  Сбросить и запустить все миграции
migrate:reset    Откатить все миграции
migrate:rollback Откатить последнюю миграцию
migrate:status   Показать статус каждой миграции

notifications:table Создать миграцию для таблицы уведомлений

optimize:clear Remove the cached bootstrap files

package:discover Rebuild the cached package manifest

ОЧЕРЕДИ
queue:batches-table  Создать миграцию для таблицы пакетных задач
queue:clear          Удалить задачи из очереди
queue:failed         Посмотреть неудачные задачи
queue:failed-table   Создать миграцию для таблицы неудачных задач
queue:flush          Flush all of the failed queue jobs
queue:forget         Delete a failed queue job
queue:listen         Запуск обработчика очереди задач с автоматическим обновлением измененного кода
queue:restart        Restart queue worker daemons after their current job
queue:retry          Retry a failed queue job
queue:retry-batch    Retry the failed jobs for a batch
queue:table          Создать миграцию для таблицы задач
queue:work           Запуск обработчика очереди задач

РОУТЫ
route:cache Создать кеш всех роутов
route:clear Удалить кеш всех роутов
route:list  Показать все роуты

schedule:run  Run the scheduled commands
schedule:work Start the schedule worker

schema:dump   Сжать все миграции в один файл SQL
session:table Создать миграцию для таблицы сессий
storage:link  Создать символическую ссылку public/storage => storage/app/public

stub:publish Publish all stubs that are available for customization

vendor:publish Publish any publishable assets from vendor packages Опубликовать ресурсы из пакетов поставщиков

view:cache Скомпилировать все blade шаблоны
view:clear Удалить все скомпилированные blade шаблоны