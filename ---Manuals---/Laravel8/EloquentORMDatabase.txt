Состав файла EloquentORM

Getting Started, Relationships, Collections, Mutators, Api resources, Serialization

Состав файла Database

Getting Started, Query Builder, Pagination, Migrations, Seeding
-------------------------------------------------

GETTING STARTED

Eloquent ORM это реализация паттерна ActiveRecord
моделям Eloquent доступны все методы Query Builder

Таблица это Модель
Паттерн Repositories это хранилище для абстракций

Аттрибуты модели это столбики
Методы all и get возвращают Коллекции

Конфиг
config/database.php

Папка моделей
app/Models
-------------------------

Создать модель
php artisan make:model Name

Создать модель и миграцию
php artisan make:model Name -m
--------------------

class Name extends Model {

  имя таблицы. или names
  protected $table = 'names';

  имя первичного ключа. или id
  protected $primaryKey = 'id';

  если первичный ключ не int autoincrement
  public $incrementing = false;

  если первичный ключ не int
  protected $keyType = 'string';

  если не хотим столбики created_at, updated_at
  public $timestamps = false;

  свой формат timestamp
  protected $dateFormat = 'U';

  свои имена created_at и updated_at
  const CREATED_AT = 'creation_date';
  const UPDATED_AT = 'last_update';

  соединение
  protected $connection = 'connectionName';

  значения по умолчанию для столбиков
  protected $attributes = ['delayed' => false];
  
  при обновлении Comment, обновит метку времени updated_at у родителя Post
  protected $touches = ['post'];
}
-------------------------

Подзапросы в Select

User::addSelect(['last_post' => Post::select('name')
  ->whereColumn('user_id', 'users.id')
])->get();

Подзапросы в OrderBy

User::orderByDesc(Post::select('arrived_at')
    ->whereColumn('user_id', 'users.id')
)->get();
-------------------------

Получить все строки
Post::all();
Post::where('active', 1)->orderBy('name', 'desc')->take(10)->get();

Получить строки чанками по N
Post::chunk(200, function ($posts) {});

Курсоры
курсор возвращает ленивые коллекции LazyCollection

Получить строки по 1 через курсоры
foreach (Post::where('foo', 'bar')->cursor() as $post) {}

User::cursor()->filter(function ($user) {
  return $user->id > 500;
});
--------------------

Получить модели

по id
Post::find(1);
Post::find([1, 2, 3]);

1ю модель из выборки
Post::where('active', 1)->first();
Post::firstWhere('active', 1);

1ю модель из выборки, если нет то выполнить замыкание
Post::where('legs', '>', 100)->firstOr(function () {});

1ю модель из выборки, а если нет то выполнить замыкание
выберем только нужные столбики
Post::where('legs', '>', 100)->firstOr(['id', 'legs'], function () {});

Если модели не найдены, то будет исключение ModelNotFoundException
если исключение не перехвачено то будет отправлен ответ HTTP 404

Post::findOrFail(1);
Post::where('legs', '>', 100)->firstOrFail();
--------------------

Агрегатные функции
все агрегатные функции из Query Builder

count()
sum('price')
max('price')
-------------------------

Переизвлечь модель в новую переменную

$user = User::find(1);
$newUser= $user->fresh();

Переизвлечь модель в эту же переменную

$user = User::find(1); //name = a1
$user->name= 'a2';
$user->refresh();
$user->name; //a1
-------------------------

Вставить модель
столбики created_at и updated_at обновятся сами

$user = new User;
$user->name = $request->name;
$user->save();

Обновить модель

$user = User::find(1);
$user->name = 'name';
$user->save();

Массовое обновление

User::where('active', 1)
  ->where('destination', 'San Diego')
  ->update(['delayed' => 1]);

Не срабатывают события модели
для методов saving, saved, updating, updated
-------------------------

Контроль изменения аттрибутов модели с момента извлечения

$user->isDirty();
$user->isDirty('title');

$user->isClean();
$user->isClean('title');

$user->wasChanged();
$user->wasChanged('title');

$user->getOriginal();
$user->getOriginal('title');
-------------------------

Вставить модель

class User extends Model {

  аттрибуты массово назначаемые
  protected $fillable = ['name'];

  сделать все аттрибуты назначаемыми
  protected $guarded = [];
}

$user= User::create(['name' => 'name']);

если модель уже есть, то вставить так
$user->fill(['name' => 'name']);
--------------------

Вставить модель

найти модель, если такой нет, то вставить новую модель с этими аттрибутами

User::firstOrCreate(['name' => 'name']);
User::firstOrCreate(['name' => 'name'], ['delayed' => 1]);
--------------------

Вставить модель

найти модель, если такой нет, то создать новую модель с этими аттрибутами, потом сохранить через save()

User::firstOrNew(['name' => 'name']);
User::firstOrNew(['name' => 'name'], ['delayed' => 1]);
--------------------

Обновить модель

обновить модель, если такой нет, то вставить новую модель с этими аттрибутами

User::updateOrCreate(['departure' => 'Oakland']);
-------------------------

Удалить модель

С извлечением из БД

$user= User::find(1);
$user->delete();

Без извлечения из БД

User::destroy(1);
User::destroy(1, 2, 3);
User::destroy([1, 2, 3]);
User::destroy(collect([1, 2, 3]));
--------------------

Удалить несколько моделей

User::where('active', 0)->delete();
--------------------

Мягкое удаление строк

без фактического удаления
на базе столбика deleted_at в котором время удаления

подключаем трейт
class User extends Model {
  use SoftDeletes;
}


в Schema builder есть метод для создания этого столбика

public function up() {
  Schema::table('users', function (Blueprint $table) {
    $table->softDeletes();
  });
}
public function down() {
  Schema::table('users', function (Blueprint $table) {
    $table->dropSoftDeletes();
  });
}

На модели вызываем метод delete
он будет в столбик deleted_at вставлять дату удаления

В методах select эта строка исключается

Проверка что строка мягко удалена
if ($flight->trashed()) {}

Получить все строки, и мягко удаленные тоже
User::withTrashed()->where('account_id', 1)->get();
$user->history()->withTrashed()->get();

Получить только мягко удаленные строки
User::onlyTrashed()->where('airline_id', 1)->get();

Сделать мягко удаленную строку снова неудаленной
$user->restore();
$user->history()->restore();

Сделать много мягко удаленных строк снова неудаленными
User::withTrashed()->where('airline_id', 1)->restore();

Реально удалить мягко удаленные строки
$user->forceDelete();
$user->history()->forceDelete();
--------------------

Создать клон экземпляра модели

$shipping = Address::create([
  'type' => 'shipping',
  'line_1' => '123 Example Street',
]);
$billing = $shipping->replicate()->fill(['type' => 'billing']);
$billing->save();
--------------------

Глобальные области для Запросов

глобальные ограничения для всех запросов к модели
мягкое удаление сделано на таком же принципе

Создать область AgeScope

class AgeScope implements Scope {
  public function apply(Builder $builder, Model $model) {
    $builder->addSelect('name')->where('age', '>', 200);
  }
}

Добавить область AgeScope к модели User

class User extends Model {
  protected static function booted() {
    static::addGlobalScope(new AgeScope);
  }
}

Добавить область на основе замыкания, к модели

class User extends Model {
  protected static function booted() {
    static::addGlobalScope('age', function (Builder $builder) {
      $builder->where('age', '>', 200);
    });
  }
}

Для конкретного запроса удалить область
User::withoutGlobalScope(AgeScope::class)->get();
User::withoutGlobalScope('age')->get();

Удалить все области
User::withoutGlobalScopes()->get();

Удалить конкретные области
User::withoutGlobalScopes([FirstScope::class, SecondScope::class])->get();
--------------------

Локальные области для Запросов

локальные ограничения для всех запросов к модели
эти методы в модели Eloquent с префиксом scope

class User extends Model {

  public function scopePopular($query) {
    return $query->where('votes', '>', 100);
  }

  с параметром  
  public function scopeActive($query, $count) {
    return $query->where('votes', '>', $count);
  }

}

Вызываются методы без префикса
popular()
active(100)
popular()->active(100)

User::popular()->orWhere(function (Builder $query) {
  $query->active();
})->get();
--------------------

Сравнить модели

совпадение соединение-таблица-первичный ключ
if ($post->is($anotherPost)) {}
--------------------

События на модели

выборка - retrieved
новая модель сохраняется - creating, created
существующая модель сохраняется - updating, updated
модель создана или обновлена - saving, saved
модель удалена - deleting, deleted
модель восстановлена - restoring, restored

Массовое обновление или удаление
не вызывает событий saved, updated, deleting, deleted

Свяжем события и классы событий

class User extends Authenticatable {
  protected $dispatchesEvents = [
    'saved' => UserSaved::class,
    'deleted' => UserDeleted::class,
  ];
}

Свяжем события и события через замыкания

class User extends Model {
  protected static function booted() {
    static::created(function ($user) {});
  }
}
--------------------

Наблюдатели

когда у модели много событий, то наблюдатель группирует всех слушателей в один класс
в классе наблюдателя методы названы как события модели

Создать наблюдателя
php artisan make:observer UserObserver --model=User

Папка наблюдателей
App/Observers

class UserObserver {
  public function created(User $user) {}
  public function updated(User $user) {}
  public function deleted(User $user) {}
  public function forceDeleted(User $user) {}
}

Наблюдатель регистрируется в модели в методе observe

или в AppServiceProvider
public function boot() {
  User::observe(UserObserver::class);
}
--------------------

Заглушить события на модели

методы внутри замыкания не вызовут события модели
User::withoutEvents(function () use () {
  User::findOrFail(1)->delete();
  User::find(2);
});
-------------------------------------------------

RELATIONSHIPS

Отношения это методы в классе модели Eloquent
имена отношений не должны конфликтовать с аттрибутами модели
всем отношениям доступен Query Builder
--------------------

Мои примеры

Brand
$brands = Brand::all();
$brand = Brand::find(1);
$brand->name;
$brand->sites;
Brand::find(1)->sites;
Brand::find(1)->sites()->where('name', 'sitename')->get();
$brand->sites()->orderBy('id')->get();

$site->category->name;

доступ к pivot таблице
foreach ($brand->sites as $site) {
  $site->brand_site->site_id;
}
--------------------

Отношения

One To One
One To Many
Many To Many

Has One Through
Has Many Through

Polymorphic One To One
Polymorphic One To Many
Polymorphic Many To Many
--------------------

"One To One" (один к одному)

class User extends Model {

  public function phone() {

    return $this->hasOne('Phone');
	
	return $this->hasOne(
	  'Phone', 
	  'foreign_key (user_id)',
	  'primary_key (id или $primaryKey)'
	);
  }
}

class Phone extends Model {

  public function user() {
  
    return $this->belongsTo('User');
	
	return $this->belongsTo(
	  'User', 
	  'foreign_key', 
	  'primary_key'
	);
  }
}

$phone = User::find(1)->phone;
--------------------

"One To Many" (один ко многим)

class Post extends Model {

  public function comments() {
  
    return $this->hasMany('Comment');
	
    return $this->hasMany(
	  'Comment', 
	  'foreign_key', 
	  'primary_key'
	);
  }
}

$comments = Post::find(1)->comments;
$comment = Post::find(1)->comments()
  ->where('title', 'foo')->first();


"One To Many" (многие к одному)

class Comment extends Model {

  public function post() {
  
    return $this->belongsTo('Post');
	
	return $this->belongsTo(
	  'Post', 
	  'foreign_key', 
	  'primary_key'
	);
  }
}

$comment = Comment::find(1);
$comment->post->title;
--------------------

"Many To Many" (многие ко многим)

class User extends Model {

  public function roles() {
  
    return $this->belongsToMany('Role');
	
	return $this->belongsToMany(
	  'Role', 
	  'role_user', 
	  'user_id', 
	  'role_id'
	);
  }
}

class Role extends Model {

  public function users() {
    return $this->belongsToMany('User');
  }
}

$user = User::find(1);
$roles = $user->roles;
$roles = User::find(1)->roles()
  ->orderBy('name')->get();


Промежуточная таблица (pivot)
pivot могут не использовать трейт SoftDeletes

В pivot только ключи pivot таблицы
можно добавить остальные аттрибуты

$this->belongsToMany('Role')
  ->withPivot('column1', 'column2');

$user = User::find(1);
foreach ($user->roles as $role) {
  $role->pivot->column1;
  $role->pivot->column2;
}

Чтобы pivot таблица обрабатывала свои аттрибуты created_at и updated_at
$this->belongsToMany('Role')
  ->withTimestamps();

Переименовать таблицу pivot
$this->belongsToMany('Podcast')
  ->as('pivot123');

foreach ($user->roles as $role) {
  echo $role->pivot123->created_at;
}
--------------------

Фильтрация результатов метода belongsToMany
wherePivot, wherePivotIn, wherePivotNotIn

$this->belongsToMany('Role')
  ->wherePivot('approved', 1);
--------------------

Отдельная модель для pivot таблицы

pivot расширяется от Database\Eloquent\Relations\Pivot
pivot полиморфная расширяется от Database\Eloquent\Relations\MorphPivot

class Role extends Model {
  public function users() {
    return $this->belongsToMany('User')
	  ->using('RoleUsertable');
  }
}

class RoleUsertable extends Pivot {
  если в pivot таблице есть primary key
  public $incrementing = true;
}
--------------------

"Has One Through" (имеет один сквозной)

механик -> машина -> овнер
1 механик имеет 1 машину, 1 машина имеет 1 овнера
механик и овнер связаны через машину
машина это pivot модель

class Mechanic extends Model {

  public function carOwner() {

    return $this->hasOneThrough('Owner', 'Car');

	return $this->hasOneThrough(
      'Owner',
      'Car',
      'mechanic_id', foreign key таблицы Cars
      'car_id',      foreign key таблицы Owners
      'id',          primary key таблицы Mechanics
      'id',          primary key таблицы Cars
    );

  }
}
--------------------

"Has Many Through" (имеет много сквозных)

3 таблицы
projects:     id
environments: id, project_id
deployments:  id, environment_id

class Project extends Model {

  public function deployments() {
    return $this->hasManyThrough(Deployment::class, Environment::class);
  }
  
}
--------------------

"One To One" (полиморфные)

posts:  id, name
users:  id, name
images: id, url, imageable_id (id юзера или поста), imageable_type (класс User или Post)

class User extends Model {
  public function image() {
    return $this->morphOne('Image', 'imageable');
  }
}

class Post extends Model {
  public function image() {
    return $this->morphOne('Image', 'imageable');
  }
}

class Image extends Model {
  public function imageable() {
    return $this->morphTo();
  }
}

$post = Post::find(1);
$image = $post->image;

$image = Image::find(1);
$imageable = $image->imageable;
--------------------

"One To Many" (полиморфные)

posts:    id, title
videos:   id, title
comments: id, body, commentable_id (id юзера или поста), commentable_type (класс User или Post)

$post = Post::find(1);
$comments = $post->comments;

$comment = Comment::find(1);
$commentable = $comment->commentable;
--------------------

"Many To Many" (полиморфные)
пропустил
--------------------

Карты морфинга

Relation::morphMap([
  'posts' => 'Post',
  'videos' => 'Video'
]);
--------------------

Проверка на наличие

$posts = Post::has('comments')->get();
$posts = Post::has('comments', '>', 3)->get();
$posts = Post::has('comments.votes')->get();
$posts = Post::whereHas('comments', function (Builder $query) {
  $query->where('content', 'foo');
})->get();

Проверка на отсутствие

$posts = Post::doesntHave('comments')->get();
$posts = Post::whereDoesntHave('comments', function (Builder $query) {
  $query->where('content', 'foo');
})->get();
--------------------

Проверка наличия связи MorphTo

$comments = Comment::whereHasMorph(
  'commentable',
  ['Post', 'Video'],
  function (Builder $query) {
    $query->where('title', 'foo');
  }
)->get();
--------------------

Подсчет связанных моделей

$posts = Post::withCount('comments')->get();

$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
  $query->where('content', 'foo');
}])->get();

$posts = Post::withCount(['comments', 'comments as comments1' => function (Builder $query) {
    $query->where('approved', false);
}])->get();
--------------------

Подсчет связанных моделей morphTo

$activities = ActivityFeed::query()
  ->with(['parentable' => function (MorphTo $morphTo) {
    $morphTo->morphWithCount([
      Photo::class => ['tags'],
      Post::class => ['comments'],
  ]);
}])->get();

$activities = ActivityFeed::with('parentable')
  ->get()
  ->loadMorphCount('parentable', [
    Photo::class => ['tags'],
    Post::class => ['comments'],
]);
--------------------

Все отношения и динамические свойства загружаются ленивой загрузкой

class Author extends Model {}

class Book extends Model {
  public function author() {
    return $this->belongsTo('Author');
  }
}
--------------------

Ленивая загрузка. N+1 запрос
$books = Book::all();
foreach ($books as $book) {
  $book->author->name;
}

Активная загрузка. 2 запроса (юзается IN)
$books = Book::with('author')->get();
$books = Book::with(['author', 'publisher'])->get();

foreach ($books as $book) {
  $book->author->name;
}

Вложенная активная загрузка
$books = Book::with('author.contacts')->get();

Активная загрузка только нужных аттрибутов
$books = Book::with('author:id,name')->get();

Включить активную загрузку всегда
class Book extends Model {
  protected $with = ['author'];
  public function author() {
    return $this->belongsTo('Author');
  }
}

Удалить активную загрузку для 1 запроса
$books = Book::without('author')->get();

Загрузить отношения когда модель уже получена
$books = Book::all();
$books->load('author', 'publisher');
$author->load(['books' => function ($query) {
  $query->orderBy('published_date', 'asc');
}]);

Загрузить отношения если они не загружены
$book->loadMissing('author');
--------------------

Вставка и обновление связанных моделей

1. Метод save() принимает экземпляр модели Eloquent

$post = Post::find(1);
$comment = new Comment(['message' => 'comment']);

$post->comments()->save($comment);

$post->comments()->saveMany([
  new Comment(['message' => 'new comment']),
  new Comment(['message' => 'new comment'])
]);

2. Метод create() принимает PHP array

$post = Post::find(1);
$comment = $post->comments()->create([
  'message' => 'new comment',
]);

$post->comments()->createMany([
  ['message' => 'new comment'],
  ['message' => 'new comment']
]);
--------------------

Перезагрузка модели и её связей
$post->refresh();
$post = Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();
--------------------

Установка foreign key на потомка
$account = Account::find(1);
$user->account()->associate($account);
$user->save();

Установка foreign key на null
$user->account()->dissociate();
$user->save();
--------------------

Если модели нет, то вернуть болванку
return $this->belongsTo('User')->withDefault();

Если модели нет, то вернуть болванку, с набором аттрибутов
return $this->belongsTo('User')->withDefault([
  'name' => 'aaa'
]);
--------------------

Вставка и удаление в "Many To Many"

users -> user_role <- roles

Добавить роль
$user = User::find(1);
$user->roles()->attach($roleId);

Добавить роль с дополнительными аттрибутами
$user->roles()->attach($roleId, ['expires' => $expires]);

Удалить роль
$user->roles()->detach($roleId);

Удалить роли
$user->roles()->detach([$roleId1, $roleId2, $roleId3]);

Удалить все роли
$user->roles()->detach();

Добавить роли. предыдущие будут удалены
$user->roles()->sync([$roleId1, $roleId2, $roleId3]);
$user->roles()->sync([$roleId1 => ['expires' => true], $roleId2, $roleId3]);

Добавить роли. не удаляя предыдущие
$user->roles()->syncWithoutDetaching([$roleId1, $roleId2, $roleId3]);

Если роль есть, то будет удалена. Если роли нет, то будет добавлена
$user->roles()->toggle([$roleId1, $roleId2, $roleId3]);

Сохранение дополнительных аттрибутов в pivot таблице
User::find(1)->roles()->save($role, ['expires' => $expires]);

Обновление записи в pivot таблице
$user->roles()->updateExistingPivot($roleId, $attributes);
-------------------------------------------------

COLLECTIONS

Eloquent возвращает коллекции
почти все методы коллекций возвращают новый инстанс Eloquent
методы pluck, keys, zip, collapse, flatten, flip возвращают базовый инстанс Collections

Дополнительные методы

contains - определить наличие модели в массиве
diff - вернет все модели кроме указанных
except - вернет все модели кроме указанных id

find - найти модель по id, модели, массиву
fresh - заново загружает модель из базы

intersect - загружает модели по массиву id

load - загружает отношения модели
loadMissing - загружает отношения модели если не были загружены

modelKeys - вернет массив id моделей в массиве
makeVisible - делает аттрибут видимым
makeHidden - делает аттрибут невидимым

only - вернет массив моделей по id
toQuery - возвращает Query Builder
unique - вернет все уникальные модели по id
--------------------

Свой класс Collection со своими методами

class User extends Model {
  public function newCollection(array $models = []) {
    return new CustomCollection($models);
  }
}

теперь Eloquent возвращает для этой модели newCollection а не Collection
можно прописать это для всех моделей
-------------------------------------------------

MUTATORS

Акцессоры читают аттрибуты
Мутаторы пишут аттрибуты

Создать Акцессор

class User extends Model {

  для аттрибута name
  public function getNameAttribute($value) {
	return $this->first_name . $this->last_name;
  }
}

Создать Мутатор

class User extends Model {

  для аттрибута name
  public function setNameAttribute($value) {
    $this->attributes['name'] = strtolower($value);
  }
}
--------------------

Мутаторы для даты

по умолчанию Eloquent конвертит created_at и updated_at в Carbon
можно добавить свои аттрибуты

добавим аттрибут expired для даты
class User extends Model {
  protected $dates = ['expired'];
}

Выключить created_at и updated_at
public $timestamps = false;

Формат даты timestamp
по умолчанию 'Y-m-d H:i:s'

Измениь формат даты
protected $dateFormat = 'U';
--------------------

Приведение типов для аттрибутов

в базе поле ban = 0 или 1
приведем к логическому true или false

protected $casts = [
  'ban' => 'boolean',
];

Все типы
integer, real, float, double, decimal:<digits>
string, boolean, object, array, collection
date, datetime, timestamp
--------------------

Приведение дат

protected $casts = [
  'created_at' => 'datetime:Y-m-d',
];
--------------------

Свой класс приведения типов для аттрибутов

class Json implements CastsAttributes {

  public function get($model, $key, $value, $attributes) {
    return json_decode($value, true);
  }

  public function set($model, $key, $value, $attributes) {
    return json_encode($value);
  }
}

Класс цепляем к модели
class User extends Model {
  protected $casts = [
    'options' => Json::class
  ];
}

Сложные типы аттрибутов

class Address implements CastsAttributes {

  public function get($model, $key, $value, $attributes) {
    return new Address(
      $attributes['address_line_one'],
      $attributes['address_line_two']
    );
  }

  public function set($model, $key, $value, $attributes) {
    return [
      'address_line_one' => $value->lineOne,
      'address_line_two' => $value->lineTwo,
    ];
  }
}
--------------------

Только входящее приведение типов. когда пишем в модель

class Hash implements CastsInboundAttributes {
  public function set($model, $key, $value, $attributes) {
    return bcrypt($value);
  }
}

Все приведения типов сложить в класс и его присоединить к модели
--------------------

Приведение массивов и json

когда в базе есть поле где лежит json
чтобы работать с ним как с массивом
будет автоматическая сериализация-десериализация

class User extends Model {
  protected $casts = [
    'options' => 'array'
  ];
}
--------------------

Приведение аттрибутов на лету

аттрибут expired без приведения

User::select([
  'users.*',
  'expired' => Post::selectRaw('MAX(created_at)')
    ->whereColumn('user_id', 'users.id')
])->get();

аттрибут expired с приведением

User::select([
  'users.*',
  'expired' => Post::selectRaw('MAX(created_at)')
    ->whereColumn('user_id', 'users.id')
])->withCasts([
    'expired' => 'datetime'
])->get();
-------------------------------------------------

API RESOURCES

для создания Api
модели Eloquent конвертируются в Json массивы

Класс ресурса это 1 модель
Класс коллекция ресурсов это массив моделей

тестирование https://postman.com
в браузере ссылки с префиксом /api/

Папка ресурсов
app/Http/Resources
--------------------

Создать ресурс для модели
php artisan make:resource User

Создать ресурс для коллекции моделей
php artisan make:resource Users --collection
php artisan make:resource UserCollection

class User extends JsonResource {

  массив аттрибутов для конвертации в json
  public function toArray($request) {
    return [
      'id' => $this->id,
      'name' => $this->name,
      'created_at' => $this->created_at,
      'updated_at' => $this->updated_at,
    ];
  }
}

Использование
new UserResource(User::find(1));

Создать коллекцию ресурсов и пагинатор
class UserCollection extends ResourceCollection {
  public function toArray($request) {
    return [
      'data' => $this->collection,
      'links' => [
        'self' => 'link-value',
      ],
    ];
  }
}

Использование
UserResource::collection(User::all());
UserCollection(User::all());
--------------------

Не сбрасывать ключи коллекции
public $preserveKeys = true;

Настройка базового класса
$this->collection в UserCollection обращается к User

Можно это изменить
public $collects = 'Http\Resources\Member';
--------------------

Загрузка отношений
public function toArray($request) {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'posts' => PostResource::collection($this->posts),
  ];
}
--------------------

Данные в массиве 'data'
указать свой ключ массива
public static $wrap = 'user';

Отключить ключ
в AppServiceProvider в методе boot
JsonResource::withoutWrapping();

В пагинаторе ключ всегда будет 'data'

Пагинатор можно закинуть в метод collection ресурса
return new UserCollection(User::paginate());
--------------------

Условное добавление аттрибутов

public function toArray($request) {

  return [

    'id' => $this->id,
    'name' => $this->name,

	аттрибут добавиться если true
    'secret' => $this->when(Auth::user()->isAdmin(), 'value'),

	через замыкание
	'secret' => $this->when(Auth::user()->isAdmin(), function () {return 'value';}),
	
	аттрибуты добавятся если true
    $this->mergeWhen(Auth::user()->isAdmin(), [
      'first-secret' => 'value',
      'second-secret' => 'value',
    ])

  ];
}

Не использовать mergeWhen с массивами
когда микс ключей цифры+строки или неупорядоченные цифры
--------------------

Условное добавление отношений

public function toArray($request) {
  return [

    'id' => $this->id,
    'name' => $this->name,

	если отношение не было загружено, то аттрибута не будет
    'posts' => PostResource::collection($this->whenLoaded('posts')),
  ];
}
--------------------

Добавление аттрибутов из pivot таблицы

public function toArray($request) {
  return [

    'id' => $this->id,

	'expires_at' => $this->whenPivotLoaded('role_user', function () {return $this->pivot->expires_at;}),

	'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {return $this->subscription->expires_at;}),

    ];
}
--------------------

Добавление метаданных data, meta, links

public function toArray($request) {
  return [
    'data' => $this->collection,
    'links' => [
      'self' => 'link-value',
    ],
  ];
}

Добавление метаданных на верхний уровень

public function toArray($request) {
  return parent::toArray($request);
}

public function with($request) {
  return [
    'meta' => ['key' => 'value'],
  ];
}

Добавление метаданных через роутер или контроллер
return (new UserCollection(User::all()->load('roles')))
  ->additional(['meta' => [
    'key' => 'value',
]]);
--------------------

Ответ ресурса

return new UserResource(User::find(1));

return (new UserResource(User::find(1)))
    ->response()
    ->header('X-Value', 'True');

class User extends JsonResource {
  public function withResponse($request, $response) {
    $response->header('X-Value', 'True');
  }
}
-------------------------------------------------

SERIALIZATION

Сериализация моделей в Json для создания Api
сериализует модели, в массивы или json

Модель и отношения в массив
user = User::with('roles')->first();
$user->toArray();

Модель в массив
$user->attributesToArray();

Коллекции моделей в массив
$users = User::all();
$users->toArray();

Модель и отношения в json
$user->toJson();
$user->toJson(JSON_PRETTY_PRINT);
--------------------

Скрыть аттрибуты из результата
class User extends Model {
  protected $hidden = ['password'];
}

Вывести только нужные аттрибуты
class User extends Model {
  protected $visible  = ['name'];
}

Временно скрыть или показать аттрибуты
$user->makeVisible('password')->toArray();
$user->makeHidden('name')->toArray();

Добавить аттрибуты
class User extends Model {

  protected $appends = ['ban'];

  как акцессор
  public function getBanAttribute() {
    return $this->attributes['ban'] === '1';
  }

}

Добавить аттрибуты на лету
$user->append('ban')->toArray();
$user->setAppends(['ban', 'onoff'])->toArray();
--------------------

Сериализация даты

Формат даты для всех аттрибутов
protected function serializeDate(DateTimeInterface $date) {
  return $date->format('Y-m-d');
}

Выставить формат на каждый аттрибут
protected $casts = [
  'birthday' => 'date:Y-m-d',
  'joined_at' => 'datetime:Y-m-d H:00',
];
-------------------------------------------------

Состав файла Database

Getting Started, Query Builder, Pagination, Migrations, Seeding
-------------------------------------------------

GETTING STARTED

Фасад DB

Базы данных
MySQL 5.6+, PostgreSQL 9.4+, SQLite 3.8.8+, SQL Server 2017+

Методы
Eloquent ORM, Query Builder, сырой SQL

Конфиг
config/database.php
--------------------

SQLite

Создать бд
touch database/database.sqlite

Конфиг в .env
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
DB_FOREIGN_KEYS=true для ограничений внешнего ключа

Настройки параметров 1 урлом driver://username:password@host:port/database?options
--------------------

Разные соединения для SELECT и INSERT UPDATE DELETE

'mysql' => [
  'read' => [],
  'write' => [],
  'sticky' => true, сразу разрешить чтение данных, которые были добавлены в текущем запросе. запись была сделана, операция чтения возьмёт данные из соединения write а не read, ибо в read еще нет этих данных
];
--------------------

Доступ к разным соединениям с БД
foo должно быть соединением с из config/database.php

DB::connection('foo');
--------------------

Доступ к сырому инстансу PDO

DB::connection()->getPdo();
--------------------

Запросы сырого SQL
биндинг параметров защищает от SQL injection

DB::select('select * from users where id = ?', [1]);
DB::select('select * from users where id = :id', ['id' => 1]);
DB::insert('insert into users (id, name) values (?, ?)', [1, 'aaa']);
DB::update('update users set votes = 100 where name = ?', ['aaa']); вернет колво строк
DB::delete('delete from users');
DB::statement('drop table users'); для запросов не возвращающих значения
--------------------

Событие и Слушатель для запроса

в AppServiceProvider
public function boot() {
  DB::listen(function ($query) {
    $query->sql . $query->bindings . $query->time;
  });
}
--------------------

Транзакции
транзакции это набор операций. если возникла ошибка то всё откатывается назад

DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
});
--------------------

Колво попыток проведения транзакции
DB::transaction(function () {
  DB::table('users')->update(['votes' => 1]);
  DB::table('posts')->delete();
}, 5);
--------------------

Транзакции вручную
DB::beginTransaction();
DB::rollBack();
DB::commit();
-------------------------------------------------

QUERY BUILDER

Query Builder (КБ) это построитель запросов
использует PDO для создания и выполнения запросов
работает для всех видов БД
привязки предотвращают атаки SQL injection
фасад DB
--------------------

Выйти с Eloquent на КБ
query()

Получить все строки
get()

Получить 1ю строку
first()

Получить 1 строку по id
find(1)

Получить 1 строку 1 столбик
value('email')

Получить все строки по 1 или нескольким столбикам
pluck('title')
pluck('title', 'name')

Получить все строки чанками по N
chunk(100, function ($users) {})

Обновить все строки чанками по N
DB::table('users')->chunkById(N, function ($users) {
  foreach ($users as $user) {
    DB::table('users')->where('id', $user->id)->update(['active' => true]);
  }
})
--------------------

Агрегатные функции
count(), max(), min(), avg(), sum()

Проверка на существование
exists(), doesntExist()
--------------------

Select

выбрать нужные столбики
select('name', 'email as email1')

выбрать с distinct
distinct()

на лету добавить в select еще столбик
$query = DB::table('users')->select('name');
$query->addSelect('age');
--------------------

Сырые запросы
самому обрабатывать код от SQL injection

DB::raw универсален
select(DB::raw('count(*) as count'))

Остальные алиасы
selectRaw(), whereRaw(), havingRaw(), orderByRaw(), groupByRaw()
--------------------

Запросы Join

join('posts', 'users.id', '=', 'posts.user_id')
leftJoin('posts', 'users.id', '=', 'posts.user_id')
rightJoin('posts', 'users.id', '=', 'posts.user_id')
crossJoin('colors')
--------------------

Дополнительные условия в Join

join('contacts', function ($join) {
  $join
    ->on('users.id', '=', 'contacts.user_id')
    ->where('contacts.user_id', '>', 5);
	->orOn(...);
})
--------------------

Подзапросы в Join

joinSub, leftJoinSub, rightJoinSub

$latestPosts = DB::table('posts')
  ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)
  ->groupBy('user_id');

$users = DB::table('users')
  ->joinSub($latestPosts, 'latest_posts', function ($join) {
    $join->on('users.id', '=', 'latest_posts.user_id');
})->get();
--------------------

Запросы Union

union, unionAll

$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first);
--------------------

Where

where('votes', 10);
where('votes', '=', 10);
where('votes', '>=', 10);
where('name', 'like', '%word%');
where([['a', '=', '1'], ['b', '<>', '1']]);
orWhere('name', 'John');
--------------------

Группировка внутри or (... and ...)

DB::table('users')
  ->where('votes', '>', 100)
  ->orWhere(function($query) {
    $query->where('name', 'Abigail')
	  ->where('votes', '>', 50);
  })
->get();
--------------------

Дополнительные методы

whereBetween, orWhereBetween
whereNotBetween, orWhereNotBetween

whereIn, whereNotIn
orWhereIn, orWhereNotIn

когда внутри IN() большой массив
whereIntegerInRaw, whereIntegerNotInRaw

whereNull, whereNotNull
orWhereNull, orWhereNotNull

для сравнения с датой
whereDate, whereMonth, whereDay, whereYear, whereTime 

для сравнения 2 столбиков
whereColumn, orWhereColumn
--------------------

Группировка параметров внутри замыкания
всегда группировать вызовы orWhere

select * from users where name = 'John' and (votes > 100 or title = 'admin')

DB::table('users')
  ->where('name', '=', 'John')
  ->where(function ($query) {
    $query->where('votes', '>', 100)
      ->orWhere('title', '=', 'Admin');
})->get();
--------------------

Метод whereExists

select * from users where exists (select 1 from orders where orders.user_id = users.id)

DB::table('users')
  ->whereExists(function ($query) {
    $query->select(DB::raw(1))
      ->from('orders')
      ->whereRaw('orders.user_id = users.id');
})->get();
--------------------

Подзапрос во Where

User::where(function ($query) {
  $query->select('type')
    ->from('membership')
    ->whereColumn('user_id', 'users.id')
    ->orderByDesc('start_date')
    ->limit(1);
}, 'Pro')->get();
--------------------

Запросы из столбиков Json

where('options->language', 'en')
whereJsonContains('options->languages', 'en')
whereJsonContains('options->languages', ['en', 'de'])
whereJsonLength('options->languages', 0)
whereJsonLength('options->languages', '>', 1)
--------------------

Сортировка

orderBy('name', 'desc')
orderBy('name', 'desc')->orderBy('email', 'asc')

сортировка по дате по столбику created_at
latest()

сортировка по дате по столбику column
latest('column')

сортировка рандомная
inRandomOrder()

Удалить сортировку
reorder()

Удалить сортировку и применить новую
reorder('email', 'desc')
--------------------

Группировка
работает как where

groupBy('account_id')
groupBy('account_id', 'status')

having('account_id', '>', 100)
having('account_id', '>', 100)
--------------------

Лимит и офсет
skip это limit
take это offset

skip(N)
take(M)

limit(N)
offset(M)
--------------------

Условные добавления в запрос

$role = $request->input('role');


Если $role = true, то выполнится замыкание

when($role, function ($query, $role) {
  return $query->where('role_id', $role);
})->get();

Если $role = false, то выполнится второе замыкание

when($role, function ($query, $role) {
  return $query->orderBy($role);
}, function ($query) {
  return $query->orderBy('name');
})->get();
--------------------

Вставка строк

вставка 1 строки
insert(['email' => 'email1', 'votes' => 0]);

вставка много строк
insert([
  ['email' => 'email1', 'votes' => 0],
  ['email' => 'email2', 'votes' => 0],
]);

игнорирование дубликатов при вставке
insertOrIgnore([
  ['id' => 1, 'email' => 'taylor@example.com'],
  ['id' => 2, 'email' => 'dayle@example.com'],
]);

вставка 1 строки и получить вставленный ID
insertGetId(['email' => 'email1', 'votes' => 0]);
insertGetId(['email' => 'email2', 'votes' => 0], 'id_user');
--------------------

Обновления строк

обновить строку
update(['votes' => 1])

обновить или вставить
если строка не найдена, то будет вставлена с данными из обоих массивов

updateOrInsert(

  условия для поиска строки
  ['email' => 'email', 'name' => 'aaa'], 
  
  что обновлять
  ['votes' => '2']
);

обновить строку JSON
update(['options->enabled' => true]);
--------------------

Инкремент и Декремент столбика
для них не работают события модели

increment('votes');
increment('votes', 5); на +5
decrement('votes');
decrement('votes', 5); на -5
increment('votes', 1, ['name' => 'John']); попутно еще что-то обновим
--------------------

Удаление строк

delete()
truncate(); удалит все строки и сбросит счетчик ID
--------------------

Блокировка

блокирует изменение строк, пока транзакция не зафиксирована
sharedLock()

блокирует выборку и изменение строк, пока существует sharedLock
lockForUpdate()
--------------------

SQL debug

sql запрос и результат
Brand::query()->dd();
Brand::query()->dump();

sql запрос
dd(Brand::query()->toSql());

explain запроса
Brand::query()->explain()->dd();

use Illuminate\Support\Facades\DB;
DB::enableQueryLog();
  код
dd(DB::getQueryLog());
-------------------------------------------------

PAGINATION

Пагинатор встроен в Eloquent ORM и Query Builder
метод groupBy() не работает с методом paginate()

Без пагинатора
all()
get()

Пагинатор ссылки "1,2,3"
paginate(10)

Пагинатор ссылки "Назад, Вперед"
simplePaginate(10)

Пагинатор с Eloquent
User::paginate(10)
User::simplePaginate(10)
--------------------

Свой пагинатор
стиль paginate от Pagination\LengthAwarePaginator
стиль simplePaginate от Pagination\Paginator
--------------------

Конвертация пагинатора в Json
метод toJson

{
  "total": 50,
  "per_page": 15,
  "current_page": 1,
  "last_page": 4,
  "first_page_url": "http://laravel.app?page=1",
  "last_page_url": "http://laravel.app?page=4",
  "next_page_url": "http://laravel.app?page=2",
  "prev_page_url": null,
  "path": "http://laravel.app",
  "from": 1,
  "to": 15,
  "data":[
    {Result Object},
    {Result Object}
   ]
}
--------------------

Счетчик страниц в урле пагинатора
page=N

Изменить ссылки пагинатора
withPath('custom/url')
будут ссылки вида custom/url?page=N

Ссылки пагинатора
{{$users->links()}}

Добавить параметр к ссылкам в query string
{{$users->appends(['sort' => 'votes'])->links()}}

Добавить весь query string к ссылкам
{{$users->withQueryString()->links()}}

Добавить хеш к ссылкам в query string
{{$users->fragment('foo')->links()}}

Настройка колва ссылок
{{$users->onEachSide(N)->links()}}

Изменить внешний вид ссылок
{{$paginator->links('view.name')}}
{{$paginator->links('view.name', ['foo' => 'bar'])}}

Экспорт вьюх ссылок пагинатора в свой каталог resources/views/vendor/pagination
php artisan vendor:publish --tag=laravel-pagination

Изменить название вьюхи

в AppServiceProvider
public function boot() {
  Paginator::defaultView('view-name');
  Paginator::defaultSimpleView('view-name');

  смена дизайна с Bootstrap на Tailwind CSS
  Paginator::useTailwind();
}

Все методы пагинатора
count, currentPage, firstItem, getOptions, getUrlRange, hasPages, 
hasMorePages, items, lastItem, lastPage, nextPageUrl, onFirstPage, 
perPage, previousPageUrl, total, url, getPageName, setPageName
-------------------------------------------------

MIGRATIONS

Миграции это аналог системы контроля версий для структуры БД
миграции создают таблицы, столбцы
таблица migrations это лог всех миграций
фасад Schema

Папка миграций
database/migrations
-------------------------

Создать миграцию
php artisan make:migration Name

Создать миграцию для таблицы table
php artisan make:migration Name --create=table
--------------------

Запустить все миграци
php artisan migrate

Запустить 1 миграцию
php artisan migrate --path=/database/migrations/name.php

Запустить все миграци без дополнительного подтверждения
php artisan migrate --force
--------------------

Откатить последнюю миграцию
php artisan migrate:rollback

Откатить последние N миграций
php artisan migrate:rollback --step=N

Откатить все миграции
php artisan migrate:reset
--------------------

Сбросить и запустить все миграции (пересоздание БД)
php artisan migrate:refresh

Сбросить и запустить все миграции (пересоздание БД и посев)
php artisan migrate:refresh --seed

Удалить все таблицы и запустить все миграции
php artisan migrate:fresh

1 команда на всё
Удалить все таблицы и запустить все миграции (сделать посев)
php artisan migrate:fresh --seed
-------------------------

Класс миграции
в методах используется schema builder

метод up
создать таблицы, столбики, индексы

метод down
удалить таблицы, столбики, индексы

public function up() {

  создать таблицу
  Schema::create('names', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->timestamps();
  });
  
}

public function down() {
  
  удалить таблицу
  Schema::drop('names');
}
-------------------------------------------------

Проверка на существование таблицы
if (Schema::hasTable('users')) {}

Проверка на существование столбика
if (Schema::hasColumn('users', 'email')) {}
--------------------

Выбрать соединение
Schema::connection('foo')->create('users', function (Blueprint $table) {
  $table->id();
});
--------------------

Параметры таблицы

$table->engine = 'InnoDB';
$table->charset = 'utf8mb4';
$table->collation = 'utf8mb4_unicode_ci';
DB::statement("ALTER TABLE `brands` comment 'коммент к таблице'");

Переименовать таблицу
Schema::rename($from, $to);

Удалить таблицу
Schema::drop('users');
Schema::dropIfExists('users');
-------------------------

У id и foreign_id должны совпадать тип столбца

1 связка
$table->integer('id')->autoIncrement();
$table->integer('categories_id');
$table->index('categories_id');
$table->foreign('categories_id')->references('id')->on('categories');

2 связка
$table->id();
$table->foreignId('categories_id')->constrained();
-------------------------

Виды столбца id

$table->id();
$table->bigIncrements('id');
`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT

$table->increments('id');
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT

$table->integer('id')->autoIncrement();
`id` INT NOT NULL AUTO_INCREMENT
-------------------------

Создать столбик

$table->string('name');
`name` VARCHAR(255) NOT NULL

$table->string('name')->nullable()->comment('название');
`name` VARCHAR(255) NULL COMMENT 'название'

$table->string('email', 100);
$table->boolean('confirmed');
$table->enum('level', ['0', '1']);
$table->integer('votes');
$table->text('description');
$table->timestamp('added_on', 0);

$table->timestamps();
`created_at` TIMESTAMP NULL, `updated_at` TIMESTAMP NULL

Случай когда 1 столбик CURRENT_TIMESTAMP а второй ON UPDATE CURRENT_TIMESTAMP

$table->timestamp('added')->useCurrent();
$table->timestamp('update')->useCurrent()
  ->default(DB::raw('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'));
--------------------

Индексы

$table->primary();
$table->unique();
$table->index();
$table->spatialIndex();

Составной ключ для промежуточной таблицы типа brand_site
строго 1 сочетание "1 сайт + 1 бренд"
$table->primary(['brand_id', 'site_id']);

Составной индекс
$table->index(['brand_id', 'site_id']);

Модификаторы

->after()
->autoIncrement()
->charset()
->collation()
->comment()
->default()
->first()
->from()
->nullable()
->storedAs()
->unsigned()
->useCurrent() - CURRENT_TIMESTAMP
->useCurrentOnUpdate() CURRENT_TIMESTAMP
->virtualAs()
->generatedAs()
->always()
--------------------

Написание специфичных функций
$table->json('movies')->default(new Expression('(JSON_ARRAY())'));
--------------------

Изменение столбиков
поставить composer require doctrine/dbal

Изменить столбик
Schema::table('users', function (Blueprint $table) {
  $table->string('name', 50)->change();
});

Переименовать столбик
Schema::table('users', function (Blueprint $table) {
  $table->renameColumn('from', 'to');
});

Удалить столбик или столбики
Schema::table('users', function (Blueprint $table) {
  $table->dropColumn('votes');
  $table->dropColumn(['votes', 'avatar', 'location']);
});

Методы работы со столбиками
dropMorphs, dropRememberToken, dropSoftDeletes, dropSoftDeletesTz, dropTimestamps, dropTimestampsTz
--------------------

Кодировка
по умолчанию utf8mb4
--------------------

Создать индекс
имена индексов создаются автоматически на основе имени таблицы и столбика

$table->string('email')->unique();
$table->unique('email');
$table->index(['account_id', 'created_at']);
$table->unique('email', 'mynameindexemail');

Методы индексов
primary, unique, index, spatialIndex

Длинна индексов
varchar по умолчанию 255

изменить в AppServiceProvider
public function boot() {
  Schema::defaultStringLength(255);
}

Переименовать индекс
$table->renameIndex('from', 'to')

Удалить индекс указав имя индекса
$table->dropPrimary('indexname');
$table->dropUnique('indexname');
$table->dropIndex('indexname');
$table->dropSpatialIndex('indexname');

Удалить индекс указав имя столбика, правильный индекс сгенерится сам
Schema::table('geo', function (Blueprint $table) {
  $table->dropIndex(['state']); - автоназвание geo_state_index
});
--------------------

Foreign key

Связь posts.user_id -> users.id

Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');
});

foreignId это алиас для unsignedBigInteger

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained();
});

constrained() автоматически найдет таблицу и столбик

можно уточнить
Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained('users');
});
--------------------

Action для "On Delete" и "On Update"

$table->foreignId('user_id')->constrained()->onDelete('cascade');

модификаторы столбиков
$table->foreignId('user_id')->nullable()->constrained();
--------------------

Удалить внешний ключ по названию ключа
$table->dropForeign('posts_user_id_foreign');

В ограничениях внешнего ключа используется то же соглашение об именах, что и в индексах
на основе имени таблицы и столбика за которыми суффикс _foreign

Удалить внешний ключ по названию столбика, а имя ключа сгенерится автоматом
$table->dropForeign(['user_id']);

Включить и отключить ограничения внешнего ключа
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();

в SQLite по умолчанию ограничение внешнего ключа отключено
Его нужно включить в config/database.php в параметре DB_FOREIGN_KEYS = true
SQLite поддерживает внешние ключи только при создании таблицы, а не при изменении
-------------------------------------------------

SEEDING

Заполнить БД тестовыми данными
сидеры вызывают фабрики
используется Eloquent и Query Builder
зависимости разрешаются через СК

Папка сидеров
database/seeds (ver 7)
database/seeders (ver 8)

Создать сидер
php artisan make:seeder Name

public function run() {

  query builder
  DB::table('users')->insert([
    'name' => Str::random(10),
    'password' => Hash::make('password'),
  ]);
  
  eloquent
  User::factory(5)->create();
  
  factory(User::class, 50)->create()->each(function ($user) {
    $user->posts()->save(factory(Post::class)->make());
  });
  
}
--------------------

Запуск нескольких сидеров
в database/seeders/DatabaseSeeder.php

public function run() {
  $this->call([
    UserSeeder::class,
    PostSeeder::class,
    CommentSeeder::class,
  ]);
}
--------------------

Мои примеры
в database/seeders/DatabaseSeeder.php

Создать бренды
Brand::factory(5)->create();
Brand::factory()->count(5)->create();
Brand::factory()->count(5)->create(['addparam' => 1]);

Создать бренды но не сохранять
Brand::factory(5)->make();
Brand::factory()->count(5)->make();
Brand::factory()->count(5)->make(['addparam' => 1]);

Изменить аттрибуты
Brand::factory()->state(['existparam' => 1])->make();

Создать бренды и сайты и в промежуточной таблице связь "сайт-бренд"
связь N:M "brands->brand_site<-sites"
Brand::factory(5)->has(Site::factory(5))->create();

Создать категории и сайты
когда связь 1:M "categories->sites"
Category::factory(5)->hasSites(5)->create();
Category::factory(5)->hasSites(5, ['addparam' => 1])->create();
Category::factory(5)->has(Site::factory()->count(5))->create();
Category::factory(5)->has(Site::factory()->count(5), 'sites')->create();

Создать сайты и категории
Site::factory()->count(5)->for(Category::factory())->create();
Site::factory()->count(5)->forCategory()->create();

Создать юзеров, сайты, и отзывы
User::factory()->has(Site::factory()->count(5))->create();
--------------------

Запустить все сидеры
php artisan db:seed

Запустить 1 сидер
php artisan db:seed --class=Brand

Запустить без дополнительного подтверждения
php artisan db:seed --force
-------------------------------------------------