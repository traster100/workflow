ДОКУМЕНТАЦИЯ

https://laravel.com/docs/5.5
http://laravel.su/docs/5.4
https://laravel.ru/docs/v5


Ставить на каждый проект

Для улучшенного вывода информации о возникающих ошибках
https://github.com/GrahamCampbell/Laravel-Exceptions

Удобная консоль ошибок
https://github.com/barryvdh/laravel-debugbar

Удобный автокомплит
https://github.com/barryvdh/laravel-ide-helper

Удобно создавать миграции и модели, используя всего одну команду
https://github.com/laracasts/Laravel-5-Generators-Extended

После всех установок выполнить
php artisan vendor:publish
composer update


Cтандарт кодирования PSR-2, стандарт автозагрузки PSR-4
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md


Стиль кода StyleCI


PHPDoc

/**
 * Register a binding with the container.
 *
 * @param  string|array  $abstract
 * @param  \Closure|string|null  $concrete
 * @param  bool  $shared
 * @return void
 */
public function bind($abstract, $concrete = null, $shared = false) {}


Микрофреймворк от Laravel
https://lumen.laravel.com



INSTALLATION

https://laravel.com/docs/5.5/installation

Образ для разработки
https://laravel.com/docs/5.5/homestead

Требования
PHP> = 7.0.0, Расширение PHP OpenSSL, Расширение PDO PHP, Расширение PHP Mbstring, Расширение Tokenizer PHP, Расширение XML PHP

1.1 Установка на Linux через Composer
composer create-project --prefer-dist laravel/laravel projectname

1.2 Установка на Windows через Composer
в PATH C:\YD\soft\OpenServer\modules\php\PHP-7.1
Tools - Composer - init composer (скачается composer.phar)
Tools - Composer - init composer (будет создан composer.json)
На файле composer.json нажать install (будет создана папка vendor)
cd C:\YD\domains\laravel.loc
php.exe C:\YD\domains\laravel.loc\composer.phar create-project --prefer-dist laravel/laravel projectname
Будет создана папка projectname и там проект
Добавить папку public в публичную в OpenServer на вкладке Домены
laravel.loc => \laravel.loc\projectname\public

2 Установка через инсталлер Laravel
Tools - Composer - Manage Dependencies - установить пакет laravel/installer
cd C:\YD\domains\laravel.loc
C:\YD\domains\laravel.loc\vendor\bin\laravel.bat new projectname2
Не использовать. в консоли ошибки и в итоге нет папки vendor внутри:
Crafting application...
Could not open input file: composer.phar
Application ready! Build something amazing.


Если ставили руками, а не через Laravel Composer или Laravel installer
- переименовать .env.example в .env
- php artisan key:generate - сгенерить или прописать руками в .env 32-символьный ключ.
- в config/app.php установить timezone и locale

Красивые урлы
в public/.htaccess - уже должно быть удаление index.php из пути. модуль mod_rewrite должен быть включен. если вдруг не работает, то прописать вручную:

для Apache:
Options +FollowSymLinks
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^ index.php [L]

для Nginx:
location / {
    try_files $uri $uri/ /index.php?$query_string;
}



CONFIGURATION

https://laravel.com/docs/5.5/configuration

В .env общие настройки
и настройки базы данных, которые потом читаются в конфиг config/database.php
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret


Получить переменные файла среды
$value = env('APP_DEBUG', false);
второе значение это по-умолчанию

Определение текущей среды
$environment = App::environment();

Проверка среды
if (App::environment('local')) {среда local}
if (App::environment(['local', 'staging'])) {среда local или staging}


Все конфиги в папке config

Получить переменные файлов конфигов
$value = config('app.timezone');
app - имя файла, timezone - параметр, третий параметр - по-умолчанию

Установка переменных файлов конфигов
config(['app.timezone' => 'America/Chicago']);

Кеширование файлов конфигов
php artisan config:cache склеивает все конфиги в 1 файл. запускать в конце разработки

Включить на сайте режим обслуживания, с показом заглушки
php artisan down --message="Upgrading Database"
php artisan up - включение обычного режима
шаблон сообщения тут: resources/views/errors/503.blade.php



DIRECTORY STRUCTURE

https://laravel.com/docs/5.5/structure

Root Directory Project

app - папка приложения
bootstrap - тут app.php bootstrap-файл фреймворка, папка cache (должна быть доступна для записи)
config - папка конфигов
database - папка миграции бд, засева, файлов sqlite
public - это web server document/web root, тут index.php точка входа всех запросов, accets (активы): css, js, images
resources - тут папка views, папка assets где нескомпилированные активы less, sass, js, папка lang где языковые файлы
routes - тут файлы роутов web.php, api.php, console.php, channels.php - для веба, апи, консоли, каналов вещания
storage - (должна быть доступна для записи). подпапки:
  /app - для любых файлов созданных вашим приложением
  /app/public - папка для файлов юзера, аватарок, надо создать символическую ссылку чтобы папка стала общедоступной командой php artisan storage:link
  /framework - для файлов сгенеренных фреймворком, кешей, вьюшек, сессий, тестов
  /logs - лог файлы
tests - тут тесты PHPUnit
vendor - тут Composer зависимости


App Directory (папка приложения)

Console - все ваши пользовательские команды artisan, и запланированные задачи
Events - классы событий
Exceptions - классы исключений
Http - все ваши контроллеры в папке Controllers, посредники в папке Middleware, запросы форм, вся логика обработки запросов
Jobs - очереди заданий
Listeners - классы обработки событий. слушатели событий получают экземпляр события, выполняют логику в ответ на событие
Mail - классы писем
Notifications - классы уведомлений, отправляющие уведомления по различным драйверам (почта, Slack, SMS)
Policies - классы авторизации, ACL, может ли юзер выполнить какое-либо действие над ресурсом
Providers - классы сервис-провайдеров
Rules - классы валидации, правил инкапсуляции сложной логики проверки в простой объект



HOMESTEAD

https://laravel.com/docs/5.5/homestead

это Vargant-контейнер, который включает: Ubuntu 16.04, Git, PHP 7.1, Nginx, MySQL, MariaDB, Sqlite3, PostgreSQL, Composer, Node (Yarn, Bower, Grunt, Gulp), Redis, Memcached, Beanstalkd, Mailhog, ngrok



DEPLOYMENT

https://laravel.com/docs/5.5/deployment

конфиг для Nginx

server {
    listen 80;
    server_name example.com;
    root /example.com/public;
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";
    index index.html index.htm index.php;
    charset utf-8;
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }
    error_page 404 /index.php;
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;
        fastcgi_index index.php;
        include fastcgi_params;
    }
    location ~ /\.(?!well-known).* {
        deny all;
    }
}

Оптимизация автозагрузчика Composer
composer install --optimize-autoloader

Оптимизация конфигов
php artisan config:cache
это склеит все конфиг файлы в 1

Оптимизация роутов
php artisan route:cache
это склеит все роуты (которые на основе контроллера) в 1
роуты на основе Closures (замыканий) не кешируются

Laravel Forge https://forge.laravel.com
Может создавать серверы для различных поставщиков инфраструктуры (DigitalOcean, Linode, AWS), устанавливает и управляет всеми инструментами (Nginx, MySQL, Redis, Memcached, Beanstalk)



REQUEST LIFECYCLE

https://laravel.com/docs/5.5/lifecycle

заружается public/index.php
он загружает автозагрузчик Composer vendor/autoload.php
из bootstrap/app.php извлекает экземпляр приложения
создается экземпляр приложения (сервис-контейнер)
входящий запрос посылается HTTP/Console-ядро

в HTTP-ядре загружается массив загрузчиков bootstrappers которые будут запущены перед выполнением запроса (они настраивают обработку ошибок, ведение журналов, итд)
в HTTP-ядре загружается массив посредников, через которые должны пройти все запросы, перед обработкой приложением (обрабатывают чтение, запись, HTTP-сессии итд)

загрузка сервис-провайдеров (они настраиваются в config/app.php в массиве providers). cначала будет вызван метод register для всех сервис-провайдеров, а когда они ВСЕ будут зарегистрированы, будет вызван метод boot

Сервис-провайдеры отвечают за начальную загрузку компонентов фреймворка (БД, очередь, проверка ввода (валидация), роутинг). хранятся в папке app/Providers. в файл AppServiceProvider добавлять свои сервис-провайдеры

Итого: сервис-провайдеры зарегистрированы, приложение загружено, Request поступает в роутер для обработки, роутер отправит запрос по роуту или контроллеру, запустит посредников соответствующих роуту.



SERVICE CONTAINER

https://laravel.com/docs/5.5/container

Сервис-контейнер — это средство для управления и внедрения зависимостей (добавление других классов в этот класс), через конструктор или метод-сеттер.

Например UserController должен получить юзеров из хранилища данных (Eloquent, файл):

class UserController extends Controller {

// Внедрение репозитория пользователя
protected $users;

public function __construct(UserRepository $users) {
        $this->users = $users;
    }
}

Связывание

Все привязки сервис-контейнеров регистрировать в сервис-провайдерах.
Если классы не зависят от интерфейсов, то не надо связывать их в контейнере.
В сервис-провайдере доступ к контейнеру как $this->app.
Зарегистрировать привязку методом bind, передав имя класса/интерфейса который хотим зарегистрировать, вместе с функцией замыкания Closure, которая возвращает экземпляр класса.

Простое связывание с контейнером
$this->app->bind('HelpSpot\API', function ($app) {
    return new HelpSpot\API($app->make('HttpClient'));
});

Привязка синглтона
привязывает класс/интерфейс к контейнеру, который должен быть создан только 1 раз
$this->app->singleton('HelpSpot\API', function ($app) {
    return new HelpSpot\API($app->make('HttpClient'));
});

Привязка экземпляра
привязать существующий экземпляр объекта к контейнеру
$api = new HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\API', $api);

Связывание примитивов
класс, который получает некие внедрённые классы, но которому еще требуется внедрение примитивных значений
$this->app->when('App\Http\Controllers\UserController')
          ->needs('$variableName')
          ->give($value);

Связывание интерфейса с реализацией с контейнером
интерфейс EventPusher и реализацию RedisEventPusher
$this->app->bind(
    'App\Contracts\EventPusher',
    'App\Services\RedisEventPusher'
);
и далее
public function __construct(EventPusher $pusher) {
    $this->pusher = $pusher;
}

Контекстное связывание
два класса, которые используют один интерфейс, но вы хотите внедрить различные реализации в каждый класс

Автоматическое связывание (самый распространенный способ)
просто указать тип зависимости в конструкторе класса в контейнере, включая контроллеры, слушателей событий, очереди задач, посредников итд. Указание типов классов приводит к их автоматическому внедрению в методы вашего контроллера.

class UserController extends Controller {
    protected $users;
    public function __construct(UserRepository $users) {
        $this->users = $users;
    }
}

Тегирование
может потребоваться получить все реализации в определенной категории

Практика

метод make для получения экземпляра класса из контейнера
$api = $this->app->make('HelpSpot\API');

если вы в месте кода, где нет доступа к $app
$api = resolve('HelpSpot\API');

События
Контейнер создаёт событие когда из него извлекается объект. Вы можете слушать эти события, используя метод resolving



SERVICE PROVIDERS

https://laravel.com/docs/5.5/providers

ваше приложение и все базовые сервисы Laravel загружаются через сервис-провайдеры
в config\app.php в массиве providers перечислены классы сервис-провайдеров, которые регистрируют в сервис-контейнере(глобальном объекте App) определенный сервис сразу, или при первом вызове метода register, это зависит от того является ли провайдер отложенным
отложенные провайдеры не загружаются при каждом запросе
все сервис-провайдеры наследуют класс Illuminate\Support\ServiceProvider

Создать новый провайдер
php artisan make:provider NameServiceProvider
это создаст класс app/Providers/NameServiceProvider.php

Метод Register
Регистрация сервис-провайдера. внутри этого метода только привязывать свои классы в сервис-контейнер. тут $app предоставляет доступ к сервис-контейнеру

class NameServiceProvider extends ServiceProvider {
    public function register() {
        $this->app->singleton(
            Connection::class,
            function ($app) {
                return new Connection(config('name'));
            }
        );
    }
}

Метод Boot
Этот метод вызывается после того, как были зарегистрированы все сервис-провайдеры. тут у вас есть доступ ко всем другим зарегистрированным сервисам

class NameServiceProvider extends ServiceProvider {
    public function boot() {
        view()->composer(
            'view',
            function () {
            }
        );
    }
}

Внедрение зависимостей в методе Boot
Можно указать зависимости сервис-провайдера и сервис-контейнер автоматически внедрит их

Регистрация провайдеров
Все сервис-провайдеры регистрируются в конфиге config/app.php в массиве providers, где можно добавить имена классов ваших сервис-провайдеров

'providers' => [
    App\Providers\NameServiceProvider::class,
],

Отложенные провайдеры
Если ваш провайдер только регистрирует привязки в сервис-контейнере, то можно отложить регистрацию до момента, когда одна из этих привязок будет запрошена из сервис-контейнера. Установите свойство defer=true и определите метод provides. Метод provides должен вернуть привязки сервис-контейнера, зарегистрированные в вашем провайдере

class NameServiceProvider extends ServiceProvider {

 protected $defer = true; // отложенная загрузка провайдера

    // получить предоставляемые сервисы от провайдера
    public function provides() {
        return [Connection::class];
    }
}

Сервис-провайдеры - нужны для регистрации сервисов(классов) в сервис-контейнере(глобальном объекте App)
Все сервис-провайдеры должны наследовать специальный класс ServiceProvider
В сервис-провайдерt есть методы register и boot, метод register для привязки нужных классов в сервис-контейнер
Регистрация сервиса в сервис-контейнере(App) в методе register, который выполняется при начальной загрузке приложения для каждого сервис-провайдера

Сервис-провайдеры позволяют внедрять зависимости (объекты нужных классов) в нужные методы так:
public function form(Request $request, SaveStr $save){}

При этом автоматически создаются объекты указанных зависимостей, и дальше в коде мы работаем с одним и тем же объектом при повторном внедрении зависимости в других методах (singleton)

class SaveStrServiceProvider extends ServiceProvider {

    public function boot() {}

 //1 так
    public function register() {
        $this->app->singleton('App\Helpers\Contracts\SaveStr', function(){
        return new SaveEloquent();
        });
    }

 //2 или так
 public function register() {
     App::singleton(SaveStr::class, function() {
        return new SaveEloquent();
        });
 }

 //3 или так
 public function register() {
    App::singleton(SaveStr::class, SaveEloquent::class);
}
}

В 1 и 2 замыкания позволяют выполнить дополнительный код и преобразования

Можно использовать метод bind вместо singleton, если не нужно использовать паттерн singleton. Первым параметром передается название контракта(интерфейса) который регистрируем, вторым параметром анонимная функция, возвращающая один из классов, реализующих данный интерфейс. Лучше использовать метод singleton

Доступ к сервис-контейнеру из сервис-провайдера
$this->app

Используем сервис
public function form(Request $request, SaveStr $save) {
        $save->save($request, User::find(1));
}

В сервис-провайдере у нас прописан класс SaveEloquent для реализации контракта(интерфейса) SaveStr. Поэтому сохранение будет в БД. Для того чтобы использовался класс SaveFile(сохранение в файл) достаточно изменить в методе register класса SaveStrServiceProvider название привязываемого класса
public function register() {
    App::singleton(SaveStr::class, function(){
        return new SaveFile();
    });
}

Метод boot всех классов сервис-провайдеров вызывается автоматически после регистрации всех сервисов. В данный метод можно внедрять любую зависимость

Сервис-провайдеры - поставщики услуг - service providers - представляют собой классы, которые регистрируют сервисы(классы) в сервис-контейнере(глобальном объекте App). Сервис провайдеры реализуют механизм Dependency Injection. При регистрации классов(сервисов) в глобальном объекте с помощью сервис-провайдеров, используется шаблон проектирования синглтон



FACADES

https://laravel.com/docs/5.5/facades

Фасады предоставляют "статический" интерфейс к классам, доступным в сервис-контейнере. Laravel поставляется со множеством фасадов, которые предоставляют доступ практически ко всем функциям Laravel. Все фасады Laravel в пространстве имен Illuminate\Support\Facades. Фасад - это класс, который предоставляет доступ к объекту в контейнере.

Фасад Cache
use Illuminate\Support\Facades\Cache;
Route::get('/cache', function () {
    return Cache::get('key');
});

При создании стороннего пакета, который взаимодействует с Laravel, лучше внедрять контракты, а не фасады

Фасады в сравнении с внедрением зависимостей
Фасады не требуют внедрения. Зависимости требуют (в конструкторе)
Преимущество внедрения зависимостей - возможность замены реализаций внедряемого класса
Фасады используют динамические методы для вызова метода-прокси для объектов, отделенных от сервис-контейнеров

Фасады в сравнении с хелперами
Нет разницы между фасадом и хелпером
Есть много встроенных хелперов, типа формирование шаблонов, запуск событий, постановка задач в очередь или отправка HTTP-ответов
Многие хелперы и фасады выполняют одни функции

Вызов фасада и этот вызов хелпера эквивалентны
return View::make('profile');
return view('profile');

таблица основных фасадов
http://laravel.su/docs/5.4/facades#facade-class-reference

Фасады - предоставляют легкий доступ к классам зарегистрированным в сервис-контейнере. Можно обходиться без них, внедряя зависимость в методы или получая объект нужного сервиса прямо в коде из глобального объекта App. Фасады стоит создавать для часто используемых сервисов, для упрощения доступа к их методам. Фасады это альтернатива внедрению зависимостей

Внедрение зависимости
public function form(Request $request, SaveStr $save) {
        $save->save($request, User::find(4));
}

Фасад
public function form(Request $request) {
        SaveStr::save($request, User::find(4));
}

Сам фасад app\Helpers\Facades\SaveStr.php
class SaveStr extends Facade {
    protected static function getFacadeAccessor() {
        return 'save';
    }
}



CONTRACTS

https://laravel.com/docs/5.5/contracts

это набор интерфейсов, которые описывают основной функционал фреймворка
Контракт Illuminate\Contracts\Queue\Queue определяет методы для работы очередей
Контракт Illuminate\Contracts\Mail\Mailer определяет методы для отправки электронной почты

Все контракты Laravel в репозиториях GitHub
https://github.com/illuminate/contracts

Контракты и фасады
Фасады и хелперы это способ использования сервисов Laravel без необходимости типизирования и извлечения контрактов из сервис-контейнера
Обычно у каждого фасада есть эквивалентный контракт
Фасады не требуют чтобы вы запрашивали их в конструкторе вашего класса
Контракты позволяют вам определить конкретные зависимости для ваших классов

Для большинства приложений неважно — фасады или контракты
Фактически, контракты являются краткой документацией функций Laravel
Чтобы получить реализацию контракта, достаточно указать тип интерфейса в конструкторе класса

use Illuminate\Contracts\Redis\Database;
class CacheOrderInformation {
protected $redis;
public function __construct(Database $redis) {
   $this->redis = $redis;
}
public function handle(OrderWasPlaced $event) {}

таблица основных контрактов
http://laravel.su/docs/5.4/contracts#contract-reference

Контракты – это интерфейсы, на основе которых сгруппированы классы, которые реализуют их, и в которых определены методы, указанные в интерфейсах, плюс другие нужные методы
Контракты хранить в папке app\Helpers\Contracts
Классы реализующие контракт хранить в папке app\Helpers

Контракт SaveStr:
Interface SaveStr {
    public static function save(Request $request, User $user);
    public function checkData($array);
}

Файл app\Helpers\SaveEloquent.php
class SaveEloquent implements SaveStr {
public static function save(Request $request, User $user){тут реализация}
public function checkData($array) {тут реализация}
}

Файл app\Helpers\SaveFile.php
class SaveFile implements SaveStr {
public static function save(Request $request, User $user) {тут реализация}
public function checkData($array) {тут реализация}
}



ROUTING

https://laravel.com/docs/5.5/routing

все роуты в папке routes
web.php, api.php, console.php, channels.php - для веба, апи, консоли, каналов вещания

регистрировать роуты для любого HTTP-запроса
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

роут отвечает на HTTP-запросы нескольких типов
Route::match(['get', 'post'], '/', function () {});

или ОДНОГО типа
Route::get('foo', function () {});

или для ВСЕХ типов
Route::any('foo', function () {});

Параметры роутов
Route::get('user/{id}', function ($id) {});
Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {});
Параметры роута находятся в {}, не содержат "-", могут содержать "_"

Необязательные параметры
после названия писать "?"
Route::get('user/{name?}', function ($name = null) {});
Route::get('user/{name?}', function ($name = 'John') {});

Ограничения регулярными выражениями параметров
Route::get('user/{name}', function ($name) {})->where('name', '[A-Za-z]+');
Route::get('user/{id}', function ($id) {})->where('id', '[0-9]+');
или сразу обоих
Route::get('user/{id}/{name}', function ($id, $name) {})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Глобальные ограничения
это ограничение автоматически применится ко всем роутам, использующим этот параметр
в RouteServiceProvider пишем
public function boot() {
    Route::pattern('id', '[0-9]+');
    parent::boot();
}

Именованные роуты
Route::get('user/profile', function () {})->name('profile');

можно указать имена роутов для действий контроллера
Route::get('user/profile', 'UserController@showProfile')->name('profile');

Генерирование URL-адресов для именованных роутов
именованные роуты позволяют генерировать URL-адреса и делать редирект на другой роут. когда вы назначили имя роуту, вы можете использовать это имя для генерирования URL адресов и редиректов

создание
$url = route('profile');

редирект
return redirect()->route('profile');

Если у именованного роута есть параметры, можете передать их
Route::get('user/{id}/profile', function ($id) {})->name('profile');
$url = route('profile', ['id' => 1]);

Группы роутов
позволяют использовать общие аттрибуты для группы роутов, не прописывая для каждого. аттрибуты это например посредники или пространства имен.
Общие атрибуты указываются в виде массива первым аргументом метода Route::group
Посредники применяются ко всем роутам в группе путём указания списка посредников с параметром middleware в массиве групповых атрибутов. Посредники выполняются в порядке перечисления в этом массиве

Route::middleware(['first', 'second'])->group(function () {

    Route::get('/', function () {
        // Uses first & second Middleware
    });

    Route::get('user/profile', function () {
        // Uses first & second Middleware
    });

});

Пространства имён
назначение одного пространства имён для группы роутов или контроллеров, используя параметр namespace

Доменный роутинг
Группы роутов можно использовать для обработки маршрутизации поддоменов

Префиксы роута
Метод prefix можно использовать для указания URI-префикса каждого роута в группе

Привязка модели к роуту
При внедрении ID модели в действие роута или контроллера бывает необходимо получить модель, соответствующую этому ID. Например, вместо внедрения ID пользователя вы можете внедрить весь экземпляр модели User по данному ID

Route::get('api/users/{user}', function (App\User $user) {
    return $user->email;
});

Если совпадающий экземпляр модели не найден в базе данных, будет автоматически сгенерирован HTTP-ответ 404
Если вы хотите, чтобы для получения класса данной модели вместо столбца id использовался другой столбец базы данных, вы можете переопределить метод getRouteKeyName в своей модели Eloquent

Явная привязка
Для регистрации явной привязки используйте метод роута model для указания класса для данного параметра

public function boot() {
    parent::boot();
    Route::model('user', App\User::class);
}

Затем определите роут, содержащий параметр {user}
Route::get('profile/{user}', function (App\User $user) {
});

Из-за того, что мы ранее привязали все параметры {user} к модели App\User, её экземпляр будет внедрён в роут. запрос profile/1 внедрит объект User, полученный из БД, который соответствует ID 1

CSRF-защита
Все HTML-формы, ведущие к роутам POST, PUT, DELETE, которые определены в файле роутов для web, должны иметь поле CSRF-токена

<form method="POST" action="/profile">
    {{ csrf_field() }}
</form>

Подмена методов
HTML-формы не поддерживают действия PUT, PATCH, DELETE. Поэтому при определении роутов PUT, PATCH, DELETE, вызываемых из HTML-формы, надо добавить в неё скрытое поле _method. Переданное в этом поле значение будет использовано как метод HTTP-запроса

<form action="/foo/bar" method="POST">
    <input type="hidden" name="_method" value="PUT">
    <input type="hidden" name="_token" value="{{ csrf_token() }}">
</form>

Используйте хелпер method_field, чтобы сгенерировать поле _method
{{ method_field('PUT') }}

Получение текущего роута
$route = Route::current();
$name = Route::currentRouteName();
$action = Route::currentRouteAction();



MIDDLEWARE

https://laravel.com/docs/5.5/middleware

Посредники предоставляют удобный механизм для фильтрации HTTP-запросов.
посредник для проверки аутентификации юзера - если юзер не аутентифицирован, посредник перенаправит его на страницу логина.
CORS-посредник для добавления особых заголовков ко всем ответам.
посредник логов - может зарегистрировать все входящие запросы.
стандартные посредники лежат в папке app/Http/Middleware

Создание посредника
php artisan make:middleware CheckAge
это создаст класс app/Http/Middleware/CheckAge.php

class CheckAge {

    public function handle($request, Closure $next) {

        // если переданный age < 200, то посредник вернёт редирект
        if ($request->age < 200) {
            return redirect('home');
        }

  // иначе запрос будет передан далее в приложение
        return $next($request);
    }
}

Посредник это какбы набор уровней, которые должен пройти HTTP-запрос, прежде чем он дойдёт до вашего приложения. Каждый уровень может проверить запрос и/или отклонить его. Момент, в который сработает посредник — до или после запроса, зависит от него самого.

Этот посредник выполнит некоторую задачу прежде, чем запрос будет обработан приложением
    public function handle($request, Closure $next) {
        // Выполнить действие
        return $next($request);
    }

Этот посредник выполнит задачу после того, как запрос будет обработан приложением
    public function handle($request, Closure $next) {
        $response = $next($request);
        // Выполнить действие
        return $response;
    }

Глобальный посредник
Чтобы посредник запускался для каждого HTTP-запроса в приложении, добавьте его в свойство $middleware класса app/Http/Kernel.php

Назначение посредника для роутов
Если хотите назначить посредника для конкретных роутов, добавьте посредника в файл app/Http/Kernel.php

protected $routeMiddleware = [
'auth' => \Illuminate\Auth\Middleware\Authenticate::class,
];

Когда посредник определён в HTTP-ядре, вы можете использовать метод middleware для назначения посредника роуту
Route::get('admin/profile', function () {})->middleware('auth');

Назначить несколько посредников роуту
Route::get('/', function () {})->middleware('first', 'second');

При назначении посредника можно указать полное имя класса
use App\Http\Middleware\CheckAge;
Route::get('admin/profile', function () {})->middleware(CheckAge::class);

Группы посредников
Объединить несколько посредников под одним ключом, чтобы проще назначать их на роуты. Это можно сделать при помощи свойства $middlewareGroups вашего HTTP-ядра. Изначально в Laravel есть группы посредников web и api. Группы посредников могут быть назначены роутам и действиям контроллера. Группы посредников делают проще единое назначение нескольких посредников на роут.

Route::get('/', function () {})->middleware('web');
Route::group(['middleware' => ['web']], function () {});

Изначально группа посредников web автоматически применяется к файлу routes/web.php сервис-провайдером RouteServiceProvider

Параметры посредника
В посредник можно передавать дополнительные параметры. Например, если в вашем приложении необходима проверка, есть ли у аутентифицированного пользователя определённая роль для выполнения данного действия, вы можете создать посредника CheckRole, который принимает название роли в качестве дополнительного аргумента. Дополнительные параметры посредника будут передаваться в посредник после аргумента $next

class CheckRole {

    public function handle($request, Closure $next, $role) {
        if (!$request->user()->hasRole($role)) {
            // Redirect
        }
        return $next($request);
    }

}

Параметры посредника можно указать при определении роута, отделив название посредника от параметров двоеточием :. Несколько параметров разделяются запятыми

Route::put('post/{id}', function ($id) {})->middleware('role:editor');

Посредник terminable
Иногда посредник должен выполнить некоторые действия уже после отправки HTTP-ответа браузеру. Например, посредник "session", поставляемый с Laravel, записывает данные сессии в хранилище после отправки ответа в браузер. Если вы определите метод terminate в посреднике, то он будет автоматически вызываться после отправки ответа в браузер.

public function terminate($request, $response) {
        // Store the session data
    }

Метод terminate должен получать и запрос и ответ. Определив terminable-посредника, вы должны добавить его в список посредников роута или глобальных посредников в файл app/Http/Kernel.php. При вызове метода terminate в посреднике, Laravel получит свежий экземпляр посредника из сервис-контейнера. Если вы хотите использовать тот же самый экземпляр посредника при вызовах методов handle и terminate, зарегистрируйте посредника в контейнере при помощи метода singleton.



CSRF PROTECTION

https://laravel.com/docs/5.5/csrf

CSRF это атаки с подделкой межсайтовых запросов, тип атаки при котором несанкционированные команды выполняются от имени аутентифицированного пользователя. Laravel автоматически генерирует CSRF-токен для каждой пользовательской сессии.

каждая HTML форма должна включать такой токен. есть хелпер csrf_field

<form method="POST" action="/profile">
    {{ csrf_field() }}
</form>

Посредник VerifyCsrfToken, входящий в группу посредников web, автоматически проверяет совпадение токена

CSRF-токены в JavaScript
При создании приложений, работающих на JavaScript, надо чтобы JavaScript-библиотека автоматически прикрепляла CSRF-токен к каждому исходящему запросу. по-умолчанию файл resources/assets/js/bootstrap.js регистрирует значение мета-тега csrf-token в HTTP-библиотеке Axios

Исключение URI из csrf-защиты
Обычно такие роуты помещаются вне группы посредников web, которую RouteServiceProvider применяет ко всем роутам в файле routes/web.php. Но вы также можете исключить роуты, добавив их URI в свойство $except посредника VerifyCsrfToken:

class VerifyCsrfToken extends Middleware {
    protected $except = [
        'stripe/*',
    ];
}

X-CSRF-token
Кроме проверки CSRF-токена как POST-параметра, посредник VerifyCsrfToken будет проверять заголовок запроса X-CSRF-token, поэтому хранить токен в HTML-теге

<meta name="csrf-token" content="{{ csrf_token() }}">

Указать библиотеке jQuery автоматически добавлять токен в заголовки
$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});

X-XSRF-token
Laravel хранит CSRF-токен в cookie XSRF-TOKEN, которая включается в каждый ответ. Вы можете использовать значение cookie, чтобы задать заголовок запроса X-XSRF-TOKEN. Этот cookie в основном посылается для удобства, потому что некоторые JavaScript-фреймворки, например Angular, автоматически помещают его значение в заголовок X-XSRF-TOKEN.



CONTROLLERS

https://laravel.com/docs/5.5/controllers

хранятся в папке app/Http/Controllers
Не надо определять всю логику обработки запросов в виде замыканий, в файлах роутов. Надо организовать её с помощью контроллеров. Контроллерам не обязательно наследовать базовый класс Controller, но тогда не будет методов middleware, validate, dispatch.

class UserController extends Controller {
    public function show($id) {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
}

Задать роут для этого контроллера. параметры роута будут переданы в метод
Route::get('user/{id}', 'UserController@show');

Контроллеры и пространства имён
при определении роута контроллера не надо указывать полное пространство имён контроллера. надо указать только ту часть имени класса, которая следует за частью App\Http\Controllers.

Если разместить свои контроллеры в подпапках App\Http\Controllers и если полный путь к классу например App\Http\Controllers\Photos\AdminController, то надо регистрировать роуты так:

Route::get('foo', 'Photos\AdminController@method');

Контроллеры одного действия
Для контроллера обрабатывающего всего одно действие, поместите в контроллер только метод __invoke

class UserController extends Controller {
    public function __invoke($id) {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
}

и роут для него
Route::get('user/{id}', 'ShowProfile');

Посредники контроллера
Посредников можно назначить роутам контроллера в файлах роутов:

Route::get('profile', 'UserController@show')->middleware('auth');

Лучше указать посредника в конструкторе контроллера. Можно даже ограничить использование посредника, назначив его определенным методам, или исключить всех кроме

    public function __construct() {
        $this->middleware('auth');
        $this->middleware('log')->only('index');
        $this->middleware('subscribed')->except('store');
    }

Создать контроллер
php artisan make:controller NameController
это создаст класс app/Http/Controllers/NameController.php

Контроллеры ресурсов

Создать контроллер ресурсов (с методами CRUD)
php artisan make:controller PhotoController --resource
это создаст класс app/Http/Controllers/PhotoController.php с методами: index, create, store, show, edit, update, destroy.

Роут контроллера ресурса:
Route::resource('photos', 'PhotoController');

Создать контроллер ресурсов (с методами CRUD) с экземпляром модели Eloquent\Model
php artisan make:controller NameController --resource --model=Photo

создаст контроллер app/Http/Controllers/PhotoController.php
создаст модель app/Photo.php

Подмена методов формы
HTML-формы не могут выполнять запросы PUT, PATCH или DELETE, поэтому добавить скрытое поле _method. Хелпер method_field:

{{ method_field('PUT') }}

Частичные роуты ресурсов
При объявлении роута можете указать подмножество всех возможных действий, которые должен обрабатывать контроллер (вместо полного набора стандартных действий CRUD):

Route::resource('photo', 'PhotoController', ['only' => ['index', 'show']]);
Route::resource('photo', 'PhotoController', ['except' => ['create', 'store', 'update', 'destroy']]);

Именование роутов ресурса
по-умолчанию все действия контроллера ресурсов имеют имена роутов, но вы можете переопределить эти имена, передав массив names.

Именование параметров роута ресурса
по-умолчанию Route::resource создаст параметры для ваших роутов ресурсов на основе имени ресурса в единственном числе. Это можно изменить для каждого ресурса, передав parameters в массив опций.

Локализация URI ресурсов
по-умолчанию Route::resource будет создавать URI ресурсов, используя английские глаголы. Если вам нужно локализовать глаголы действий create и edit, вы можете использовать метод Route::resourceVerbs.

Добавление дополнительных роутов в контроллеры ресурсов
Если надо добавить дополнительные роуты в контроллер ресурсов (не входящие в набор роутов ресурсов по-умолчанию CRUD), их надо определить до вызова Route::resource.

Внедрение зависимостей и контроллеры

Внедрение в конструктор

class UserController extends Controller {

    protected $users;

    // вы можете указать в качестве аргумента - тип любого Laravel-контракта.
    public function __construct(UserRepository $users) {
        $this->users = $users;
    }
}


Внедрение в метод

class UserController extends Controller {
    public function store(Request $request) {
        $name = $request->name;
    }
}

Если метод ожидает данные из параметра роута, перечислите аргументы роута после остальных зависимостей.

Если роут такой
Route::put('user/{id}', 'UserController@update');

То в методе так
public function update(Request $request, $id) {}

Кэширование роутов
Роуты на основе замыканий нельзя кэшировать.
после кеширования скорость может стать быстрее в 100 раз.
команда php artisan route:cache
если изменяли роуты то перегенерить
для очистки кэша роутов команда php artisan route:clear



REQUESTS

https://laravel.com/docs/5.5/requests

Получение экземпляра запроса в контроллере
    public function store(Request $request) {
        $name = $request->input('name');
    }

Внедрение зависимости и параметры роута

если роут с параметрами такой
Route::put('user/{id}', 'UserController@update');

то контроллер такой
public function update(Request $request, $id) {}

Обращение к запросу через замыкания роутов
Route::get('/', function (Request $request) {});

Получение пути запроса
$uri = $request->path(); // foo/bar

проверка соответствия пути заданной маске.
if ($request->is('admin/*')) {}

Получение URL запроса
$url = $request->url(); // Без строки запроса
$url = $request->fullUrl(); // Со строкой запроса

Получение метода запроса
$method = $request->method();

Проверка метода запроса
if ($request->isMethod('post')) {}

Запросы PSR-7
требует установки либ
composer require symfony/psr-http-message-bridge
composer require zendframework/zend-diactoros

Обрезка и нормализация ввода
посредники TrimStrings и ConvertEmptyStringsToNull в глобальном стеке посредников.
они обрезают все поля где строки, а пустые строки конвертят в null
посредники перечислены в стеке в классе App\Http\Kernel


Получение всех данных ввода
$input = $request->all();

Получения значения из ввода (из любого метода, post, get, итд)
$name = $request->input('name');
$name = $request->input('name', 'defaultname');

Для форм с переменными массивами
$name = $request->input('products.0.name');
$names = $request->input('products.*.name');

Получение ввода через динамические свойства
$name = $request->name;
При использовании динамических свойств Laravel сначала ищет значение параметра в данных запроса. Если его там нет, будет искать поле в параметрах роута.

Получения значения из ввода JSON
$name = $request->input('user');
$name = $request->input('user.name'); // погружаясь в массив

Получение некоторых переменных запроса
$input = $request->only(['username', 'password']);
$input = $request->only('username', 'password');
$input = $request->except(['credit_card']);
$input = $request->except('credit_card');

Получить часть входных данных, которые действительно присутствуют в запросе
$input = $request->intersect(['username', 'password']);

Была ли передана переменная?
if ($request->has('name')) {}
if ($request->has(['name', 'email'])) {} // Когда передается массив, определит присутствуют ли все указанные значения.

Старый ввод в формы сохраняется в сессию. встроенные возможности Laravel вызовут их автоматически.

Передача ввода в сессию
$request->flash(); // все поля

// или только указанные поля
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');

если требуется передать ввод в сессию и затем перенаправить на предыдущую страницу
return redirect('form')->withInput();
return redirect('form')->withInput($request->except('password'));

Получение старого ввода
хелпер old
$username = $request->old('username');

шаблон Blade
<input type="text" name="username" value="{{old('username')}}">

Получение Cookies из запросов
$value = $request->cookie('name');

Добавление cookie к ответам
return response('Hello World')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);

Генерация экземпляров Cookie
хелпер cookie
$cookie = cookie('name', 'value', $minutes);
return response('Hello World')->cookie($cookie);

Получение загруженных файлов
$file = $request->file('photo');
$file = $request->photo;

Есть ли в запросе файл
if ($request->hasFile('photo')) {}

Прошёл ли загруженный файл проверку?
if ($request->file('photo')->isValid()) {}

Пути и расширения файла
$path = $request->photo->path();
$extension = $request->photo->extension(); // на основе его содержимого

Сохранение загруженных файлов
$path = $request->photo->store('images');
store принимает путь относительно настроенного корневой папки файловой системы. путь не должен включать имя файла, он автоматически генерится UUID в качестве имени файла.

$path = $request->photo->store('images', 's3');
второй необязательный аргумент — имя диска для сохранения файла.

Если не хотите автоматически генерировать имя файла
$path = $request->photo->storeAs('images', 'filename.jpg');



RESPONSES

https://laravel.com/docs/5.5/responses

Все роуты и контроллеры должны возвращать ответ для отправки обратно в браузер.

Вернуть строку:
Route::get('/', function () {return 'Hello World';});

Вернуть массив:
Route::get('/', function () {
    return [1, 2, 3]; // вернем json
});

Вернуть объект Illuminate\Http\Response
Возврат полного экземпляра Response позволяет вам изменять HTTP-код состояния и заголовки ответов.

Route::get('home', function () {
return response('Hello World', 200)->header('Content-Type', 'text/plain');
});

Добавление заголовков в ответы
return response($content)
            ->header('Content-Type', $type)
            ->header('X-Header-One', 'Header Value')
            ->header('X-Header-Two', 'Header Value');
Или так
return response($content)
            ->withHeaders([
                'Content-Type' => $type,
                'X-Header-One' => 'Header Value',
                'X-Header-Two' => 'Header Value',
            ]);

Добавление cookie в ответы
return response($content)
                ->header('Content-Type', $type)
    ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly);

Cookies и шифрование
по-умолчанию все генерируемые cookie шифруются и подписываются. Если вы хотите отключить шифрование для определённого набора cookie, можете использовать свойство $except посредника App\Http\Middleware\EncryptCookies, который находится в папке app/Http/Middleware:

protected $except = [
    'cookie_name', // Названия тех cookie, которые не надо шифровать.
];

Редиректы
это объекты класса Illuminate\Http\RedirectResponse
Использовать хелпер redirect
Route::get('dashboard', function () {
    return redirect('home/dashboard');
});

Редирект на предыдущую страницу
хелпер back
для этого используются сессии, роут вызывающий метод back должен использовать группу посредников web или должен применять всех посредников сессий

Route::post('user/profile', function () {
    // Validate the request
    return back()->withInput();
});

Редиректы на именованные роуты
Когда вы вызываете хелпер redirect без параметров, возвращается экземпляр Illuminate\Routing\Redirector, позволяя вам вызывать любой метод объекта Redirector

return redirect()->route('login');

// Для роута с таким URI: profile/{id}
return redirect()->route('profile', ['id' => 1]);

вы можете также возвращать коллекции Eloquent из роутов и контроллеров. Они будут автоматически сконвертированы в JSON.

Заполнение параметров через модели Eloquent
Для роута с таким URI: profile/{id}
return redirect()->route('profile', [$user]);
Для изменения значения, помещённого в параметр роута, переопределите метод getRouteKey в вашей модели Eloquent

Редиректы на действие контроллера
return redirect()->action('HomeController@index')
return redirect()->action('UserController@profile', ['id' => 1]);

Редиректы с одноразовыми переменными сессии
Редирект на новый URL и передача данных в сессию обычно происходят в одно и то же время. Обычно это делается после успешного выполнения действия, когда вы передаёте сообщение об этом в сессию.

Обновление профиля пользователя с мессагой
Route::post('user/profile', function () {
    return redirect('dashboard')->with('status', 'Profile updated!');
});

Вывести одноразовую мессагу из сессии. с помощью синтаксиса Blade:
@if (session('status'))
    <div class="alert alert-success">
        {{ session('status') }}
    </div>
@endif

Ответы шаблона
хелпер view
return response()
            ->view('hello', $data, 200)
            ->header('Content-Type', $type);

Ответы JSON
автоматически задаст заголовок Content-Type для application/json, и сконвертирует массив в JSON
return response()->json(['name' => 'Abigail','state' => 'CA']);

Ответы JSONP
return response()->json(['name' => 'Abigail', 'state' => 'CA'])->withCallback($request->input('callback'));

Скачивание файлов
Метод download используется для создания ответа, получив который, браузер юзера скачивает файл по указанному пути. принимает вторым аргументом имя файла, это имя увидит юзер при скачивании файла. можете передать массив HTTP-заголовков третьим аргументом
return response()->download($pathToFile);
return response()->download($pathToFile, $name, $headers);
return response()->download($pathToFile)->deleteFileAfterSend(true); // удалить файл после отправки

Ответ отображения файла
для вывода файла (изображение или PDF) прямо в браузере, вместо запуска его скачивания
return response()->file($pathToFile);
return response()->file($pathToFile, $headers);

Макрос ответа
Если вы хотите определить свой ответ, который вы смогли бы использовать повторно в различных роутах и контроллерах, то можете использовать метод macro на фасаде Response



VIEWS

https://laravel.com/docs/5.5/views

содержат HTML-разметку
расположены в папке resources/views

Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});

первый аргумент - название файла шаблона в папке resources/views.
второй аргумент - массив с данными шаблона.

шаблоны могут находиться в подпапках внутри resources/views. Для обращения к ним использовать синтаксис с точкой
return view('admin.profile', $data);

Проверка существования шаблона
if (View::exists('emails.customer')) {}

Передача массива данных в шаблон
$data = ['name' => 'Victoria'];
return view('greetings', $data);

Передача одной переменной в шаблон
return view('greeting')->with('name', 'Victoria');

Передача данных во все шаблоны
Если надо передавать некоторые данные во все шаблоны. Это можно сделать с помощью метода share внутри метода boot сервис-провайдера. Его можно добавить в провайдер AppServiceProvider или создать отдельный провайдер.

Вью-композеры
Это функции обратного вызова или методы класса, которые вызываются при отображении шаблона. Если у вас есть данные, которые вы хотели бы отправлять в шаблон при каждом его отображении, то композеры могут помочь организовать такую логику в одном месте. Если вы создаёте новый сервис-провайдер для хранения ваших композеров, то также следует добавить его в массив providers внутри config/app.php

public function boot() {
        // Using class based composers
        View::composer(
            'profile', 'App\Http\ViewComposers\ProfileComposer'
        );
        // Using Closure based composers
        View::composer('profile', function ($view) {
            //
        });
    }

Теперь, когда мы зарегистрировали композер, метод ProfileComposer@compose будет вызываться при каждом отображении шаблона profile.

Класс композера
class ProfileComposer {
    public function compose(View $view) {
        $view->with('count', $this->users->count());
    }
}

Перед началом отображения шаблона композер вызовет метод compose с экземпляром Illuminate\View\View в качестве первого параметра. Вы можете использовать метод with для передачи данных в шаблон. Все композеры подключаются через сервис контейнер, поэтому можно применить любое внедрение зависимостей внутри конструктора композера.

Вы можете подключить к композеру несколько шаблонов одновременно. Метод composer также принимает специальный символ *

View::composer(
    ['profile', 'dashboard'],
    'App\Http\ViewComposers\MyViewComposer'
);

View::composer('*', function ($view) {});

Создатели шаблонов
View::creator('profile', 'App\Http\ViewCreators\ProfileCreator');



URL GENERATION

https://laravel.com/docs/5.5/urls

Laravel предоставляет несколько хелперов, чтобы помочь вам в создании URL-адресов для вашего приложения. Хелпер url. Сгенерированный URL-адрес будет автоматически использовать схему (HTTP или HTTPS) и хост из текущего запроса.

$post = App\Post::find(1);
echo url("/posts/{$post->id}"); // http://example.com/posts/1

текущий урл без query string
echo url()->current();

текущий урл с query string
echo url()->full();

полный урл для предыдущего запроса
echo url()->previous();

Эти методы доступны также через URL фасад:
use Illuminate\Support\Facades\URL;
echo URL::current();

Хелпер route может быть использован для создания URL-адресов для именованных роутов. Именованные роуты позволяют создавать URL-адреса без привязки к фактическому URL-адресу, определенному в роуте. Поэтому, если URL-адрес роута изменяется, изменений в вызовах не потребуется.

Роут
Route::get('/post/{post}', function () {})->name('post.show');

URL-адрес этого роута
echo route('post.show', ['post' => 1]); // http://example.com/post/1

Вы часто будете генерировать URL-адреса, используя первичный ключ моделей Eloquent. По этой причине вы можете передавать модели Eloquent в качестве значений параметров. Хелпер route будет автоматически извлечь первичный ключ модели

echo route('post.show', ['post' => $post]);

URL-адреса для действий контроллера
Функция action генерирует URL-адрес для контроллера действий
$url = action('HomeController@index');

Если метод контроллера принимает параметры роута, вы можете передать их в качестве второго аргумента функции
$url = action('UserController@profile', ['id' => 1]);

Вы можете указать стандартные значения по-умолчанию для определенных параметров URL

Route::get('/{locale}/posts', function () {})->name('post.index');

Это громоздко всегда передавать locale каждый раз, когда вы вызываете хелпер route. Вы можете использовать метод для определения значения по-умолчанию для этого параметра

    public function handle($request, Closure $next) {
        URL::defaults(['locale' => $request->user()->locale]);
        return $next($request);
    }



SESSION

https://laravel.com/docs/5.5/session

Сессии — способ сохранения информации о пользователе между отдельными запросами.
Поддерживаются Memcached, Redis, СУБД.
Настройки сессии в config/session.php.
по-умолчанию используется драйвер file.
Для увеличения производительности сессий в продакшне использовать memcached или redis.

file - сессии хранятся в storage/framework/sessions.
cookie - сессии хранятся в виде зашифрованных cookie.
database - сессии хранятся в реляционной БД.
memcached/redis - сессии хранятся в быстрых хранилищах.

Драйвер database
необходимо создать таблицу для хранения данных сессии.

Драйвер Redis
установить пакет composer predis/predis (~1.0)
настроить конфиг в config/database.php.
в конфиге config/session.php в параметре connection указать подключение Redis

Получение данных
два способа работы с данными сессии: с помощью хелпера session и через экземпляр Request.

Через Request
public function show(Request $request, $id) {
   $value = $request->session()->get('key');
   $value = $request->session()->get('key', 'default'); // второй аргумент значение по-умолчанию
}

В качестве второго аргумента можно передать замыкание (Closure), оно выполнится если нет значения

$value = $request->session()->get('key', function () {
    return 'default';
});

Через хелпер Session

Получить часть данных из сессии
$value = session('key');

Указать значение по-умолчанию
$value = session('key', 'default');

Сохранить часть данных в сессии
session(['key' => 'value']);

Получение всех данных сессии
$data = $request->session()->all();

Определение наличия элемента в сессии

Вернёт true, если значение существует и не равно null
if ($request->session()->has('users')) {}

Для проверки существования значения в сессии, даже если оно равно null
if ($request->session()->exists('users')) {}

Сохранение данных

Через экземпляр Request
$request->session()->put('key', 'value');

Через хелпер
session(['key' => 'value']);

Запись массивов в сессию
для записи нового значения в элемент сессии, который является массивом.
$request->session()->push('user.teams', 'developers');

Чтение и сразу удаление элемента
$value = $request->session()->pull('key', 'default');

Флеш-данные
Сохранить переменную в сессии только до следующего запроса
$request->session()->flash('status', 'Task was successful!');

Для сохранения одноразовых данных в течение большего числа запросов, юзать метод reflash, который оставит эти данные для следующего запроса
$request->session()->reflash();

А если надо хранить только определённые данные, то используйте метод keep
$request->session()->keep(['username', 'email']);

Удаление данных
$request->session()->forget('key'); // удалит куски данных
$request->session()->flush(); // удалит все данные

Обновление ID сессии
Laravel автоматически обновляет ID сессии во время аутентификации, если вы используете встроенный LoginController, но можно обновлять ID сессии вручную
$request->session()->regenerate();

Добавление своих драйверов сессий
Ваш драйвер сессий должен реализовывать SessionHandlerInterface. После реализации драйвера его можно зарегистрировать в фреймворке. Для добавления дополнительных драйверов для работы с сессиями в Laravel используйте метод extend фасада Session. Вам надо вызвать метод extend из метода boot сервис-провайдера. Это можно сделать в имеющемся AppServiceProvider или создать новый провайдер. Когда драйвер сессий зарегистрирован, вы можете использовать свой драйвер в своём конфиге config/session.php.



VALIDATION

https://laravel.com/docs/5.5/validation

Базовый контроллер использует трейт ValidatesRequests, который обеспечивает удобный способ валидации HTTP-запросов. Метод validate принимает экземпляр HTTP-запроса, и набор правил. если проверка не пройдена, будет выброшено исключение и сообщение об ошибке автоматически отправится обратно пользователю. Для HTTP-запроса, ответ будет перенаправлен обратно с заполненными flash-переменными, для AJAX запроса отправится JSON.

public function store(Request $request) {
    $this->validate($request, [
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);
    // The blog post is valid, store in database
}

Остановить выполнение остальных правил после первой неудачной проверки
$this->validate($request, [
    'title' => 'bail|required|unique|max:255',
]);
Для этого используется атрибут bail. если не выполняется правило required, - следующие правило unique проверяться не будет. Правила выполняются в той последовательности, в какой назначаются.

Если данные HTTP-запроса содержат "вложенные" параметры, можно указать их, используя синтаксис с точкой
$this->validate($request, [
    'author.name' => 'required',
    'author.description' => 'required',
]);

Отображение ошибок валидации
Если входящие данные не проходят проверку, Laravel автоматически перенаправляет пользователя на предыдущую страницу. Все ошибки валидации будут автоматически записаны во flash-переменные. Не надо передавать сообщения об ошибках в шаблоне роута. Laravel будет проверять наличие ошибок в текущем сеансе и автоматически привязывать их к шаблону.
Переменная $errors является экземпляром Illuminate\Support\MessageBag. $errors привязана к посреднику Illuminate\View\Middleware\ShareErrorsFromSession, который входит в группу посредников web. При использовании этого посредника, $errors всегда будет доступна в ваших шаблонах.

@if ($errors->any())
  @foreach ($errors->all() as $error)
    {{ $error }}
  @endforeach
@endif


Null поля
в Laravel включены глобальные посредники TrimStrings и ConvertEmptyStringsToNull. Они перечислены в свойстве $middleware класса App\Http\Kernel. Из-за этого нужно часто помечать дополнительные поля как nullable, если не нужно, чтобы валидатор считал недействительным значение null.

$this->validate($request, [
    'publish_at' => 'nullable|date',
]);

указываем что поле publish_at может быть null или должно содержать дату. Если модификатор nullable не добавляется в правило, проверяющий элемент будет рассматривать null как недопустимую дату.

Настройка формата вывода ошибок
Если хотите настроить вывод ошибок валидации, которые будут во flash-переменных после нарушений правил, переопределите метод formatValidationErrors в базовом контроллере.

AJAX запросы и валидация
При использовании метода validate во время запроса AJAX, Laravel генерирует ответ с JSON данными, содержащий в себе все ошибки проверки. Этот ответ будет отправлен с кодом состояния HTTP 422

Валидация FormRequest
Form Requests это специальные классы, которые содержат в себе логику проверки.

Создать валидацию FormRequest
php artisan make:request StoreBlogPost
это создаст класс app/Http/Requests/StoreBlogPost.php

и там в методе rules писать правила
public function rules() {
    return [
        'title' => 'required|unique|max:255',
        'body' => 'required',
    ];
}

Потом указать класс FormRequest в аргументах метода вашего контроллера. Входящий запрос перед вызовом метода контроллера будет валидироваться автоматически, что позволит не загромождать контроллер логикой валидации.

public function store(StoreBlogPost $request) {
    // Действительный входящий запрос
}

Если проверка не пройдена, то ошибки будут записываться в сессию и будут доступны в шаблонах. Если был AJAX-запрос, HTTP-ответ с кодом 422 будет возвращен, включая JSON с ошибками валидации.

Добавление хуков в FormRequest
Хук After можно добавить через метод withValidator. Этот метод получает полностью сформированный валидатор, позволяя вызвать любой из его методов, прежде чем фактически применяются правила

public function withValidator($validator) {
    $validator->after(function ($validator) {
        if ($this->somethingElseIsInvalid()) {
            $validator->errors()->add('field', 'Something is wrong with this field!');
        }
    });
}

Авторизация FormRequest (проверка на роль)
В методе authorize можно проверить имеет ли аутентифицированный юзер права на выполнение данного запроса. Например, можно проверить, есть ли у пользователя право для добавления комментариев в блог

public function authorize() {
    $comment = Comment::find($this->route('comment'));
    return $comment AND $this->user()->can('update', $comment);
}

Так как все FormRequest расширяют базовый класс Request, мы можем использовать метод user, чтобы получить доступ к текущему пользователю. Метод route предоставляет доступ к параметрам URI, определенным в роуте. Если метод authorize возвращает false, автоматически генерируется ответ с кодом 403 и метод контроллера не выполняется.

Если же логика авторизации организована в другом месте вашего приложения, просто верните true из метода authorize

public function authorize() {
    return true;
}

Настройка формата вывода ошибок
Если вы хотите настроить формат вывода ошибок валидации, которые будут заполнять flash-переменные при неудачном выполнении, переопредилите метод formatErrors в вашем базовом Request (App\Http\Requests\Request)

Настройка сообщений об ошибках (свой текст)
Вы можете кастомизировать сообщения об ошибках, используя в FormRequest метод messages. Этот метод должен возвращать массив атрибутов/правил и их соответствующие сообщения об ошибках

Создание валидаторов вручную
Если вы не хотите использовать трейт ValidatesRequests и его метод validate, можно создать экземпляр валидатора вручную с помощью фасада Validator

$validator = Validator::make(

//получаем данные для проверки
$request->all(),

//правила проверки, которые должны применяться к данным
    [
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);

    if ($validator->fails()) {

  return redirect('post/create')

        //метод withErrors для загрузки ошибок во flash-переменные. переменная $errors будет автоматически передаваться в ваши макеты, после редиректа
            ->withErrors($validator)
            ->withInput();
    }

Автоматическое перенаправление
Если вы хотите создать экземпляр валидации вручную, но все же воспользоваться автоматическим редиректом трейта ValidatesRequest, можно вызвать метод validate

Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();

MessageBag
Если у вас есть несколько форм на одной странице, которые необходимо провалидировать, вам понадобится MessageBag — он позволяет получать сообщения об ошибках для определенной формы.

Хук после валидации
Валидатор также позволяет вам использовать функции обратного вызова после завершения всех проверок. Это позволяет легко выполнять дальнейшие проверки и даже добавить больше сообщений об ошибках в коллекции сообщений.

Работа с сообщениями об ошибках

Получить первое сообщения об ошибке для заданного поля
$errors = $validator->errors();
echo $errors->first('email');

Получить все сообщения об ошибках для заданного поля
foreach ($errors->get('email') as $message) {}

Если выполняется проверка поля формы с массивом, можно получить все сообщения для каждого из элементов массива с помощью символа *

foreach ($errors->get('attachments.*') as $message) {}

Получение всех сообщений об ошибках для всех полей
foreach ($errors->all() as $message) {}

Определить наличие сообщения об ошибке для заданного поля
if ($errors->has('email')) {}

Пользовательские сообщения об ошибках

$messages = [
    //тут свой текст. :attribute будет заменен на имя проверяемого поля
    'required' => 'The :attribute field is required.',
 'same'    => 'The :attribute and :other must match.',
    'size'    => 'The :attribute must be exactly :size.',
];
$validator = Validator::make($input, $rules, $messages);

Иногда есть необходимость указать своё сообщение для конкретного поля и для конкретного правила
$messages = [
    'email.required' => 'We need to know your e-mail address!',
];

Указание своих сообщений в файлах локализации
Также можно определять сообщения в файле локализации вместо того, чтобы передавать их в валидатор напрямую.

Указание пользовательских атрибутов в файлах локализации
Если вы хотите, чтобы :attribute был заменен на кастомное имя, можно указать в массиве attributes файле локализации resources/lang/xx/validation.php

Доступные правила валидации
Accepted, Active URL, After (Date), After Or Equal (Date), Alpha, Alpha Dash, Alpha Numeric, Array
Before (Date), Before Or Equal (Date), Between, Boolean
Confirmed
Date, Date Format, Different, Digits, Digits Between, Dimensions (Image Files), Distinct
E-Mail
Exists (Database)
File, Filled
Image (File), In, In Array, Integer, IP Address
JSON
Max, MIME Types, MIME Type By File Extension, Min
Nullable, Not In, Numeric
Present
Regular Expression, Required, Required If, Required Unless, Required With, Required With All, Required Without, Required Without All
Same, Size, String
Timezone
Unique (Database), URL

Добавление правил с условиями

Валидация при наличии поля
Иногда вам нужно проверить некое поле только тогда, когда оно присутствует во входных данных. Для этого добавьте правило sometimes.

Сложная составная проверка
Например, потребовать поле, только если другое поле имеет значение большее, чем 100. Или понадобится два поля, когда другое поле присутствует. Первый аргумент, переданный в метод sometimes это имя поля, которое мы условно проверяем. Второй аргумент — правила, которые мы хотим добавить.

Валидация массивов
проверить, что каждая последующая электронная почта является уникальной
$validator = Validator::make($request->all(), [
    'person.*.email' => 'email|unique:users',
    'person.*.first_name' => 'required_with:person.*.last_name',
]);

Скрытые расширения
по-умолчанию, когда проверяемый атрибут отсутствует или содержит пустое значение, как в правиле required, валидация не выполняется, в том числе и для ваших расширений. Например, unique не будет выполнено для значения null:

$rules = ['name' => 'unique'];
$input = ['name' => null];
Validator::make($input, $rules)->passes(); // true

Правило должно подразумевать, что атрибут обязателен, даже если он пуст. Для создания «скрытых» расширений используйте метод

Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {
    return $value == 'foo';
});



ERRORS & LOGGING

https://laravel.com/docs/5.5/errors

обработка ошибок и исключений уже настроена
Laravel использует библиотеку Monolog
Параметр debug в файле настроек config/app.php по-умолчанию установлен в соответствии со значением переменной среды APP_DEBUG, которая в файле .env.
Для локальной разработки APP_DEBUG = true, для продакшена false
Laravel поддерживает запись журналов в единые файлы single, в отдельные файлы для каждого дня daily, в syslog и errorlog. Для выбора уровня изменить параметр log в файле config/app.php.
При использовании режима daily Laravel хранит логи за 5 дней
Laravel сохраняет в журнал события всех уровней.
на продакшене задать минимальный уровень серьёзности который необходимо заносить в журнал, добавив параметр log_level в конфиг app.php
при log_level равном error будут записываться события error, critical, alert и emergency.
уровни серьёзности — от меньшего к большему: debug, info, notice, warning, error, critical, alert, emergency.

Обработчик исключений
Все исключения обрабатываются классом App\Exceptions\Handler. Этот класс содержит 2 метода: report и render. Метод report используется для занесения исключений в журнал или отправки их во внешний сервис, такой как Bugsnag или Sentry.

Игнорирование исключений заданного типа
Свойство обработчика исключений $dontReport в файле app/Exceptions/Handler.php содержит массив с типами исключений, которые не будут заноситься в журнал.

protected $dontReport = [
    \Illuminate\Auth\AuthenticationException::class,
    \Illuminate\Auth\Access\AuthorizationException::class,
    \Symfony\Component\HttpKernel\Exception\HttpException::class,
    \Illuminate\Database\Eloquent\ModelNotFoundException::class,
    \Illuminate\Validation\ValidationException::class,
];

Метод render отвечает за конвертацию исключения в HTTP-ответ, который должен быть возвращён браузеру. по-умолчанию исключение передаётся в базовый класс, который генерирует для вас ответ.

HTTP-исключения
Хелпер abort
abort(404);
abort(403, 'Unauthorized action.');

Пользовательские страницы HTTP-ошибок
создавайте файлы типа resources/views/errors/404.blade.php
Представления в этой папке должны иметь имена, соответствующие кодам ошибок.
Экземпляр HttpException, созданный функцией abort, будет передан в представление как переменная $exception
<h2>{{ $exception->getMessage() }}</h2>

Логирование
по-умолчанию Laravel настроен на создание файла журнала в папке storage/logs
Можно записывать информацию в журнал при помощи фасада Log
Log::info('Showing user profile for user: '.$id);

Регистратор событий предоставляет восемь уровней логирования
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

в методы логирования можно передать массив данных

Log::info('User failed to login.', ['id' => $user->id]);



BLADE TEMPLATES

https://laravel.com/docs/5.5/blade

Шаблонизатор поставляемый с Laravel.
Все шаблоны Blade скомпилированы в чистый PHP-код и кешированы
Файлы шаблонов Blade используют расширение .blade.php и хранятся в папке resources/views

Макет

<html>
    <head>
        <title>@yield('title')</title>
    </head>
    <body>
        @section('sidebar')
            master sidebar.
        @show

        <div class="container">
            @yield('content')
        </div>
    </body>
</html>

Два основных преимущества использования Blade — наследование шаблонов и секции.
@section определяет секцию содержимого
@yield используется для отображения содержимого заданной секции

Наследование макета

@extends('layouts.app')
@section('title', 'Page Title')
@section('sidebar')
    @
    <p>Это дополнение к основной боковой панели.</p>
@endsection
@section('content')
    <p>Это содержимое тела страницы.</p>
@endsection

В этом примере секция sidebar использует директиву @ для дополнения (а не перезаписи) содержимого к боковой панели макета. Директива @ будет заменена содержимым макета при отрисовке шаблона.

При определении дочернего шаблона используйте @extends для указания макета, который должен быть "унаследован" дочерним шаблоном.
Шаблоны, которые наследуют макет, могут внедрять содержимое в секции макета с помощью @section.
Содержимое этих секций будет отображено в макете при помощи @yield

Компоненты и слоты

Компоненты и слоты предоставляют аналогичные преимущества для секций и макетов.

Создаем повторно используемый компонент
<!-- /resources/views/alert.blade.php -->
<div class="alert alert-danger">
    {{ $slot }}
</div>
Переменная {{ $slot }} будет соджержать контент, который мы хотим внедрить в компонент

Теперь чтобы сконструировать этот компонент используем директиву @component
@component('alert')
    <strong>Ой!</strong> Что-то пошло не так!
@endcomponent

Можно определить несколько слотов для компонента
<!-- /resources/views/alert.blade.php -->
<div class="alert alert-danger">
    <div class="alert-title">{{ $title }}</div>
    {{ $slot }}
</div>

Теперь можем внедрить контент в именованный слот, используя директиву @slot. Любой контент, не входящий в директиву @slot, будет передан компоненту в переменной $slot

@component('alert')
    @slot('title')
        Forbidden
    @endslot
    You are not allowed to access this resource!
@endcomponent

Передача дополнительных данных компоненту
@component('alert', ['foo' => 'bar'])
    //
@endcomponent

Отображение данных
Можно отобразить переданные в шаблон данные обернув переменные в фигурные скобки {{}}

Роут
Route::get('greeting', function () {
    return view('welcome', ['name' => 'Samantha']);
});

Отобразить содержимое переменной
Hello, {{ $name }}

Можно писать любой пхп код в оператор вывода {{}}
The current UNIX timestamp is {{ time() }}

Оператор {{}} автоматически отправляется через PHP-функцию htmlspecialchars для предотвращения XSS-атак.

Вывод неэкранированных данных
Hello, {!! $name !!}

Blade и JavaScript
Поскольку многие JavaScript-фреймворки тоже используют фигурные скобки для обозначения того, что данное выражение должно быть отображено в браузере, то вы можете использовать символ @, чтобы указать механизму отрисовки Blade, что выражение должно остаться нетронутым. В этом примере Blade удалит символ @, но выражение {{ name }} останется нетронутым, что позволит вашему JavaScript-фреймворку отрисовать его вместо Blade.
Hello, @{{ name }}

Если вы выводите JavaScript-переменные в большой части вашего шаблона, вы можете обернуть HTML директивой @verbatim , тогда вам не нужно будет ставить символ @ перед каждым оператором вывода Blade

@verbatim
    <div class="container">
        Hello, {{ name }}
  My name is, {{ operator }}
    </div>
@endverbatim

Управляющие конструкции
условия @if, @elseif, @else и @endif
проверки @isset, @empty
циклы @for, @foreach, @forelse, @while
@continue, @break
@continue($user->type == 1)
@break($user->number == 5)

При работе с циклами внутри цикла будет доступна переменная $loop
$loop->first
$loop->last
$loop->parent->first
всего 8 методов там

Комментарии
Blade-комментарии не включаются в HTML-код, возвращаемый вашим приложением
{{-- Этого комментария не будет в итоговом HTML --}}

Для выполнения блока чистого PHP в вашем шаблоне
@php
    //
@endphp

Включение подшаблонов
Включение подшаблонов является повторение функционала компонентов, только в "старом" стиле.
Blade-директива @include позволяет вам включать Blade-шаблон в другой шаблон. Все переменные, доступные родительскому шаблону, будут доступны и включаемому шаблону.
@include('shared.errors')
@include('view.name', ['some' => 'data'])
Если вы хотите включить шаблон, которого может не существовать, вам надо использовать директиву @includeIf
Если вы хотите включить (@include) шаблон в зависимости от логического условия, можно использовать директиву @includeWhen

Отрисовка шаблонов для коллекций
@each('view.name', $jobs, 'job', 'view.empty')
Первый аргумент — часть шаблона, которую надо отрисовать для каждого элемента массива или коллекции. Второй аргумент — массив или коллекция для перебора, а третий — имя переменной, которое будет назначено для текущей итерации в шаблоне. Четвёртый аргумент - определяет шаблон, который будет отрисовано, если данный массив пуст.

Стеки
Именованные стеки, которые могут быть отрисованы где-нибудь ещё в другом шаблоне или макете. Это удобно в основном для указания любых JavaScript-библиотек, требуемых для ваших дочерних шаблонов

@push('scripts')
    <script src="/example.js"></script>
@endpush

"Пушить" в стек можно сколько угодно раз. Для отрисовки всего содержимого стека передайте имя стека в директиву @stack

<head>
    @stack('scripts')
</head>

Внедрение сервисов
Извлечения сервиса из сервис-контейнера Laravel

@inject('metrics', 'App\Services\MetricsService')
<div>
    Месячный доход: {{ $metrics->monthlyRevenue() }}.
</div>

Наследование
Blade позволяет вам определять свои директивы с помощью метода directive. После изменения логики директивы Blade вам надо удалить все кешированные шаблоны Blade. Это можно сделать Artisan-командой view:clear



LOCALIZATION

https://laravel.com/docs/5.5/localization

Языковые строки хранятся в файлах, располагающихся внутри папок
resources/lang/en
resources/lang/ru
итд

Все языковые файлы возвращают простой массив ключей и строк.

Настройка локали
Основной язык вашего приложения указан в конфиге locale в config/app.php
Запасной язык вашего приложения указан в конфиге fallback_locale в config/app.php, он будет использоваться когда в основном нет строки перевода.

Изменить язык в процессе работы
App::setLocale($locale);

Определение и проверка текущей локали
$locale = App::getLocale();
if (App::isLocale('en')) {}

Использование кратких ключей
return [
    'welcome' => 'Welcome to our application'
];

Использование строк перевода как ключей, они хранятся в JSON
resources/lang/es.json:
{
    "I love programming.": "Me encanta la programación."
}

Получение строк перевода
Функция __. Она принимает файл.ключ строки перевода. Если запрошенной строки перевода не существует, то функция __ вернёт ключ строки перевода.
echo __('messages.welcome');
echo __('messages.bye');
echo __('I love programming.'); // wtf

Используя шаблонизатор Blade
{{ __('messages.welcome') }}
@lang('messages.welcome')

Подстановка параметров в строках перевода
'welcome' => 'Welcome, :name',
echo __('messages.welcome', ['name' => 'dayle']);

Если ваш плейсхолдер содержит только прописные буквы, или только первая буква является прописной, то переведённое значение будет преобразовано также
'welcome' => 'Welcome, :NAME', // Welcome, DAYLE
'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle

Плюрализация
С помощью символа "вертикальной черты" вы можете разграничить одиночную и множественную форму строки:
'apples' => 'There is one apple|There are many apples',
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',
echo trans_choice('messages.apples', 10);

Переопределение языковых файлов пакета
Некоторые пакеты могут поставляться со своими языковыми файлами. Вместо изменения корневых файлов пакета для внесения изменений в языковые строки, вы можете переопределить их, поместив файлы в папку resources/lang/vendor/{package}/{locale}



FRONTEND SCAFFOLDING

https://laravel.com/docs/5.5/frontend

По-умолчанию установлены Bootstrap и Vue.
Использовать npm для установки фронтенд-пакетов.
Laravel Mix компилирует SASS и LESS.
Файл package.json содержит пакет bootstrap-sass. В него добавлять/удалять пакеты.
Перед компилированием css установить зависимости фронтенда через node.js (NPM) и npm install.
Потом с помощью Laravel Mix скомпилировать SASS и LESS в чистый CSS.
Команда npm run dev обрабатывает инструкции из файла webpack.mix.js.
Скомпилированные scss-ресурсы будут помещены в папку public/css.
В стандартном варианте webpack.mix.js компилирует resources/assets/sass/app.scss, вы можете изменять его.

Написание javascript
Все javascript-зависимости в файле /package.json
Все php-зависимости в файле /composer.json

Установить зависимости
npm install
composer install

По-умолчанию в package.json только axios, bootstrap-sass, jquery, laravel-mix, lodash, vue. Вы можете добавить/удалить свои пакеты. После установки пакетов выполнить npm run dev для компилирования ресурсов. Скомпилированные js-ресурсы будут помещены в папку public/js.

Команда npm run dev выполнит инструкции из webpack.mix.js. По-умолчанию там только одна запись. С помощью сцепки методов вы можете гибко определить свой конвейер сборки.
mix.js('resources/assets/js/app.js', 'public/js')
   .sass('resources/assets/sass/app.scss', 'public/css');

В файле resources/assets/js/app.js зарегистрированы компоненты Vue, также там загружается bootstrap.js, который загружает и настраивает Vue, Axios, jQuery, и все остальные javaScript-зависимости.

Написание компонентов Vue
По-умолчанию есть только Vue-компонент ExampleComponent.vue в папке resources/assets/js/components который зарегистрирован в app.js. Для использования компонента просто разместить его в HTML-шаблоне

@extends('layouts.app')
@section('content')
    <example></example>
@endsection

Выполнять команду npm run dev после каждого изменения в Vue-компоненте. Или выполнить команду npm run watch для автоматического отслеживания и перекомпилирования.



COMPILING ASSETS

https://laravel.com/docs/5.5/mix

Laravel Mix это инструмент для инструкций сборки Webpack.

Установка Node.js
node -v
npm -v

Установка Laravel Mix
Файл package.json по-умолчанию включает все необходимое для начала.

Установить зависимости, командой
npm install

Если на Windows то запускать команду
npm install --no-bin-links

Запуск Laravel Mix

Запустить все задачи
npm run dev

Запустить все задачи и минифицировать вывод
npm run production

Отслеживание изменений
Команда npm run watch будет следить за всеми изменениями ресурсов и перекомпилировать.

Если Webpack не обновляется, запустить команду
npm run watch-poll

Работа с CSS
Файл инструкций webpack.mix.js, это легкая оболочка над Webpack.

Компилирование LESS
mix.less('resources/assets/less/app.less', 'public/css');
Можно задать имя файла
mix.less('resources/assets/less/app.less', 'public/stylesheets/styles.css');

Компилирование SASS
mix.sass('resources/assets/sass/app.sass', 'public/css')
   .sass('resources/assets/sass/admin.sass', 'public/css/admin');

Компилирование Stylus
Stylus почти аналог Less и Sass.
mix.stylus('resources/assets/sass/app.sass', 'public/css')

PostCSS
Это инструмент трансформации CSS. Laravel Mix пользуется плагином Autoprefixer для автоматического применения вендор-префиксов CSS3.

Добавить свои плагины
Сначала нужно установить плагины через NPM, затем обратиться к ним в webpack.mix.js

Слитие всех CSS в 1 файл
mix.styles(
    [
    'public/css/vendor/normalize.css',
    'public/css/vendor/videojs.css'
 ],
 'public/css/all.css'
);

Обработка URL
Абсолютные пути в любом выражении url() исключены из перезаписывания

.example {background: url('../images/example.png');}

по-умолчанию Laravel Mix и Webpack найдут example.png, скопируют их в папку public/images, затем перезапишут url() так

.example {background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e);}

Можно отключить перезаписывание и путь останется оригинальным

mix.sass('resources/assets/app/app.scss', 'public/css').options({processCssUrls: false});

Работа с javascript
mix.js('resources/assets/js/app.js', 'public/js');

Одной этой строкой кода происходит компилирование ECMAScript 2015, бандлинг модулей, минификация, конкатенация JavaScript-файлов.

Если часто обновляете javascript, то можно вынести внешние библиотеки в отдельный файл. Метод extract принимает массив всех библиотек или модулей, которые вы бы хотели извлечь в файл vendor.js
mix.js('resources/assets/js/app.js', 'public/js').extract(['vue'])

Тогда будет сгенерировано

public/js/manifest.js - Webpack manifest runtime
public/js/vendor.js - Ваши библиотеки
public/js/app.js - Код вашего приложения

Загрузить файлы в таком же порядке
<script src="/js/manifest.js"></script>
<script src="/js/vendor.js"></script>
<script src="/js/app.js"></script>

Слитие всех JS в 1 файл
mix.scripts(
    [
    'public/js/admin.js',
    'public/js/dashboard.js'
 ],
 'public/js/all.js'
);

Настройка Webpack
Файл настроек webpack.config.js

Копирование файлов и папок
mix.copy('node_modules/foo/bar.css', 'public/css/bar.css');
mix.copyDirectory('assets/img', 'public/img');

Версии файлов и очистка кэша
Чтобы браузер загружал свежие ресурсы. Метод version автоматически добавит уникальный хеш к именам всех скомпилированных файлов.
mix.js('resources/assets/js/app.js', 'public/js').version();

Тогда в HTML-шаблонах писать так
<link rel="stylesheet" href="{{ mix('/css/app.css') }}">

Но во время разработки это не нужно, поэтому запускать только в режиме продакшена (npm run production)
mix.js('resources/assets/js/app.js', 'public/js');
if (mix.inProduction()) {
    mix.version();
}

Тулза BrowserSync
https://browsersync.io
Автоматически обновляет браузер при изменениях
Метод mix.browserSync()



AUTHENTICATION

https://laravel.com/docs/5.5/authentication

Конфиг аутентификации
config/auth.php

Гварды
Определяют как аутентифицируются пользователи для каждого запроса, например через гвард session.

Провайдеры
Определяют как извлекаются пользователи из источника, например через Eloquent или конструктор запросов.
Для провайдера Eloquent есть модель Eloquent App\User в папке app.
Для провайдера database использовать конструктор запросов.

Столбцы
столбец паролей не менее 60 символов.
столбец remember_token на 100 символов, в нем хранятся ключи сессий «запомнить меня».

Создать аутентификацию на свежем приложении
php artisan make:auth (создаст контроллеры, вьюхи, роуты, макет)
php artisan migrate (создаст в бд таблицы migrations, users, password_resets)

Перейти по адресу http://domain.com/register

Будут сгенерены
- 4 шаблона в папке resources/views/auth
- контроллер app/Http/Controllers/HomeController, с шаблоном resources/views/home.blade.php, с роутом /home куда попадаешь после логина
- макет resources/views/layouts/app.blade.php
- все роуты
- в папке app/Http/Controllers/Auth контроллеры:
    ForgotPasswordController - отправка ссылок на сброс пароля
    LoginController - аутентификация пользователя
    RegisterController - регистрация пользователя
    ResetPasswordController - логика сброса паролей

Изменить /home можно в свойстве redirectTo, контроллеров LoginController, RegisterController, ResetPasswordController, или в методе redirectTo

protected $redirectTo = '/';

protected function redirectTo() {
    return '/path';
}

По-умолчанию для аутентификации используется поле email, это можно изменить в методе username в LoginController.

в классе RegisterController можно изменить набор полей для формы регистрации, или способа добавления пользователей в бд. Метод create класса отвечает за создание новых записей App\User в бд с помощью Eloquent

залогиненный юзер
$user = Auth::user();

id залогиненного юзера
$id = Auth::id();

если юзер залогинен, то получить его можно через Illuminate\Http\Request
$request->user();

проверка что залогинен
if (Auth::check()) {}

Доступ к роуту только аутентифицированным пользователям
Route::get('profile', function () {
    // только аутентифицированные пользователи могут зайти
})->middleware('auth');

Если вы используете контроллеры, то можете вызвать метод middleware из конструктора контроллера, вместо присоединения его напрямую к определению роута

public function __construct() {
    $this->middleware('auth');
}

Ограничение числа неудачных попыток входа
по-умолчанию юзер не сможет войти в приложение в течение одной минуты, если он несколько раз указал неправильные данные для входа.

Ручная аутентификация пользователей
if (Auth::attempt(['email' => $email, 'password' => $password])) {
    // Аутентификация успешна
    return redirect()->intended('dashboard');
}
Метод attempt вернет true, если аутентификация прошла успешно.
Метод intended сделает редирект к тому URL, к которому он обращался до того, как был перехвачен фильтром аутентификации.

Указание дополнительных условий
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
    // Юзер активен, не приостановлен и существует.
}

Разлогин
Auth::logout();

Функциональность "запомнить меня".
Сохранит пользователя аутентифицированным на неопределённое время, пока он вручную не выйдет из системы. Таблица users должна содержать столбец remember_token который хранит токены "запомнить меня".

if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
    // Юзер запомнен
}

Определить, аутентифицировался ли юзер, используя cookie "запомнить меня"

if (Auth::viaRemember()) {}

Залогинить существующий экземпляр пользователя

Войти
Auth::login($user);

Войти и "запомнить"
Auth::login($user, true);

С указанием какой гвард использовать
Auth::guard('admin')->login($user);

Войти по ID юзера
Auth::loginUsingId(1);

Войти и "запомнить" по ID юзера
Auth::loginUsingId(1, true);

Однократная аутентификация
Для логина только для одного запроса. Сеансы и cookies не будут использоваться, что может быть полезно при создании API без сохранения состояний

if (Auth::once($credentials)) {}

HTTP-аутентификация
Route::get('profile', function () {
    // только аутентифицированные пользователи могут зайти
})->middleware('auth.basic');
вы автоматически получите запрос данных для входа при обращении к роуту через браузер

HTTP-аутентификация без сохранения состояния
Route::get('api/user', function () {
    // только аутентифицированные пользователи могут зайти
})->middleware('auth.basic.once');

Добавление своих гвардов
Вы можете определить свои гварды аутентификации, используя метод extend фасада Auth.

Добавление своих провайдеров пользователей
Если вы не используете традиционную реляционную базу данных для хранения пользователей, вам необходимо добавить в Laravel свой провайдер аутентификации пользователей.

События
Laravel генерирует различные события в процессе аутентификации. Вы можете прикрепить слушателей к этим событиям в вашем EventServiceProvider



API AUTHENTICATION

https://laravel.com/docs/5.5/passport

API использует токены для аутентификации пользователей, и не сохраняет состояние сессии между запросами. Laravel Passport предоставляет полную реализацию сервера OAuth2.

composer require laravel/passport

зарегистрируйте сервис-провайдер Passport в массиве providers в config/app.php
Laravel\Passport\PassportServiceProvider::class

Миграции Passport создадут таблицы для хранения клиентов и токенов доступа
php artisan migrate

Создать ключи шифрования для генерирования токенов доступа
php artisan passport:install
php artisan passport:keys

Добавить трейт Laravel\Passport\HasApiTokens в свою модель App\User

Вызвать метод Passport::routes из метода boot своего AuthServiceProvider

В config/auth.php задать значение passport параметру driver защитника аутентификации

Passport поставляется с JSON API, который можно использовать, чтобы разрешить вашим пользователям создавать клиентов и персональные токены доступа.

События
Passport создаёт события при выдаче и обновлении токенов доступа.



AUTHORIZATION

https://laravel.com/docs/5.5/authorization

Авторизация это способ авторизовать действия пользователя в отношении данного ресурса. Есть два основных способа авторизации действий: шлюзы и политики. Думайте о шлюзах и политиках, как о роутах и контроллерах.

Шлюзы наиболее применимы к действиям, которые не связаны с какой-либо моделью или ресурсом, например, просмотр панели администратора. Политика должна быть использована, если вы хотите разрешить действие для конкретной модели или ресурса.

Шлюзы (Gate)
Это замыкания, которые определяют, имеет ли юзер право выполнить данное действие

Gate::define('update-post', function ($user, $post) {
    return $user->id == $post->user_id;
});
или так
Gate::define('update-post', 'PostPolicy@update');

Шлюзы ресурсов
Gate::resource('posts', 'PostPolicy');
это аналогично
Gate::define('posts.view', 'PostPolicy@view');
Gate::define('posts.create', 'PostPolicy@create');
Gate::define('posts.update', 'PostPolicy@update');
Gate::define('posts.delete', 'PostPolicy@delete');
можно и так
Gate::resource('posts', 'PostPolicy', [
    'photo' => 'updatePhoto',
    'image' => 'updateImage',
]);

Авторизация действий
Чтобы авторизовать действие с помощью шлюзов нужно использовать методы allows или denies

if (Gate::allows('update-post', $post)) {
    // юзер может обновить пост
}

if (Gate::denies('update-post', $post)) {
    // юзер не может обновить пост
}

можно и так

if (Gate::forUser($user)->allows('update-post', $post)) {
    // юзер может обновить пост
}

if (Gate::forUser($user)->denies('update-post', $post)) {
    // юзер не может обновить пост
}

Политики

Политики являются классами, организующими логику авторизации вокруг конкретной модели или ресурса. Например, если ваше приложение является блогом, у вас может быть модель Post и соответствующая политика PostPolicy.

Cоздать политику
php artisan make:policy PostPolicy
это создаст класс app/Policies/PostPolicy.php

Создать политику с методами CRUD
php artisan make:policy PostPolicy --model=Post

Зарегистрировать политику в классе app/Providers/AuthServiceProvider.php

protected $policies = [
    Post::class => PostPolicy::class,
];

Далее вы можете добавить методы для всех действий, которые она авторизует. Например определим метод update класса PostPolicy, который определяет может ли данный юзер User обновить данный экземпляр Post.

class PostPolicy {
    public function update(User $user, Post $post) {
        return $user->id === $post->user_id;
    }
}

Разрешить все действия политики, например админу
Определите в политике метод before

Запретить все действия политики
Вернуть false из метода before


Авторизация действий с помощью политик

Через модель пользователя
if ($user->can('update', $post)) {}
if ($user->cant('update', $post)) {}

Действия которые не требуют моделей
if ($user->can('create', Post::class)) {
    // выполняет метод «create» в политике
}

Через посредников
С помощью посредников, которые могут авторизовать действия до того, как входящий запрос достигнет роутов или контроллеров.

Route::put('/post/{post}', function (Post $post) {
    // юзер может обновить пост
})->middleware('can:update,post');

Действия которые не требуют моделей

Route::post('/post', function () {
    // юзер может создать пост
})->middleware('can:create,App\Post');

Через хелперы контроллера

public function update(Request $request, Post $post) {
    $this->authorize('update', $post);
    // юзер может обновить пост
}

Действия которые не требуют моделей

public function create(Request $request) {
    $this->authorize('create', Post::class);
 // юзер может создать пост
}

Через шаблоны Blade
Если требуется отобразить часть страницы, только если юзер авторизован выполнить данное действие. Директивы @can и @cannot. Эти директивы являются удобными краткими записями заявлений @if и @unless. Директивы @can и @cannot можно разложить следующим образом

@if (Auth::user()->can('update', $post))
    // юзер может обновить пост
@endif

@unless (Auth::user()->can('update', $post))
    // юзер не может обновить пост
@endunless


Действия которые не требуют моделей

@can('create', App\Post::class)
    // юзер может создать пост
@endcan

@cannot('create', App\Post::class)
    // юзер не может создать пост
@endcannot



ENCRYPTION

https://laravel.com/docs/5.5/encryption

Используется OpenSSL для шифрования, по алгоритмам AES-256 и AES-128.
Задать ключ key в config/app.php, или использовать команду
php artisan key:generate - сгенерить или прописать руками в .env 32-символьный ключ.

Шифровать значение
$crypted= encrypt('string');

Расшифровать значение
$decrypted = decrypt($crypted);

Шифровать без сериализации
При шифровании значения подвергаются "сериализации", что позволяет шифровать объекты и массивы. Если хотите зашифровать/расшифровать без сериализации

$encrypted = Crypt::encryptString('Hello world.');
$decrypted = Crypt::decryptString($encrypted);



HASHING

https://laravel.com/docs/5.5/hashing

Используется bcrypt-хеширование для хранения паролей. Встроенные классы LoginController и RegisterController уже используют это

$request->user()->fill(
    [
    'password' => Hash::make($request->newPassword)
    ]
)->save();

Сравнить строку и хеш
if (Hash::check('plain-text', $hashedPassword)) {
    // пароли совпадают
}

Проверка необходимости повторного хеширования пароля
Проверить изменилась ли используемая сложность хеширования паролей, с момента создания хешей

if (Hash::needsRehash($hashed)) {
    $hashed = Hash::make('plain-text');
}



PASSWORD RESET

https://laravel.com/docs/5.5/passwords

Чтобы использовать функции сброса пароля, модель User должна иметь трейт Illuminate\Notifications\Notifiable

Создать аутентификацию
php artisan make:auth

Перейти на http://domain.com/register
Все роуты будут сгенерены
Шаблоны для сброса пароля resources/views/auth/passwords

Создать таблицу хранения токенов сброса пароля
в папке database/migrations уже есть миграции на эту тему
php artisan migrate

После сброса пароля
Перейти на http://domain.com/password/reset
После сброса пароля юзер автоматически будет зарегистрирован и перенаправлен на /home. Изменить урл редиректа после сброса пароля, можно в методе или свойстве redirectTo

Токены сброса пароля истекают через 1 час

Настройки отправки почты
Можно изменять класс уведомления, используемый для отправки ссылки сброса пароля пользователю



ARTISAN CONSOLE

https://laravel.com/docs/5.5/artisan

Artisan это интерфейс командной строки (CLI)

Cписок всех artisan-команд
php artisan list

Показать подсказку по команде
php artisan help commandname

Tinker
Позволяет взаимодействовать со всем Laravel приложением из командной строки, включая Eloquent ORM, задачи в очереди, события, итд

Запустить Tinker
php artisan tinker

Список всех роутов
php artisan route:list

Можно писать свои команды, и выбрать место хранения команд, лишь бы они загружались с помощью Composer.

Команды на функциях-замыканиях
Являются альтернативой определению команд как классов.
Как роуты с анонимными функциями являются альтернативой контроллерам.

Выполнить команду в коде

$exitCode = Artisan::call('email:send', ['user' => 1, '--queue' => 'default']);

Метод queue фасада Artisan, запустит команду в очереди, и они будут выполняться в фоне, обработчиком очереди.

Artisan::queue('email:send', ['user' => 1, '--queue' => 'default']);

Только настройте очередь и запустите обработчик очередей.

Выполнить команду из другой команды

public function handle() {
    $this->call('email:send', ['user' => 1, '--queue' => 'default']);
}

Выполнить команду и скрыть ее выходные данные

public function handle() {
    $this->callSilent('email:send', ['user' => 1, '--queue' => 'default']);
}



BROADCASTING

https://laravel.com/docs/5.5/broadcasting

WebSocket используется для обновляющихся в режиме реального времени интерфейсов. Это альтернатива постоянному опросу вашего приложения на наличие изменений. Настроить и запустить слушателя очереди.

Настройки
config/broadcasting.php

Драйверы вещания
Pusher, Redis, log (для разработки и отладки), null (отключает широковещание)

Добавить провайдер
BroadcastServiceProvider в массив providers в config/app.php

Пакеты драйверов
composer require pusher/pusher-php-server "~2.6"
composer require predis/predis

Redis + Socket.IO
Включить клиентскую библиотеку Socket.IO JavaScript в HTML-элемент head

Laravel Echo
Это js-пакет для отлова широковещательных серверных событий генерируемых драйверами. Он делает подписку на каналы и слушание вещания событий.

установка
npm install --save laravel-echo

Каждому подключению назначается сокет ID. В Vue и Axios, сокет ID будет автоматически прикрепляться к каждому исходящему запросу как заголовок X-Socket-ID.

У пакета должен быть доступ к CSRF-токену
<meta name="csrf-token" content="{{ csrf_token() }}">

Вещать событие другим клиентам подключения (например фразу "печатает...")
Echo.channel('chat').whisper('typing', { name: this.user.name });

Все события вещаются по каналам.

Общедоступные каналы
Для всех без аутентификации или авторизации

Приватные каналы
Юзер должен быть аутентифицирован и авторизован прослушивать этот канал
Правила авторизации в routes/channels.php

Broadcast::channel('order.{orderId}', function ($user, $orderId) {
    return $user->id === Order::findOrNew($orderId)->user_id;
    }
);

Метод channel принимает два аргумента: имя канала и анонимную функцию, которая возвращает true или false, указывая авторизован юзер слушать на этом канале, или нет. Затем остается слушать событие в нашем JavaScript-приложении. Для этого используется js-библиотека Laravel Echo.



CACHE

https://laravel.com/docs/5.5/cache

Настройки config/cache.php
Драйвера: Memcached, Redis, Database, File (по-умолчанию, хранит сериализованные объекты в ФС).

Database
Создать таблицу для хранения элементов кэша
php artisan cache:table

Memcached
Установить пакет Memcached PECL

Redis
Установить пакет composer predis/predis (~1.0), или расширение PECL PhpRedis PHP.

Контракты
Illuminate\Contracts\Cache\Factory - доступ ко всем драйверам кэша
Illuminate\Contracts\Cache\Repository - драйвер кэша по-умолчанию который задан в файле настроек

Фасад Cache
$value = Cache::get('key');

Обращение к разным хранилищам
Cache::store('file')->get('foo');
Cache::store('redis')->put('bar', 'baz', 10);

Получение элементов
$value = Cache::get('key');
$value = Cache::get('key', 'default');

Можно передать вторым параметром замыкание, если элемента не существует будет возвращён результат замыкания
$value = Cache::get('key', function () {
    return DB::table()->get();
});

Проверка существования элемента
if (Cache::has('key')) {}

Увеличение / уменьшение значений
Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);

Получить элемент из кеша, и если его не существует то сохранить значение по-умолчанию. Получить всех пользователей из кэша, а если они не существуют, получить их из базы данных и добавить в кэш.
$value = Cache::remember('users', $minutes, function () {
    return DB::table('users')->get();
});

Получить элемент и удалить его из кэша
$value = Cache::pull('key');

Сохранить элемент в кэш
Cache::put('key', 'value', $minutes);

$expiresAt = Carbon::now()->addMinutes(10);
Cache::put('key', 'value', $expiresAt);

Добавит элемент в кэш, если его там нет
Cache::add('key', 'value', $minutes);

Сохранить элемент навсегда
Cache::forever('key', 'value');

Удаление элемента из кэша
Cache::forget('key');

Очистить весь кэш
Cache::flush();

Кроме фасада Cache и контракта Cache, можно использовать глобальную функцию cache
$value = cache('key');

Сохранить массив в кеш
cache(['key' => 'value'], $minutes);
cache(['key' => 'value'], Carbon::now()->addSeconds(10));

Теги кэша не поддерживаются драйверами file или database

Теги кэша позволяют отмечать несколько элементов в кеше, связку
Cache::tags(['people', 'artists'])->put('John', $john, $minutes);
Cache::tags(['people', 'authors'])->put('Anne', $anne, $minutes);

Обращение к элементам кэша с тегами
$john = Cache::tags(['people', 'artists'])->get('John');
$anne = Cache::tags(['people', 'authors'])->get('Anne');

Удаление элементов кэша с тегами
Cache::tags(['people', 'authors'])->flush();
Cache::tags('authors')->flush();

Написание драйвера
Чтобы создать свой драйвер кэша, надо реализовать контракт Illuminate\Contracts\Cache\Store

События
Для выполнения какого-либо кода при каждой операции с кэшем вы можете прослушивать события, инициируемые кэшем.



COLLECTIONS

https://laravel.com/docs/5.5/collections

Коллекции неизменнны, каждый метод класса Illuminate\Support\Collection возвращает новый экземпляр Collection. Это обертка для работы с массивами. Результаты запросов Eloquent всегда возвращаются в виде экземпляров класса Collection.

Создать коллекцию
$collection = collect([1, 2, 3]);

Методы
82 метода всего

all - возвращает заданный массив, представленный коллекцией
avg - возвращает среднее значение переданного ключа
chunk - разбивает коллекцию на множество мелких коллекций заданного размера (полезен для сеток Bootstrap)
collapse - сворачивает коллекцию массивов в одну одномерную коллекцию
combine - комбинирует ключи коллекции со значениями другого массива или коллекции
contains - определяет, содержит ли коллекция заданное значение
containsStrict() - как contains, но сравнивает строго
count - возвращает общее количество элементов в коллекции
diff - сравнивает одну коллекцию с другой коллекцией/массивом, по значениям
diffAssoc - сравнивает коллекцию с другой коллекцией/массивом, по ключам и значениям
diffKeys - сравнивает одну коллекцию с другой коллекцией/массивом, по ключам
each - перебирает элементы в коллекции и передает каждый элемент в функцию обратного вызова
every - проверка что все элементы прошли проверку на истинность
except - возвращает все элементы коллекции, кроме указанного массива ключей
filter - фильтрует коллекцию с помощью функции обратного вызова, оставляя только элементы соответствующие условию
first - возвращает первый элемент коллекции, подходящий под заданное условие
flatMap - проходит по коллекции и передаёт каждое значение в функцию обратного вызова
flatten - преобразует многомерную коллекцию в одномерную
flip - меняет местами ключи и значения в коллекции
forget - удаляет элемент из коллекции по ключу. он изменяет коллекцию, а не возвращает новую
forPage - возвращает коллекцию содержащую элементы для вывода на странице с заданным номером
get - возвращает элемент по ключу
groupBy - группирует элементы по ключу
has - определяет существует ли ключ в коллекции
implode - соединяет элементы в коллекции
intersect - удаляет все значения из коллекции, которых нет в переданной коллекции/массиве
intersectKey - удаляет все ключи из коллекции, которых нет в переданной коллекции/массиве
isEmpty - возвращает true, если коллекция пуста
isNotEmpty - возвращает true, если коллекция не пуста
keyBy - возвращает коллекцию по указанному ключу
keys - возвращает все ключи коллекции
last - возвращает последний элемент коллекции, подходящий под заданное условие
map - перебирает коллекцию и передаёт каждое значению в функцию обратного вызова. антагонист transform
mapWithKeys - проходит по элементам коллекции и передаёт каждое значение в функцию обратного вызова
max - возвращает максимальное значение по заданному ключу
median - возвращает медианное значение заданного ключа
merge - добавляет указанный массив в исходную коллекцию
min - возвращает минимальное значение по заданному ключу
mode - возвращает значение мода заданного ключа
nth - создает новую коллекцию, состоящую из каждого n-ного элемента
only - возвращает элементы коллекции с заданными ключами
partition - возвращает элементы которые прошли проверку на истинность
pipe - передает коллекцию в заданную функцию и возвращает результат
pluck - извлекает все значения по заданному ключу
pop - удаляет и возвращает последний элемент из коллекции
prepend - добавляет элемент в начало коллекции
pull - возвращает и удаляет элемент из коллекции по ключу
push - добавляет элемент в конец коллекции
put - устанавливает заданный ключ и значение в коллекцию
random - возвращает случайный элемент коллекции
reduce - уменьшает коллекцию до одного значения, передавая результат каждой итерации в последующую итерацию
reject - фильтрует коллекцию, используя функцию обратного вызова
reverse - меняет порядок элементов коллекции
search - ищет в коллекции заданное значение и возвращает его ключ
shift - возвращает и удаляет первый элемент коллекции
shuffle - перемешивает элементы в коллекции случайным образом
slice - возвращает часть коллекции, начиная с заданного индекса
sort - сортирует коллекцию, сохраняя ключи. можно передать функцию обратного вызова со своим алгоритмом сортировки
sortBy - сортирует коллекцию по ключу, сохраняя ключи
splice - возвращает и удаляет часть элементов, начиная с заданного индекса
split - разбивает коллекцию на заданное число групп
sum - возвращает сумму всех элементов в коллекции
take - возвращает новую коллекцию с заданным числом элементов
tap - передает коллекцию заданной анонимной функции, позволяя "подключиться" к коллекции в определенный момент и сделать что-то с элементами, не оказывая влияния на саму коллекцию
times - создает новую коллекцию, вызывая функцию заданное количество раз
toArray - преобразует коллекцию или вложенные объекты коллекции, в простой массив. Если значения коллекции это модели Eloquent, то они тоже будут преобразованы в массивы
toJson - преобразует коллекцию в JSON
transform - перебирает коллекцию и вызывает функцию обратного вызова для каждого элемента. Элементы коллекции будут заменены на значения, полученные из функции обратного вызова. он изменяет коллекцию, а не возвращает новую. антагонист map
union - добавляет данный массив в коллекцию
unique - возвращает все уникальные элементы в коллекции, сохраняя ключи. работает со вложенными коллекциями/объектами. можно передать свою анонимную функцию
uniqueStrict - как unique, но сравнивает строго
values - возвращает новую коллекцию со сброшенными ключами и последовательно пронумерованными индексами
when - выполнит заданную анонимную функцию, когда первый переданный методу элемент будет true
where - фильтрует коллекцию по заданной паре ключ/значение
whereStrict - как where, но сравнивает строго
whereIn - фильтрует коллекцию по заданным ключу/значению, содержащимся в данном массиве
whereInStrict - как whereIn, но сравнивает строго
whereNotIn - фильтрует коллекцию по заданным ключу/значению, которые не содержатся в данном массиве
whereNotInStrict - как whereNotIn, но сравнивает строго
zip - объединяет все значения заданного массива со значениями исходной коллекции

Операции высшего порядка
Методы коллекций, которые предоставляют операции высшего порядка: average, avg, contains, each, every, filter, first, flatMap, map, partition, reject, sortBy, sortByDesc, sum



EVENTS

https://laravel.com/docs/5.5/events

Паттерн Observer
Можно подписываться и прослушивать события вашего приложения
Классы событий в папке app/Events
Классы обработчиков в папке app/Listeners

Регистрация событий и слушателей
Все события регистрируются в массиве $listen в EventServiceProvider, он содержит массив всех событий(ключи) и их слушателей(значения)

protected $listen = [

 'App\Events\OrderShipped' => [
        'App\Listeners\SendShipmentNotification',
    ],
];

Добавить слушателей и события в EventServiceProvider, и сгенерировать события и слушатели
php artisan event:generate

Регистрация событий вручную
Можно зарегистрировать события вручную, в методе boot в EventServiceProvider

Слушатели событий по маске
Регистрировать слушателей используя символ *, что позволит поймать несколько событий для одного слушателя

Определение событий
Класс события — это просто контейнер данных, содержащий информацию, которая относится к событию

Определение слушателей
Слушатели событий принимают экземпляр события в свой метод handle. При генерации командой, она автоматически импортирует класс события и указывает тип события в метод handle

Ваши слушатели события могут указывать тип любых зависимостей, которые необходимы для их конструкторов. Все слушатели события доступны через сервис-контейнер Laravel, поэтому зависимости будут внедрены автоматически.

Остановить распространение события для других слушателей
Возвратить false из метода handle вашего слушателя

Слушатели события в очереди
Добавление слушателей в очередь, если слушатель делает медленную задачу (например отправка email). Предварительно настроить очередь и запустить слушателя очереди

Обработка проваленных задач
Если работа слушателя завершилась неудачно после N попыток, будет вызван метод failed в вашем слушателе

Размещение событий
Чтобы разместить событие, надо передать экземпляр события хелперу event. хелпер разместит событие всем его зарегистрированным слушателям

Подписчики событий
Подписчики событий — это классы, которые могут подписаться на множество событий из самого класса, что позволяет определить несколько обработчиков событий в одном классе

Регистрация подписчиков событий
Когда подписчик определён, он может быть зарегистрирован в диспетчере события



FILE STORAGE

https://laravel.com/docs/5.5/filesystem

Настройки ФС config/filesystems.php
Используется пакет Flysystem
Драйверы: local, Amazon S3, Rackspace Cloud Storage, FTP

Драйвер local
Локальная ФС. папка public для общего доступа к файлам
Хранит файлы в storage/app/public
Все файлы которые должны быть общедоступны, помещать в папку storage/app/public
Все файловые операции выполняются относительно папки root, определенной в конфиге, по-умолчанию папка storage/app

Сделать папку доступную через веб
создать символическую ссылку с public/storage на storage/app/public
php artisan storage:link

Когда файл сохранён и создана символьная ссылка, создать URL к файлу
echo asset('storage/file.txt'); // хелпер asset

Сохранить файл в storage/app/file.txt
Storage::disk('local')->put('file.txt', 'Contents');

Выбрать драйвер
Storage::put('avatars/1', $fileContents);
Storage::disk('s3')->put('avatars/1', $fileContents);

Получить файл
$contents = Storage::get('file.jpg');

Существует ли файл?
$exists = Storage::disk('s3')->exists('file.jpg');

URL файла
$url = Storage::url('file1.jpg');

Метаданные файла
$size = Storage::size('file1.jpg');
$time = Storage::lastModified('file1.jpg');

Сохранение файлов
Storage::put('file.jpg', $contents);
Storage::put('file.jpg', $resource);

Работа с потоками (для больших файлов)
Методы putFile, putFileAs

Добавление контента в начало/конец файла
Storage::prepend('file.log', 'Prepended Text');
Storage::append('file.log', 'Appended Text');

Копирование и перемещение файлов
Storage::copy('old/file1.jpg', 'new/file1.jpg');
Storage::move('old/file1.jpg', 'new/file1.jpg');

Загрузка файлов
public function update(Request $request) {
    $path = $request->file('avatar')->store('avatars');
 //или
 $path = Storage::putFile('avatars', $request->file('avatar'));
}

Метод store в качестве имени файла генерит UUID. Метод вернёт путь к файлу, его и сохранять в БД

Указание имени файла
$path = $request->file('avatar')->storeAs('avatars', $request->user()->id);
$path = Storage::putFileAs('avatars', $request->file('avatar'), $request->user()->id);

Указание диска
$path = $request->file('avatar')->store('avatars/'.$request->user()->id, 's3');

Видимость файлов
Файлы могут быть обозначены как public или private
Storage::put('file.jpg', $contents, 'public');

Если файл уже был сохранён, то получить/задать его видимость
$visibility = Storage::getVisibility('file.jpg');
Storage::setVisibility('file.jpg', 'public')

Удаление файлов
Storage::delete('file.jpg');
Storage::delete(['file1.jpg', 'file2.jpg']);

Получение всех файлов в папке
$files = Storage::files($directory);
$files = Storage::allFiles($directory); // включая подпапки

Получение всех подпапок
$directories = Storage::directories($directory);
$directories = Storage::allDirectories($directory); // включая подпапки

Создание папки
Storage::makeDirectory($directory);

Удаление папки
Storage::deleteDirectory($directory);

Пользовательские ФС
Создать свой драйвер, например Dropbox
composer require spatie/flysystem-dropbox



HELPERS

https://laravel.com/docs/5.5/helpers

Хелпер - глобальная вспомогательная функция

Массивы
array_add - добавляет указанную пару ключ/значение в массив, если она там не существует
array_collapse - собирает массив массивов в единый массив
array_divide - возвращает два массива, один с ключами, другой со значениями
array_dot - делает многоуровневый массив одноуровневым, объединяя вложенные массивы с помощью точки в именах
array_except - удаляет указанную пару ключ/значение из массива
array_first - возвращает первый элемент массива, удовлетворяющий условию
array_flatten - сделает многоуровневый массив плоским
array_forget - удалит указанную пару ключ/значение из многоуровневого массива, используя синтаксис имени с точкой
array_get - вернет значение из многоуровневого массива, используя синтаксис имени с точкой
array_has - проверяет существование элемента/элементов в массиве используя синтаксис имени с точкой
array_last - возвращает последний элемент массива, удовлетворяющий условию
array_only - вернет из массива только указанные пары ключ/значения
array_pluck - извлекает значения из многоуровневого массива, соответствующие переданному ключу
array_prepend - поместит элемент в начало массива
array_pull - извлечет значения из многоуровневого массива, соответствующие переданному ключу, и удалит их
array_set - установит значение в многоуровневом массиве, используя синтаксис имени с точкой
array_sort - отсортирует массив по результатам вызовов переданной функции-замыкания
array_sort_recursive - рекурсивно сортирует массив с помощью функции sort
array_where - фильтрует массив с помощью переданной функции-замыкания
array_wrap - поместит заданное значение в массив, если это значение уже в массиве, то не изменит
head - вернет первый элемент массива
last - вернет последний элемент массива

Пути
app_path - возвращает полный путь к папке app
base_path - возвращает полный путь к корневой папке приложения
config_path - возвращает полный путь к папке настройки приложения
database_path - возвращает полный путь к папке базы данных приложения
mix - возвращает путь к версионированному файлу Mix
public_path - возвращает полный путь к папке public
resource_path - возвращает полный путь к папке resources
storage_path - возвращает полный путь к папке storage

Строки
camel_case - преобразует строку в camelCase
class_basename - возвращает имя переданного класса без пространства имен
e - выполняет функцию PHP htmlspecialchars с опцией double_encode, равной false
ends_with - определяет заканчивается ли строка переданной подстрокой
kebab_case - преобразует строку в kebab-case
snake_case - преобразует строку SnakeCase в snake_case
str_limit - ограничивает число сиволов в строке
starts_with - определяет начинается ли строка с переданной подстроки
str_after - возвращает все, что содержится в строке после переданной подстроки
str_contains - определяет содержит ли строка переданную подстроку, можно передать массив значений, чтобы определить, содержит ли строка любое из них
str_finish - добавляет одно вхождение подстроки в конец переданной строки, если она уже не заканчивается этим вхождением
str_is - определяет соответствует ли строка маске, можно использовать * как символы подстановки
str_plural - преобразовывает слово-строку во множественное число, только англ язык. можно указать число вторым аргументом для получения единственного или множественного числа строки
str_random - создает последовательность случайных символов заданной длины, php функция random_bytes
str_singular - преобразует слово-строку в единственное число, только англ язык
str_slug - генерирует подходящую для URL "заготовку" из переданной строки
studly_case - преобразует строку studly_case в StudlyCase
title_case - преобразует строку title case в Title Case
trans - переводит переданную строку с помощью ваших файлов локализации
trans_choice - переводит переданную строку с изменениями

Урл
action - генерирует URL для заданного действия контроллера. передайте имя класса контроллера в пространстве App\Http\Controllers
asset - генерирует URL к ресурсу (изображению итд) на основе текущей схемы запроса (HTTP или HTTPS)
secure_asset - генерирует URL для ресурса с использованием HTTPS
route - генерирует URL для заданного именованного роута, можно передать параметры вторым аргументом, по-умолчанию генерирует абсолютный URL-адрес, чтобы сгенерировал относительный надо передать false третьим параметром
secure_url - генерирует полный HTTPS URL по заданному пути
url - генерирует полный URL по заданному пути

Прочее
abort - выбрасывает HTTP-исключение, которое будет отображено обработчиком исключений. Вы можете передать текст для вывода при ответе с этим исключением
abort_if - выбрасывает HTTP-исключение, если заданное логическое выражение равно true
abort_unless - выбрасывает HTTP-исключение, если заданное логическое выражение равно false
auth - возвращает экземпляр аутентификатора. Вы можете использовать ее вместо фасада Auth
back - создает ответ-редирект на предыдущую страницу пользователя
bcrypt - хеширует переданное значение с помощью Bcrypt. Вы можете использовать ее вместо фасада Hash
cache - можно использовать для получения значений из кэша
collect - создает экземпляр коллекции из переданного массива
config - получает/задает значения переменной из конфигурации. К значениям конфигурации можно обращаться через точку имяфайла.параметр
csrf_field - создаёт скрытое поле ввода HTML hidden, содержащее значение CSRF-последовательности
csrf_token - позволяет получить текущее значение CSRF-последовательности
dd - выводит дамп переменных и завершает выполнение скрипта. Если вы не хотите останавливать выполнение скрипта, вместо этого используйте функцию dump
dump - выводит дамп переменных
dispatch - помещает новую задачу в список задач
env - позволяет получить значение переменной среды или вернуть значение по-умолчанию
event - отправляет указанное событие его слушателям
factory - создает построитель фабрики моделей для данного класса, имени и количества
info - будет записывать информацию в журнал
logger - можно использовать, чтобы записать в журнал сообщение уровня debug
method_field - создаёт скрытое поле ввода HTML hidden, содержащее подмененное значение HTTP-типа формы
old - получает значение "старого" ввода, переданного в сессию
redirect - возвращает HTTP-ответ редиректа, или экземпляр редиректора, если вызывается без аргументов
request - возвращает экземпляр текущего запроса или получает элемент ввода
response - создает экземпляр ответа или получает экземпляр фабрики ответов
retry - пытается выполнить заданную функцию до тех пор, пока не будет достигнут заданный максимальный порог попыток
session - используется для получения/задания значений сессии. Если в функцию не было передано значение, то она вернет значения сессии
value - просто вернет данное функции значение. если передать Closure функции, будет выполнено Closure и возвращен результат
view - получает экземпляр шаблона



MAIL

https://laravel.com/docs/5.5/mail

Конфиг config/mail.php
Библиотека SwiftMailer
С драйверами SMTP, Mailgun, SparkPost, Amazon SES, mail, sendmail
Mailgun и SparkPost быстрее чем SMTP
Mailgun и SparkPost требуют Guzzle
composer require guzzlehttp/guzzle

Mailgun
Задайте для параметра driver в конфиге config/mail.php значение mailgun

Драйвер SparkPost
Задайте для параметра driver в конфиге config/mail.php значение sparkpost

Драйвер Amazon SES
Установите Amazon AWS SDK для PHP

Каждый тип email-сообщений расширяет класс Mailable. Эти классы хранятся в папке app/Mail. Настройка класса mailable в методе build, внутри него можно вызвать методы from, subject, view и attach. В методе build можно использовать метод view, чтобы указать шаблон следует использовать. Обычно шаблон Blade. В папке resources/views/emails положить свои email-шаблоны

Создать класс email-сообщения
php artisan make:mail OrderShipped
это создаст класс app/Mail/OrderShipped.php

Два способа настройки отправителя
метод from внутри вашего метода mailable-класса build
указать глобальный адрес "from" в конфиге config/mail.php

Email-сообщения без форматирования
Метод text. Как и метод view, он принимает имя шаблона

Данные шаблона

Через общедоступные свойства
Любое общедоступное свойство вашего класса mailable доступно в шаблоне

Через метод with вручную
public function build() {
    return $this->view('emails.orders.shipped')->with([
                        'orderName' => $this->order->name,
                        'orderPrice' => $this->order->price,
                    ]);
}

Потом в шаблоне Blade
<div>Price: {{ $orderPrice }}</div>

Вложения
public function build() {
    return $this->view('emails.orders.shipped')->attach('/path/to/file');
}

Можно указать отображаемое имя файла и MIME тип
return $this->view('emails.orders.shipped')->attach('/path/to/file', [
                        'as' => 'name.pdf',
                        'mime' => 'application/pdf',
                    ]);

Вложения с сырыми данными
Метод attachData. для присоединения сырой строки байтов в качестве вложения. Например чтобы сгенерировать PDF в памяти без записи на диск и вставить во вложение

Встроенные вложения
добавлять изображения и получать соответствующие CID
<body>
    <img src="{{ $message->embed($pathToFile) }}">
</body>

Встроенные вложения с сырыми данными
Если у вас уже есть строка с сырыми данными, которую вы хотите встроить в шаблон, можно использовать метод embedData на переменной $message

Настройка сообщения SwiftMailer
В методе withSwiftMessage можно зарегистрировать анонимную функцию перед отправкой, для кастомизации сообщения

public function build() {
    $this->view('emails.orders.shipped');
    $this->withSwiftMessage(function ($message) {
            $message->getHeaders()
            ->addTextHeader('Custom-Header', 'HeaderValue');
        });
}

Markdown
Сообщения в формате Markdown

Создать класс Markdown email-сообщения
php artisan make:mail OrderShipped --markdown=emails.orders.shipped
Тогда в методе build, вызовите метод markdown вместо метода view

Написание Markdown-сообщений
Используйте Blade-компоненты и синтаксис Markdown

Компонент Button (кнопка)
Компонент Panel (область)
Компонента Table (таблица)

CSS
После экспорта компонентов в папке resources/views/vendor/mail/html/themes будет файл default.css

Отправка почты
Метод to принимает адрес email, экземпляр пользователя, или коллекцию пользователей
Если передаете объект или коллекцию объектов, то убедитесь что там есть поля email и name в массиве
Mail::to($request->user())
    ->cc($moreUsers)
    ->bcc($evenMoreUsers)
    ->send(new OrderShipped($order));

Помещение сообщения в очередь
Предварительно настроить очередь
Mail::to($request->user())
    ->cc($moreUsers)
    ->bcc($evenMoreUsers)
    ->queue(new OrderShipped($order));

Задержка отправки сообщения
Задержать отправку сообщения, метод later

$when = Carbon\Carbon::now()->addMinutes(10);
Mail::to($request->user())->later($when, new OrderShipped($order));

Помещение сообщения в определённую очередь или в очередь по-умолчанию
Указать имя очереди и подключение для сообщения

Локальная разработка

Драйвер Log
Вместо отправки будет записывать все email-сообщения в ваши логи

Универсальный получатель
Задать универсального получателя для всех сообщений от фреймворка. Параметр to в config/mail.php

Mailtrap
Cервис Mailtrap и драйвер smtp для отправки почтовых сообщений на фиктивный почтовый ящик

События
Laravel генерирует событие непосредственно перед отправкой почтовых сообщений. Событие возникает при отправке сообщения, а не при помещении его в очередь



NOTIFICATIONS

https://laravel.com/docs/5.5/notifications

Отправка уведомлений по каналам email, SMS, Slack
Лежат в папке app/Notifications

Создать уведомление
php artisan make:notification InvoicePaid
создаст класс app/Notifications/InvoicePaid.php

Класс содержит метод via и переменный набор методов построения сообщений, например toMail, toDatabase, toArray

Отправка уведомления
используя метод notify трейта Notifiable
используя фасад Notification

Использование трейта Notifiable
$user->notify(new InvoicePaid($invoice));

Использование фасада Notification
Когда надо отправить уведомление нескольким объектам
Notification::send($users, new InvoicePaid($invoice));

Указание каналов доставки
В методе via, каналы mail, database, broadcast, nexmo, slack

public function via($notifiable) {
    return $notifiable->prefers_sms ? ['nexmo'] : ['mail', 'database'];
}

Формирование очередей уведомлений
Добавить к уведомлению интерфейс ShouldQueue и отправляйте как обычно. Чтобы отложить доставку то привязать метод delay

Отправка уведомления на канал mail

public function toMail($notifiable) {
    return (new MailMessage)
                ->greeting('Hello!')
                ->line('One of your invoices has been paid!')
                ->action('View Invoice', url('/invoice/'.$this->invoice->id))
                ->line('Thank you for using our application!');
}

Такое компонентное сообщение будет преобразовано в HTML шаблон
В конфиге установить значение name в config/app.php, но будет использовано для заголовка и футера
В методе view можно указать шаблон
В экземпляре $notifiable должно быть поле email
Можно в формате markdown, используя Blade и синтаксис Markdown

Уведомления вещания канала broadcast позволяют вашему JavaScript-клиенту ловить уведомления в режиме реального времени.

Все уведомления вещания становятся в очередь на вещание



PACKAGE DEVELOPMENT

https://laravel.com/docs/5.5/packages

Пакеты это способ добавления нового функционала в Laravel. Пакеты могут быть автономны для любого фреймворка, и только для Laravel и могут содержать роуты, контроллеры, представления и настройки

Во время написания приложения не важно используете ли вы контракты или фасады
При написании пакетов лучше использовать контракты, а не фасады, поскольку у вашего пакета не будет доступа к хелперам

Сервис-провайдеры — связующие элементы между вашим пакетом и Laravel. Сервис-провайдер отвечает за привязку в Laravel сервис-контейнеров и за передачу информации о том, куда загружать ресурсы пакета: шаблоны, настройки, языковые файлы

Использовать метод publishes из метода boot для:
загрузить файл настроек пакета в папку app/config
загрузить шаблоны пакета в папку resources/views/vendor
загрузить ресурсы пакета (css, js, image) в папку public
загрузить переводы пакета в папку resources/lang/vendor

loadRoutesFrom - загрузить роуты
loadMigrationsFrom - загрузить миграции
loadTranslationsFrom - загрузить языковые файлы
loadViewsFrom - загрузить шаблоны
commands - зарегистрировать artisan-команды пакета



QUEUES

https://laravel.com/docs/5.5/queues

Laravel Queue - единое API для очередей. Чтобы ставить в очередь медленные задачи типа отправка email
Все настройки в config/queue.php в параметре connections
Драйвера очередей: Database, Beanstalkd, Amazon SQS, Redis, sync(для локального использования), null(отменяет задачи очереди)

Подключения и очереди
Подключение это подключение к различным бекенд-сервисам, т.е. к драйверам
У любого подключения есть несколько очередей, т.е. пачек задач

Отправляем задачу в очередь по-умолчанию
dispatch(new Job);

Отправляем задачу в очередь emails
dispatch((new Job)->onQueue('emails'));

Database
Создать таблицу для очередей задач для драйвера очередей Database
php artisan queue:table
php artisan migrate
это создаст таблицу jobs

Redis
Настроить подключение к Redis в config/database.php

Нужные зависимости
Amazon SQS: aws/aws-sdk-php ~3.0
Beanstalkd: pda/pheanstalk ~3.0
Redis: predis/predis ~1.0

Создать задачу для очереди
php artisan make:job SendReminderEmail
это создаст класс app/Jobs/SendReminderEmail.php

Все задачи хранятся в папке app/Jobs

В классе задачи метод handle вызывается при обработке задачи в очереди. Можно передать модель Eloquent в конструктор задачи. Когда очередь начнёт обработку задачи, она автоматически запросит полный экземпляр модели из БД. В handle можно указать зависимости, они автоматически внедрятся. Метод delay чтобы задержать выполнение задачи

Добавление задач в очередь
хелпер dispatch. передаем ему экземпляр задачи
dispatch(new ProcessPodcast($podcast));

Задаче не следует быть доступной для обработки до истечения 10 минут после ее отправки
$job = (new ProcessPodcast($podcast))->delay(Carbon::now()->addMinutes(10));
dispatch($job);

Поместить задачи в разные очереди, разделить по категориям, задать приоритеты по кол-ву обработчиков
$job = (new ProcessPodcast($podcast))->onQueue('processing');
dispatch($job);

Указать подключение к очереди для задачи
$job = (new ProcessPodcast($podcast))->onConnection('sqs');
dispatch($job);

$job = (new ProcessPodcast($podcast))->onConnection('sqs')->onQueue('processing');

Указать максимальное число попыток выполнения задачи
php artisan queue:work --tries=3
или в классе
public $tries = 3;

Таймаут
php artisan queue:work --timeout=30
или в классе
public $timeout = 30;

Обработка ошибок
Если во время обработки задачи выбрасывается исключение, задача будет автоматически помещена обратно в очередь, чтобы ее можно было бы попытаться выполнить снова. Задача будет продолжать попытки выполнения, пока не достигнет установленного максимального количества попыток.

Запустить воркер очереди
php artisan queue:work

Воркер очереди обрабатывает задачи. Чтобы воркер работал в фоне, нужно использовать инструмент мониторинга процессов, например Supervisor. Воркеры очереди это длительные процессы и хранят в памяти состояние загруженного приложения. Они не заметят изменений в коде без перезапуска

Перезапустить воркеры
php artisan queue:restart

Приоритеты очереди
dispatch((new Job)->onQueue('high'));

Supervisor
Это монитор процессов для Linux, он автоматически перезапустит процесс queue:work, если он остановится
sudo apt-get install supervisor
Файл настроек в папке /etc/supervisor/conf.d

Проваленные задачи
Некоторые задачи могут закончится неудачей. Указать кол-во попыток выполнения задачи. После этого задача будет добавлена в таблицу failed_jobs

Создать таблицу проваленных задач очередей
php artisan queue:failed-table
php artisan migrate
это создаст таблицу failed_jobs

Очистка проваленных задач
Задать метод failed напрямую в классе задачи, это позволит выполнить очистку специально после этой задачи в случае провала

Событие проваленных задач
Вызывается при ошибке выполнения задачи, используйте метод Queue::failing, например для отправки на email

Посмотреть все проваленные задачи в таблице failed_jobs
php artisan queue:failed

Выполнить задачу с ID=5
php artisan queue:retry 5

Повторить все проваленные задачи
php artisan queue:retry all

Удалить проваленную задачу с ID=5
php artisan queue:forget 5

Удалить все проваленные задачи
php artisan queue:flush

События задач
В методах before и after фасада Queue, можно указать анонимные функции которые нужно выполнить перед или после выполнения задачи в очереди. В них удобно выполнять логирование или собирать статистику



TASK SCHEDULING

https://laravel.com/docs/5.5/scheduling

Раньше для каждой cron-задачи создавали свою cron-запись на сервере
При работе с Laravel все записи пишем внутри кода, а на сервере в cron-файле только 1 запись
Можно и Artisan-команды, и команды операционной системы
Запланировать Artisan-команду можно либо через имя команды, либо по классу

Добавить на сервер 1 запись
* * * * * php /path-to-your-project/artisan schedule:run >> /dev/null 2>&1
он будет вызываться каждую минуту

Крон-задачи писать в методе schedule в app/Console/Kernel.php

Например запланируем замыкание Closure
protected function schedule(Schedule $schedule) {
   $schedule->call(function () {
   DB::table('recent_users')->delete();
   })->daily();
}

Примеры команд
$schedule->command('emails:send --force')->daily();
$schedule->command(EmailsCommand::class, ['--force'])->daily();
$schedule->exec('node /home/forge/script.js')->daily();

Настройки частоты
->cron('* * * * * *');
->everyMinute();
->everyFiveMinutes();
->everyTenMinutes();
->everyThirtyMinutes();
->hourly();
->hourlyAt(17);
->daily();
итд

Запуск каждый понедельник в 13:00
$schedule->call(function () {})->weekly()->mondays()->at('13:00');

Запуск каждый час с 8:00 до 17:00 по будням
$schedule->command('foo')->weekdays()->hourly()->timezone('America/Chicago')->between('8:00', '17:00');

Список дополнительных ограничений расписания
->weekdays(); Ограничить задачу рабочими днями
->sundays(); Ограничить задачу воскресеньем
->mondays(); Ограничить задачу понедельником
->tuesdays(); Ограничить задачу вторником
->wednesdays(); Ограничить задачу средой
->thursdays(); Ограничить задачу четвергом
итд

Ограничение промежутком времени
$schedule->command('reminders:send')->hourly()->between('7:00', '22:00');

Исключить выполнение задачи в указанный период времени
$schedule->command('reminders:send')->hourly()->unlessBetween('23:00', '4:00');

Ограничение проверкой на истинность
Метод when
$schedule->command('emails:send')->daily()->when(
    function () {
    return true;
});

Метод skip является инверсией метода when

Предотвращение перекрытий задач
По-умолчанию задачи запускаются по крону, даже если предыдущая еще не закончила работу, чтобы это предотвратить, использовать метод withoutOverlapping
команда emails:send будет запускаться каждую минуту, если она ещё не запущена
$schedule->command('emails:send')->withoutOverlapping();

Запланированные задачи Laravel не будут выполняться, когда Laravel находится в режиме обслуживания

Если вы хотите, чтобы задача запускалась даже в режиме обслуживания
$schedule->command('emails:send')->evenInMaintenanceMode();

Работа с выходными данными, сгенерированными запланированными задачами

$schedule->command('emails:send')->daily()->sendOutputTo($filePath);
$schedule->command('emails:send')->daily()->appendOutputTo($filePath);
$schedule->command('foo')->daily()->sendOutputTo($filePath)->emailOutputTo('foo@example.com');

Методы emailOutputTo, sendOutputTo, appendOutputTo доступны только для command, не для call

Хуки задач
Методы before и after, в них можно указать код, который будет выполняться до запуска и после завершения запланированной задачи

Пинг URL
Используя методы pingBefore и thenPing, планировщик может автоматически пинговать заданный URL до запуска и после завершения задачи. Этот метод полезен для уведомления внешней службы, например, Laravel Envoyer



DATABASE GETTING STARTED

https://laravel.com/docs/5.5/database

Драйвера: MySQL, Postgres, SQLite, SQL Server
Настройки в config/database.php

Разные подключения к БД
одно для SELECT, другое для INSERT, UPDATE и DELETE

'mysql' => [
    'read' => [
        'host' => '192.168.1.1',
    ],
    'write' => [
        'host' => '196.168.1.2'
    ],
],

Несколько соединений с БД
имя подключения foo из файла config/database.php
$users = DB::connection('foo')->select();

Выполнение сырых SQL-запросов
Привязка параметров обеспечивает защиту от SQL-внедрений

$users = DB::select('select * from users where active = ?', [1]);
$results = DB::select('select * from users where id = :id', ['id' => 1]);
DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);
$affected = DB::update('update users set votes = 100 where name = ?', ['John']);
$deleted = DB::delete('delete from users');

Выполнение запроса общего типа
DB::statement('drop table users');

Прослушивание событий запросов
Например для логирования SQL-запросов и отладки. Метод listen

Транзакции
DB::transaction(function () {
    DB::table('users')->update(['votes' => 1]);
    DB::table('posts')->delete();
}, 5);
Второй необязательный аргумент - число повторных попыток транзакции при возникновении взаимной блокировки

Ручное использование транзакций
DB::beginTransaction();
DB::rollBack();
DB::commit();



QUERY BUILDER

https://laravel.com/docs/5.5/queries

Получение всех записей
$users = DB::table('users')->get();

Получение одной строки
$user = DB::table('users')->where('name', 'John')->first();

Получение одного столбца
$email = DB::table('users')->where('name', 'John')->value('email');

Получение списка всех значений одного столбца
$titles = DB::table('roles')->pluck('title');

Указать произвольный ключ для возвращаемой коллекции
$roles = DB::table('roles')->pluck('title', 'name');

Разделение результатов на куски когда извлекаются много записей
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
 //тут работа по 100
 }
});
Чтобы остановить обработку последующих кусков, верните false из Closure

Агрегатные функции
count, max, min, avg и sum
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');

Указание столбцов для выборки
$users = DB::table('users')->select('name', 'email as user_email')->get();

Distinct позволяет вернуть только отличающиеся результаты
$users = DB::table('users')->distinct()->get();

Если уже есть экземпляр конструктора запросов, и хотим добавить столбец к существующему набору
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();

Использовать сырое SQL-выражение в запросе
$users = DB::table('users')->select(DB::raw('count(*) as user_count, status'))->get();

Inner Join
$users = DB::table('users')
            ->join('contacts', 'users.id', '=', 'contacts.user_id')
            ->join('orders', 'users.id', '=', 'orders.user_id')
            ->select('users.*', 'contacts.phone', 'orders.price')
            ->get();

Left Join
$users = DB::table('users')
            ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();

Cross Join
$users = DB::table('sizes')
            ->crossJoin('colours')
            ->get();

Сложные условия объединения
DB::table('users')
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')->orOn();
        })
        ->get();

DB::table('users')
        ->join('contacts', function ($join) {
            $join->on('users.id', '=', 'contacts.user_id')
                 ->where('contacts.user_id', '>', 5);
        })
        ->get();

Слияния Union
$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first)->get();
Метод unionAll с аналогичными параметрами

Условия Where
$users = DB::table('users')->where('votes', '=', 100)->get();
$users = DB::table('users')->where('votes', 100)->get();
$users = DB::table('users')->where('votes', '>=', 100)->get();
$users = DB::table('users')->where('votes', '<>', 100)->get();
$users = DB::table('users')->where('name', 'like', 'T%')->get();
$users = DB::table('users')->where([['status', '=', '1'],['subscribed', '<>', '1'],])->get();

Условия Or

$users = DB::table('users')->where('votes', '>', 100)->orWhere('name', 'John')->get();

$users = DB::table('users')->whereBetween('votes', [1, 100])->get();
$users = DB::table('users')->whereNotBetween('votes', [1, 100])->get();

$users = DB::table('users')->whereIn('id', [1, 2, 3])->get();
$users = DB::table('users')->whereNotIn('id', [1, 2, 3])->get();

$users = DB::table('users')->whereNull('updated_at')->get();
$users = DB::table('users')->whereNotNull('updated_at')->get();

$users = DB::table('users')->whereDate('created_at', '2016-12-31')->get();
$users = DB::table('users')->whereMonth('created_at', '12')->get();
$users = DB::table('users')->whereDay('created_at', '31')->get();
$users = DB::table('users')->whereYear('created_at', '2016')->get();

Для проверки на совпадение (или сравнение) двух столбцов
$users = DB::table('users')->whereColumn('first_name', 'last_name')->get();
$users = DB::table('users')->whereColumn('updated_at', '>', 'created_at')->get();
$users = DB::table('users')->whereColumn([['first_name', '=', 'last_name'],['updated_at', '>', 'created_at']])->get(); // в массиве условия будут через AND

Группировка параметров
DB::table('users')->where('name', '=', 'John')->orWhere(
            function ($query) {
                $query->where('votes', '>', 100)->where('title', '<>', 'Admin');
            })
            ->get();

Равносильно: select * from users where name = 'John' or (votes > 100 and title <> 'Admin')

Условия Where Exists

DB::table('users')->whereExists(
            function ($query) {
                $query->select(DB::raw(1))
                      ->from('orders')
                      ->whereRaw('orders.user_id = users.id');
            })
            ->get();

Равносильно: select * from users where exists (select 1 from orders where orders.user_id = users.id)

Запросы для столбцов типа JSON
$users = DB::table('users')->where('options->language', 'en')->get();
$users = DB::table('users')->where('preferences->dining->meal', 'salad')->get();

orderBy
$users = DB::table('users')->orderBy('name', 'desc')->get();

latest/oldest
отсортировать результаты по дате
$user = DB::table('users')->latest()->first();

inRandomOrder - сортировка запросов в случайном порядке
groupBy, having - для группировки результатов запроса
havingRaw - для передачи сырой строки в условие having
skip, take - аналогичны limit и offset, можно использовать любую пару

Условные выражения
Применить условие, только когда выполняется другое условие
Метод when выполняет замыкание, только когда первый параметр равен true
Можно передать еще замыкание третьим параметром, оно выполнится когда false

$role = $request->input('role');

$users = DB::table('users')->when($role,
    function ($query) use ($role) {
        return $query->where('role_id', $role);
    })
    ->get();

Вставка Insert
DB::table('users')->insert(['email' => 'john@example.com', 'votes' => 0]);

DB::table('users')->insert([
    ['email' => 'taylor@example.com', 'votes' => 0],
    ['email' => 'dayle@example.com', 'votes' => 0]
]);

insertGetId - для вставки записи и получения ее первичного ключа

Обновления Update
DB::table('users')->where('id', 1)->update(['votes' => 1]);

Обновление JSON-столбцов
DB::table('users')->where('id', 1)->update(['options->enabled' => true]);

Increment, Decrement
DB::table('users')->increment('votes');
DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes');
DB::table('users')->decrement('votes', 5);
DB::table('users')->increment('votes', 1, ['name' => 'John']);

Удаления Delete
DB::table('users')->delete();
DB::table('users')->where('votes', '>', 100)->delete();
DB::table('users')->truncate();

Разделяемая блокировка
предотвращает изменение выбранных строк до конца транзакции
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();

Блокировка на обновление
предотвращает изменение строк и их выбор другими разделяемыми блокировками
DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();



PAGINATION

https://laravel.com/docs/5.5/pagination

Пагинация интегрирована с построителем запросов и Eloquent ORM

Страничный вывод выборки из БД
public function index(){
    $users = DB::table('users')->paginate(15);
    return view('user.index', ['users' => $users]);
}

Если необходимо использовать groupBy для пагинации, рекомендуется делать запрос в БД и создавать экземпляр пагинации вручную

Ссылки Назад/Вперед
$users = DB::table('users')->simplePaginate(15);

Пагинация в Eloquent
$users = App\User::paginate(15);
$users = User::where('votes', '>', 100)->paginate(15);
$users = User::where('votes', '>', 100)->simplePaginate(15);

Создание своего класса пагинатора
Иногда необходимо создать экземпляр страничного вывода вручную, передав ему массив данных

Отображение результатов страничного вывода
<div class="container">
    @foreach ($users as $user)
        {{ $user->name }}
    @endforeach
</div>
{{ $users->links() }}

Настроить URI для вывода ссылок
$users = App\User::paginate(15);
$users->withPath('custom/url'); // http://example.com/custom/url?page=N

Добавить параметры запросов к ссылкам
{{ $users->appends(['sort' => 'votes'])->links() }}

Добавить хэш-фрагмент к ссылкам
{{ $users->fragment('foo')->links() }}

Классы пагинации реализуют контракт интерфейса Illuminate\Contracts\Support\Jsonable и предоставляют метод toJson, поэтому легко конвертировать страничный вывод в JSON

Настройка шаблона
Если не используете Bootstrap, то можете определить свои шаблоны для отрисовки ссылок, передав первым аргументом имя шаблона
{{ $paginator->links('view.name') }}
{{ $paginator->links('view.name', ['foo' => 'bar']) }} // передав данные

Экспортировать шаблоны пагинатора из папки vendor\laravel\framework\src\Illuminate\Pagination\resources\views в папку resources\views\vendor\pagination для ручного изменения
php artisan vendor:publish --tag=laravel-pagination

default.blade.php в этой папке отвечает за шаблон страничного вывода

У пагинатора есть методы
$results->count()
$results->currentPage()
$results->firstItem()
$results->hasMorePages()
$results->lastItem()
$results->lastPage() (недоступен для simplePaginate)
$results->nextPageUrl()
$results->perPage()
$results->previousPageUrl()
$results->total() (недоступен для simplePaginate)
$results->url($page)



MIGRATIONS

https://laravel.com/docs/5.5/migrations

Миграции — что-то вроде системы контроля версий для вашей базы данных. Они позволяют вашей команде изменять структуру БД, в то же время оставаясь в курсе изменений других участников.

Создать миграцию
php artisan make:migration create_users_table
это создаст класс database/migrations/ДАТАВРЕМЯ_create_users_table.php

Параметры --table и --create для указания имени таблицы и факта что миграция будет создавать новую таблицу
php artisan make:migration create_users_table --create=users
php artisan make:migration add_votes_to_users_table --table=users

В классе миграции методы up и down
up используется для добавления новых таблиц, столбцов, индексов
down отменяет операции, выполненные методом up

public function up() {
    Schema::create('flights', function (Blueprint $table) {
        $table->increments('id');
        $table->string('name');
        $table->string('airline');
        $table->timestamps();
        });
}

Для запуска всех миграций
Применить созданные миграции, это создаст таблицы
php artisan migrate

Отменить изменения, сделанные последней миграцией
php artisan migrate:rollback

Откатить нужное число миграций
php artisan migrate:rollback --step=5

Откатить изменения всех миграций
php artisan migrate:reset

Отменить изменения всех миграций, и пересоздать всю БД
php artisan migrate:refresh

Обновить БД и запустить заполнение БД начальными данными
php artisan migrate:refresh --seed

Откатить и повторно применить нужное число миграций
php artisan migrate:refresh --step=5

Создать таблицу
Schema::create('users', function (Blueprint $table) {
    $table->increments('id');
});

Проверка существования таблицы/столбца
if (Schema::hasTable('users')) {}
if (Schema::hasColumn('users', 'email')) {}

Если вы хотите выполнить операции над структурой через подключение к БД, которое не является вашим основным подключением, используйте метод connection

Задать тип таблицы
$table->engine = 'InnoDB';

Переименовать таблицу
Schema::rename($from, $to);

Удалить таблицу
Schema::drop('users');
Schema::dropIfExists('users');

Создать столбец
Schema::table('users', function (Blueprint $table) {
    $table->string('email');
});

Типы столбцов
$table->bigIncrements('id');
$table->bigInteger('votes');
$table->binary('data');
$table->boolean('confirmed');
итд. их много. а также удобняшки типа поля для ip, mac-адреса, remember_token, email, итд

Модификаторы столбцов
->after('column')
->comment('my comment')
->default($value)
->nullable()
итд

Изменить столбцы
добавьте зависимость doctrine/dbal в файл composer.json
composer require doctrine/dbal

change - изменить тип существующего столбца или его атрибуты
renameColumn - переименовать столбец
dropColumn - удалить столбец

Создать индекс
$table->string('email')->unique();
$table->unique('email');
$table->index(['account_id', 'created_at']);

Типы индексов
$table->primary('id');
$table->primary(['first', 'last']);
$table->unique('email');
$table->index('state');
итд

Laravel использует набор символов utf8mb4. Если работаете на MySQL старее чем 5.7.7 или MariaDB старее 10.2.2, вам может потребоваться вручную настроить длину строки

Удалить индекс
Обычно автоматическое имя индекса = имя таблицы + имя столбца-индекса + тип индекса
$table->dropPrimary('users_id_primary');
$table->dropUnique('users_email_unique');
$table->dropIndex('geo_state_index');

Если передать массив столбцов в метод для удаления индексов, будет сгенерировано стандартное имя индекса на основе имени таблицы, столбца и типа ключа
Schema::table('geo', function (Blueprint $table) {
    $table->dropIndex(['state']); // удалит index 'geo_state_index'
});

Ограничения внешнего ключа
Столбец user_id в таблице posts, который ссылается на столбец id в таблице users

Schema::table('posts', function (Blueprint $table) {
    $table->integer('user_id')->unsigned();
 $table->foreign('user_id')->references('id')->on('users');
});

Можно указать требуемое действие для свойств ограничений "on delete" и "on update"
$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

Удалить внешний ключ
Имя внешнего ключа такое же как у индексов. имя таблицы + столбцов из ограничения + суффикс "_foreign"
$table->dropForeign('posts_user_id_foreign');

Либо вы можете передать значение массива, при этом для удаления будет автоматически использовано стандартное имя ограничения
$table->dropForeign(['user_id']);

Можно включить/выключить ограничения внешнего ключа в своих миграциях
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();



SEEDING

https://laravel.com/docs/5.5/seeding

Наполнение БД тестовыми данными
Классы в папке database/seeds
Называть так UsersTableSeeder

Добавить тестовые данные в таблицу
php artisan make:seeder UsersTableSeeder
это создаст класс database/seeds/UsersTableSeeder.php

В методе run вставлять данные
public function run() {
    DB::table('users')->insert([
        'name' => str_random(10),
        'email' => str_random(10).'@gmail.com',
        'password' => bcrypt('secret'),
        ]);
}

Использование фабрик моделей
Например создадим 50 юзеров и привяжем отношения к постам
public function run() {
    factory(App\User::class, 50)->create()->each(
     function ($u) {
            $u->posts()->save(factory(App\Post::class)->make());
    });
}

В классе DatabaseSeeder можно использовать метод call чтобы запустить дополнительные классы загрузки
public function run() {
    $this->call(UsersTableSeeder::class);
    $this->call(PostsTableSeeder::class);
    $this->call(CommentsTableSeeder::class);
}

Написали классы загрузки, далее заполним тестовыми данными

Заполнить тестовыми данными таблицы
php artisan db:seed
php artisan db:seed --class=UsersTableSeeder

команда db:seed вызывает класс DatabaseSeeder который может быть использован для вызова других классов, заполняющих БД данными. Параметр --class для указания конкретного класса для вызова

Обновить БД и запустить заполнение БД начальными данными
php artisan migrate:refresh --seed



REDIS

https://laravel.com/docs/5.5/redis

Redis - хранилище пар ключ/значение
ключи могут содержать строки, хэши, списки, наборы и сортированные наборы.

установить пакет
composer require predis/predis

Настройки в config/database.php в массиве redis
Если используется кластер серверов Redis, задать эти кластеры в массиве clusters

Методы фасада Redis
$user = Redis::get('user:profile:'.$id);
Redis::set('name', 'Taylor');
$values = Redis::lrange('names', 5, 10);
$values = Redis::command('lrange', ['name', 5, 10]);

Использование разных подключений
$redis = Redis::connection('my-connection');

Конвейер команд
Должен использоваться, когда отправляете много команд на сервер за одну операцию
Redis::pipeline(function ($pipe) {
    for ($i = 0; $i < 1000; $i++) {
        $pipe->set("key:$i", $i);
    }
});

PUB/SUB
Интерфейс к Redis-командам publish и subscribe. Эти команды позволяют прослушивать сообщения на заданном канале. Вы можете публиковать сообщения в канал из другого приложения

Подписка по маске
С помощью метода psubscribe вы можете подписаться на канал по маске, это может быть полезно для отлова всех сообщений на всех каналах



ELOQUENT ORM GETTING STARTED

https://laravel.com/docs/5.5/eloquent

Eloquent ORM - реализация шаблона ActiveRecord
Настройки в config/database.php
Все модели в папке app
Все модели Eloquent наследуют Illuminate\Database\Eloquent\Model
Модели Eloquent работают как конструктор запросов. Все методы доступные в конструкторе запросов, доступны при работе с моделями Eloquent

Создать модель Eloquent
php artisan make:model User2
это создаст класс app/User2.php

Создать модель Eloquent с миграцией
php artisan make:model User4 --migration
это создаст класс app/User4.php
и класс database/migrations/ДАТАВРЕМЯ_create_user4s_table.php

Именование моделей
имя таблицы == имя класса
имя класса в нижнем регистре (snake case) во множественном числе
например модель Flight, таблица flights
можно указать таблицу в свойстве $table
можно указать первичный ключ в свойстве $primaryKey (по-умолчанию id)

Столбцы времени
created_at, updated_at
установить $timestamps = false если не нужно чтобы Eloquent автоматически с ними работал
установить $dateFormat чтобы изменить формат времени
задать константы CREATED_AT, UPDATED_AT чтобы изменить имена этих столбцов

задать $connection чтобы указать соединение с БД

Получить модель
$flights = App\Flight::all();
foreach ($flights as $flight) {
    echo $flight->name;
}

Добавить ограничения
$flights = App\Flight::where('active', 1)
               ->orderBy('name', 'desc')
               ->take(10)
               ->get();

Коллекции
Методы all и get получающие несколько результатов, возвращают коллекции Illuminate\Database\Eloquent\Collection

Разделение результата на блоки (для большой выборки)
Flight::chunk(100, function ($flights) {
    foreach ($flights as $flight) {
 //работа по 100. на каждые 100 отдельный запрос к БД
 }
});

Курсоры
Позволяет проходить по записям используя курсор, который выполняет только 1 запрос
foreach (Flight::where('foo', 'bar')->cursor() as $flight) {}

Получить записи

По первичному ключу
$flight = App\Flight::find(1);
$flights = App\Flight::find([1, 2, 3]);

По условию
$flight = App\Flight::where('active', 1)->first();

Выброс исключения Illuminate\Database\Eloquent\ModelNotFoundException если модель не найдена
$model = App\Flight::findOrFail(1);
$model = App\Flight::where('legs', '>', 100)->firstOrFail();

Если исключение не поймано то автоматически отсылается HTTP-ответ 404
Route::get('/api/flights/{id}', function ($id) {
    return App\Flight::findOrFail($id);
});

Агрегатные методы count, sum, max, итд
$count = App\Flight::where('active', 1)->count();
$max = App\Flight::where('active', 1)->max('price');

Создать запись
$flight = new Flight;
$flight->name = $request->name;
$flight->save();
Столбцы created_at и updated_at будут автоматически установлены

Обновить запись
$flight = App\Flight::find(1);
$flight->name = 'New Flight Name';
$flight->save();
Столбец updated_at будет автоматически установлен

Массовое обновление
App\Flight::where('active', 1)->where('destination', 'San Diego')->update(['delayed' => 1]);
Для массового обновления не выбрасываются события saved и updated

Массовое назначение
Назначить список разрешенных столбцов в $fillable, чтобы юзер не всунул в массив в форме например is_admin=1 и этот элемент не пролез в массив в методе save или update

$fillable = ['name', 'email'];

$fillable - белый список заполнения
$guarded - черный список заполнения

$guarded = ['is_admin'];

Если уже есть экземпляр модели, можно его заполнить массивом полей так
$flight = App\Flight::create(['name' => 'Flight 10']);
$flight->fill(['name' => 'Flight 22']);

Методы создания моделей с помощью массового заполнения
firstOrCreate - ищет запись в БД используя указанные пары столбец/значение, если модель не найдена то запись будет вставлена
firstOrNew - ищет запись в БД используя указанные пары столбец/значение, если модель не найдена то будет возвращён новый экземпляр модели, но эта модель еще не вставлена в БД

Обновить существующую модель или создать новую, если ее еще нет
метод updateOrCreate. как и метод firstOrCreate, он сохраняет модель

Удалить модель
$flight = App\Flight::find(1);
$flight->delete();

Удалить модель по первичному ключу
App\Flight::destroy(1);
App\Flight::destroy([1, 2, 3]);
App\Flight::destroy(1, 2, 3);

Удалить модель по условию
$deletedRows = App\Flight::where('active', 0)->delete();

При массовом удалении, не будут выброшены события deleting и deleted

Псевдоудаление моделей
Запись не удаляется, просто ей ставится аттрибут deleted_at. добавить такой столбец в таблицу. в deleted_at будет установлено в значение текущей даты и времени. при запросе моделей, использующих псевдоудаление, "удалённые" модели не будут включены в результат

Schema::table('flights', function ($table) {
    $table->softDeletes();
});

Определение удалён ли экземпляр модели?
if ($flight->trashed()) {}

Получить все модели, в том числе и псевдоудаленные
$flights = App\Flight::withTrashed()->where('account_id', 1)->get();

Получить только псевдоудалённые модели
$flights = App\Flight::onlyTrashed()->where('airline_id', 1)->get();

Восстановить псевдоудалённые модели
$flight->restore();
App\Flight::withTrashed()->where('airline_id', 1)->restore();

Перманентно удалить псевдоудалённую модель
$flight->forceDelete();

Принудительно удалить все связанные модели
$flight->history()->forceDelete();

Глобальные заготовки (Scope)
Позволяют добавить ограничения во ВСЕ запросы, для данной модели

Определите класс, реализующий интерфейс Illuminate\Database\Eloquent\Scope и метод apply
public function apply(Builder $builder, Model $model) {
    $builder->where('age', '>', 200); //ограничение where
}

Если глобальная заготовка добавляет столбцы для выбора спецификации запроса, надо использовать метод addSelect, а не select

Для назначения глобальной заготовки на модель, переопределить метод boot данной модели
protected static function boot() {
    parent::boot();
    static::addGlobalScope(new AgeScope);
}

После добавления заготовки, например запрос User::all() будет создавать следующий SQL
select * from `users` where `age` > 200

Анонимные глобальные заготовки
Глобальные заготовки с помощью замыканий, что удобно для простых заготовок без отдельного класса
protected static function boot() {
    parent::boot();
    static::addGlobalScope('age', function (Builder $builder) {
        $builder->where('age', '>', 200);
    });
}

Удалить глобальные заготовки
Чтобы удалить глобальную заготовку для данного запроса, надо использовать метод withoutGlobalScope, передавая в него имя класса глобальной заготовки
User::withoutGlobalScope(AgeScope::class)->get();

Удалить все глобальные заготовки
User::withoutGlobalScopes()->get();

Удалить некоторые глобальные заготовки
User::withoutGlobalScopes([FirstScope::class, SecondScope::class])->get();

Заготовки позволяют повторно использовать логику запросов в моделях. Для создания заготовки просто начните имя метода с префикса scope

public function scopePopular($query) {
    return $query->where('votes', '>', 100);
}

public function scopeActive($query) {
    return $query->where('active', 1);
}

Когда заготовка определена, вы можете вызывать методы заготовки при запросах к модели, можно сцеплять разные заготовки
$users = App\User::popular()->active()->orderBy('created_at')->get();

Динамические заготовки с параметрами на лету
public function scopeOfType($query, $type) {
    return $query->where('type', $type);
}

и потом
$users = App\User::ofType('admin')->get();

События
Можно добавить обработчики событий с помощью методов creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored. и выполнять код при каждом сохранении или изменении класса конкретной модели в БД

Когда новая модель сохраняется первый раз, возникают события creating/created
Если модель уже существовала на момент вызова метода save, вызываются события updating/updated
В обоих случаях также возникнут события saving/saved

protected $events = [
    'saved' => UserSaved::class,
    'deleted' => UserDeleted::class,
];

Наблюдатели
Если вы прослушиваете много событий для модели, то можете использовать наблюдателей (обсерверов) для объединения всех слушателей в единый класс. В классах наблюдателей названия методов отражают те события которые вы хотите прослушивать. Для регистрации наблюдателя используйте метод observe на наблюдаемой модели. Вы можете зарегистрировать наблюдателей в методе boot одного из ваших сервис-провайдеров



RELATIONSHIPS

https://laravel.com/docs/5.5/eloquent-relationships

Отношения определяются как методы для классов моделей Eloquent

Связь один к одному
модель User и Phone

class User extends Model {
    public function phone() {
        return $this->hasOne('App\Phone');
    }
}

class Phone extends Model {
    public function user() {
        return $this->belongsTo('App\User');
    }
}

Динамические свойства позволяют обращаться к методам отношений как к свойствами самой модели
$phone = User::find(1)->phone;

Автоматически предполагается что модель Phone имеет внешний ключ user_id
Автоматически предполагается что имя внешнего ключа соответствует столбцу id (или кастомному $primaryKey) родителя
Если хотите задать другое имя столбца, то передать его третьим аргументом

return $this->hasOne('App\Phone', 'foreign_key');

belongsTo может отдать модель по-умолчанию, пустую или с аттрибутами, если взаимосвязь null

return $this->belongsTo('App\User')->withDefault();

return $this->belongsTo('App\User')->withDefault(['name' => 'Guest Author',]);

return $this->belongsTo('App\User')->withDefault(function ($user) {$user->name = 'Guest Author';});

Связь один ко многим
модель Post и Comment

class Post extends Model {
    public function comments() {
        return $this->hasMany('App\Comment');
    }
}

$comments = App\Post::find(1)->comments;
foreach ($comments as $comment) {}
$comments = App\Post::find(1)->comments()->where('title', 'foo')->first();

Автоматически предполагается что внешний ключ равен "змеиное имя" родительской модели + _id
внешний ключ на модели Comment будет post_id

Можно переопределить внешний и локальный ключи
return $this->hasMany('App\Comment', 'foreign_key');
return $this->hasMany('App\Comment', 'foreign_key', 'local_key');

class Comment extends Model {
    public function post() {
        return $this->belongsTo('App\Post');
    }
}

$comment = App\Comment::find(1);
echo $comment->post->title;

Связь многие ко многим
модель User и Role
три таблицы в БД: users, roles, role_user
role_user содержит столбцы user_id, role_id

class User extends Model {
    public function roles() {
        return $this->belongsToMany('App\Role');
    }
}

$user = App\User::find(1);
foreach ($user->roles as $role) {}
return $this->belongsToMany('App\Role', 'role_user', 'user_id', 'role_id');

class Role extends Model {
    public function users() {
        return $this->belongsToMany('App\User');
    }
}

Доступ к полям таблицы role_user

$user = App\User::find(1);
foreach ($user->roles as $role) {
    echo $role->pivot->created_at; //используя аттрибут pivot
}

return $this->belongsToMany('App\Role')->withPivot('column1', 'column2');

Если в таблице role_user есть поля created_at, updated_at, и чтобы они работали, используйте метод withTimestamps

return $this->belongsToMany('App\Role')->withTimestamps();

Настройка имени pivot-атрибута
return $this->belongsToMany('App\Podcast')->as('subscription')->withTimestamps();

$users = User::with('podcasts')->get();
foreach ($users->flatMap->podcasts as $podcast) {
    echo $podcast->subscription->created_at;
}

Фильтрация результатов по столбцам таблицы role_user
return $this->belongsToMany('App\Role')->wherePivot('approved', 1);
return $this->belongsToMany('App\Role')->wherePivotIn('priority', [1, 2]);

Связь много через
Связь has-many-through обеспечивает удобный доступ к дистанционным отношениям, через промежуточное отношение
Country, имеет много Post, через User

countries
    id - integer
    name - string

users
    id - integer
    country_id - integer // страна
    name - string

posts
    id - integer
    user_id - integer // юзер
    title - string

Связь полиморфные отношения
Юзеры могут комментировать как сообщения, так и видео. Можно использовать одну таблицу comments для комментов

posts
    id - integer
    title - string
    body - text

videos
    id - integer
    title - string
    url - string

comments
    id - integer
    body - text
    commentable_id - integer // ID сообщения или видео
    commentable_type - string // имя класса модели

$post = App\Post::find(1);
foreach ($post->comments as $comment) {}

$comment = App\Comment::find(1);
$commentable = $comment->commentable; // вернет экземпляр Post или Video

Запросы на существование отношений

Получить сообщения содержащие хотя бы 1 комментарий
$posts = App\Post::has('comments')->get();

Получить сообщения содержащие три и более комментариев
$posts = Post::has('comments', '>=', 3)->get();

Получить сообщения содержащие хотя бы 1 комментарий с голосами
$posts = Post::has('comments.votes')->get();

Получить сообщения с хотя бы одним комментарием содержащим слова foo%
$posts = Post::whereHas('comments', function ($query) {
    $query->where('content', 'like', 'foo%');
})->get();

Получить сообщения в блоге у которых нет комментариев
$posts = App\Post::doesntHave('comments')->get();
$posts = Post::whereDoesntHave('comments', function ($query) {
    $query->where('content', 'like', 'foo%');
})->get();

Подсчитать кол-во результатов из отношений, не загружая их
$posts = App\Post::withCount('comments')->get();
foreach ($posts as $post) {
    echo $post->comments_count;
}

$posts = Post::withCount(['votes', 'comments' => function ($query) {
    $query->where('content', 'like', 'foo%');
}])->get();

echo $posts[0]->votes_count;
echo $posts[0]->comments_count;

Нетерпеливая загрузка
По-умолчанию у динамических свойств ленивая загрузка, данные будут загружаться только в момент обращения
Можно включить активную загрузку

$books = App\Book::all();
foreach ($books as $book) {
    echo $book->author->name;
}

В этом цикле будет
1 запрос для извлечения всех книг в таблице
25 запросов для извлечения автора для каждой книги

Активная загрузка, уменьшит эту операцию до 2 запросов
$books = App\Book::with('author')->get();
foreach ($books as $book) {
    echo $book->author->name;
}

Активная загрузка нескольких разных отношений
$books = App\Book::with(['author', 'publisher'])->get();

Загруженные вложенные отношения
$books = App\Book::with('author.contacts')->get();

Динамически решить следует ли загружать связанные модели
$books = App\Book::all();
if ($someCondition) {
    $books->load('author', 'publisher');
}

Вставка и обновление связанных моделей
$comment = new App\Comment(['message' => 'A new comment']);
$post = App\Post::find(1);
$post->comments()->save($comment);
Метод автоматически добавит соответствующий post_id для новой модели Comment

$post = App\Post::find(1);
$post->comments()->saveMany([
    new App\Comment(['message' => 'A new comment']),
    new App\Comment(['message' => 'Another comment']),
]);

Методы create и save
save принимает экземпляр модели Eloquent
create принимает простой PHP массив

$post = App\Post::find(1);
$comment = $post->comments()->create(['message' => 'A new comment',]);

$post->comments()->createMany([
    ['message' => 'A new comment',],
    ['message' => 'Another new comment',],
]);


Для случая у юзера много ролей, у роли много юзеров

Прикрепить роль к пользователю, вставив запись в промежуточную таблицу
$user = App\User::find(1);
$user->roles()->attach($roleId);

Прикрепить роль к пользователю и вставить массив дополнительных данных в промежуточную таблицу
$user->roles()->attach($roleId, ['expires' => $expires]);

Удалить роль у юзера
$user->roles()->detach($roleId);

Удалить все роли у юзера
$user->roles()->detach();

Удалить некоторые роли у юзера
$user->roles()->detach([1, 2, 3]);

Прикрепить некоторые роли к юзеру, с дополнительными данными
$user->roles()->attach([
    1 => ['expires' => $expires],
    2 => ['expires' => $expires]
]);

Синхронизация ассоциаций в промежуточной таблице юзер-роль
$user->roles()->sync([1, 2, 3]); // установит роли с id 1,2,3 и удалит все остальные
$user->roles()->sync([1 => ['expires' => true], 2, 3]);

Если не хотите удалять все остальные
$user->roles()->syncWithoutDetaching([1, 2, 3]); // добавит роли с id 1,2,3 не удаляя старые

Переключающие ассоциации в промежуточной таблице юзер-роль
Метод toggle будет переключать. Если идентификатор подключен, то будет отсоединен. если отсоединен, то будет подключен
$user->roles()->toggle([1, 2, 3]);

Сохранение дополнительных данных в промежуточной таблице
Метод save принимает в качестве второго аргумента массив дополнительных атрибутов промежуточной таблицы
App\User::find(1)->roles()->save($role, ['expires' => $expires]);

Обновление записи на промежуточной таблице
$user = App\User::find(1);
$user->roles()->updateExistingPivot($roleId, $attributes);

Обновление меток времени родителя
для belongsTo или belongsToMany. например Comment и Post
обновить временную метку родителя при обновлении дочерней модели
когда Comment обновляется, обновить updated_at у Post

class Comment extends Model {
    protected $touches = ['post'];
}



COLLECTIONS

https://laravel.com/docs/5.5/eloquent-collections

Все выборки Eloquent являются коллекциями Illuminate\Database\Eloquent\Collection и наследуют все методы работы с коллекциями

$users = App\User::where('active', 1)->get();
foreach ($users as $user) {
    echo $user->name;
}

Удалить из выборки неактивных юзеров, и собрать имена оставшихся
$names = $users->reject(
    function ($user) {
        return $user->active === false;
    })
 ->map(
     function ($user) {
            return $user->name;
});



MUTATORS

https://laravel.com/docs/5.5/eloquent-mutators

Аксессоры и мутаторы позволяют форматировать значения атрибутов Eloquent при выборке или вставке/обновлении
Например шифровать значение при вставке в БД, и дешифровать при выборке

Акцессор
Создайте getFooAttribute метод в модели, где Foo это "стадное имя столбца" к которому надо получить доступ. Исходное значение столбца передается аксессору для манипуляций

public function getFirstNameAttribute($value) {
    return ucfirst($value);
}

И потом получить так
$user = App\User::find(1);
$firstName = $user->first_name;

public function getFullNameAttribute() {
    return "{$this->first_name} {$this->last_name}";
}

И потом получить так
$user = App\User::find(1);
$firstName = $user->full_name;

Мутатор
Создайте setFooAttribute метод в модели, где Foo это "стадное имя столбца" к которому надо получить доступ. Этот мутатор будет автоматически вызываться, когда мы попытаемся установить значение first_name атрибута в модели. Мутатор получит значение, которое устанавливается в атрибуте, для манипуляций

public function setFirstNameAttribute($value) {
    $this->attributes['first_name'] = strtolower($value);
}

Мутатор даты
По-умолчанию Eloquent преобразует столбцы created_at и updated_at в экземпляры Carbon, который расширяет DateTime класс PHP. Можно настроить какие даты автоматически мутируются, или отключить мутацию. Когда столбец считается датой, вы можете установить его значение как временную метку UNIX, строку даты, и значение даты будет автоматически сохранено в БД.

При извлечении атрибутов перечисленных в свойстве $dates они будут автоматически переданы в Carbon что позволит использовать любые методы Carbon

return $user->deleted_at->getTimestamp();

Формат даты
По-умолчанию метки времени форматируются как 'Y-m-d H:i:s'. Настроить формат можно в свойстве $dateFormat модели

Атрибут Casting
Свойство $casts модели обеспечивает удобный способ преобразования атрибутов общих типов данных
Поддерживаемые типы: integer, real, float, double, string, boolean, object, array, collection, date, datetime, timestamp

Выделим атрибут is_admin который хранится в БД как целое число 0 или 1, до логического значения

protected $casts = [
    'is_admin' => 'boolean',
];

Теперь is_admin всегда будет переведен в логический тип при доступе к нему
$user = App\User::find(1);
if ($user->is_admin) {}

Массив JSON и Casting
Например столбец options типа JSON или TEXT, в котором хранятся сериализованные JSON-массивы. Добавление array-приведения этому атрибуту автоматически сериализует/десериализует массив при выборке/вставке

protected $casts = [
    'options' => 'array',
];

$user = App\User::find(1);
$options = $user->options;
$options['key'] = 'value';
$user->options = $options;
$user->save();



API RESOURCES

https://laravel.com/docs/5.5/eloquent-resources

Слой преобразования между Eloquent-моделями и ответами JSON
Ресурсы лежат в папке app/Http/Resources
Ресурсы расширяют класс Illuminate\Http\Resources\Json\Resource
Коллекции ресурсов расширяют класс Illuminate\Http\Resources\Json\ResourceCollection
Класс ресурсов представляет собой единую модель, которая должна быть преобразована в структуру JSON

Ресурсы преобразуют отдельные модели
Коллекции ресурсов преобразуют коллекции моделей

Ресурсы переводят одну модель в массив
Коллекции ресурсов преобразуют коллекцию моделей в массив

Создать ресурс
php artisan make:resource User123
это создаст класс app/Http/Resources/User123.php

Создать коллекцию ресурсов
php artisan make:resource Users456 --collection
это создаст класс app/Http/Resources/Users456.php

Ресурс
Route::get('/user', function () {
    return new UserResource(User::find(1));
});

Коллекция ресурсов
Route::get('/user', function () {
    return UserResource::collection(User::all());
});

В методе toArray набор аттрибутов, который должен быть преобразован в JSON при отправке ответа
public function toArray($request) {
    return [
        'id' => $this->id,
        'name' => $this->name,
        'email' => $this->email,
        'created_at' => $this->created_at,
        'updated_at' => $this->updated_at,
    ];
}

Отношения
Включить связанные ресурсы в ответ
public function toArray($request) {
    return [
        'id' => $this->id,
        'name' => $this->name,
        'email' => $this->email,
        'posts' => Post::collection($this->posts),
        'created_at' => $this->created_at,
        'updated_at' => $this->updated_at,
    ];
}

Обертка данных в JSON
По-умолчанию любой внешний ресурс обернут в JSON
это можно это отключить в AppServiceProvider в методе

public function boot() {
    Resource::withoutWrapping();
}

Пагинация
Такие ответы всегда содержат сами данные, подмассивы meta и links пагинатора, даже если был вызван метод nonWrapping

Route::get('/users', function () {
    return new UserCollection(User::paginate());
});

Условные атрибуты
Включить атрибут в ответ, если выполнено условие
например указать значение если текущий юзер админ
метод when

return [
    'id' => $this->id,

 //так
 'secret' => $this->when($this->isAdmin(), 'secret-value'),

 //или через замыкание
 'secret' => $this->when($this->isAdmin(), function () {return 'secret-value';}),

];

Слияние условных атрибутов
Включить несколько аттрибутов в ответ, если выполнено условие
return [
    'id' => $this->id,

    $this->mergeWhen($this->isAdmin(), ['first-secret' => 'value','second-secret' => 'value']),
];

Условные отношения

return [
    'id' => $this->id,
    'posts' => Post::collection($this->whenLoaded('posts')),
];

включать данные из промежуточных таблиц отношений "многие ко многим" используя метод whenPivotLoaded

return [
    'id' => $this->id,
    'expires_at' => $this->whenPivotLoaded('role_users', function () {return $this->pivot->expires_at;}),
];

Добавление метаданных

return [
    'data' => $this->collection,
    'links' => ['self' => 'link-value',],
];

Включить только определенные метаданные

public function toArray($request) {
    return parent::toArray($request);
}

public function with($request) {
    return ['meta' => ['key' => 'value',],];
}

или

return (new UserCollection(User::all()->load('roles')))->additional(['meta' => ['key' => 'value',]]);

Настроить исходящий HTTP-запрос до его отправки

Route::get('/user', function () {
    return (new UserResource(User::find(1)))->response()->header('X-Value', 'True');
});

или в ресурсе

public function withResponse($request, $response) {
    $response->header('X-Value', 'True');
}



SERIALIZATION

https://laravel.com/docs/5.5/eloquent-serialization

Преобразовать модель и ее загруженные отношения в массив
$user = App\User::with('roles')->first();
return $user->toArray();

Преобразовать коллекции моделей в массив
$users = App\User::all();
return $users->toArray();

Преобразовать модель в JSON
$user = App\User::find(1);
return $user->toJson();

Удалить аттрибуты модели из JSON-массива
перечислить их в классе модели, в свойстве $hidden

Белый список аттрибутов модели
перечислить в классе модели, в свойстве $visible
все остальные будут скрыты

Временное скрыть/показать атрибуты модели на данном экземпляре модели
return $user->makeVisible('attribute')->toArray();
return $user->makeHidden('attribute')->toArray();

Добавление своих элементов в массив выборки JSON

public function getIsAdminAttribute() {
   return $this->attributes['admin'] == 'yes';
}

Сериализация даты
public function boot() {
    Carbon::serializeUsing(function ($carbon) {
        return $carbon->format('U');
    });
}



TESTING GETTING STARTED

https://laravel.com/docs/5.5/testing

PHPUnit
Настроки в phpunit.xml
Юнит-тесты тестят маленький участок кода, обычно метод класса
Функциональные тесты тестят большую часть кода
классы тестов в папках Feature и Unit

Создать Feature-тест
php artisan make:test UserTest
это создаст класс tests/Feature/UserTest.php

Создать Unit-тест
php artisan make:test UserTest --unit
это создаст класс tests/Unit/UserTest.php

Запустить тесты
phpunit



HTTP TESTS

https://laravel.com/docs/5.5/http-tests

class ExampleTest extends TestCase {
    public function testBasicTest() {
        $response = $this->get('/');
        $response->assertStatus(200); // возвращаемый ответ должен быть HTTP 200
    }
}

Метод withHeaders для настройки заголовков запроса до его отправки
$response = $this->withHeaders(['X-Header' => 'Value',])->json('POST', '/user', ['name' => 'Sally']);
$response->assertStatus(200)->assertJson(['created' => true]);

Установить данные сеанса
$response = $this->withSession(['foo' => 'bar'])->get('/');

Аутентификация пользователя
Сохранение состояния аутентифицированного пользователя в методе actingAs

Тестирование API JSON
$response = $this->json('POST', '/user', ['name' => 'Sally']);
$response->assertStatus(200)->assertJson(['created' => true]);

Проверка точного совпадения JSON
Чтобы проверить что данный массив равен массиву возвращаемого приложением
Метод assertExactJson

Загрузка файлов
Метод fake для создания фиктивных файлов, изображений. Можно указать ширину, высоту, размер изображения
UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);

Методы утверждения для тестов PHPUnit
их тут больше 20



BROWSER TESTS

https://laravel.com/docs/5.5/dusk

Laravel Dusk для автоматизации браузера и тестирования
не требует установки JDK или Selenium
использует отдельную установку ChromeDriver

Добавить зависимость
composer require --dev laravel/dusk

Зарегистрировать сервис-провайдер Laravel\Dusk\DuskServiceProvider
public function register() {
    if ($this->app->environment('local', 'testing')) {
        $this->app->register(DuskServiceProvider::class);
    }
}

Установить Dusk
php artisan dusk:install
это создаст папку tests/Browser

Запустить тесты Dusk
php artisan dusk

Создать тест Dusk
php artisan dusk:make LoginTest
это создаст класс tests/Browser/logintest.php

Создать файл среды для Dusk
.env.dusk.{environment}

Аутентификация
Метод loginAs аутентифицирует без взаимодействия со страницей логина

Кликнуть по ссылке или элементу
$browser->clickLink($linkText);
$browser->click('.selector');

Получить value элемента
$value = $browser->value('selector');

Установить value элемента
$browser->value('selector', 'value');

Получить текст элемента
Метод text

Получить аттрибут элемента
Метод attribute

Заполнить поле
$browser->type('email', 'taylor@laravel.com');

Очистить поле
Метод clear

Выбрать значение селекта
Метод select. Чтобы выбрать случайную опцию опустите второй параметр

Отметить/снять чекбокс
$browser->check('terms');
$browser->uncheck('terms');

Отметить радиобуттон
Метод radio

Прикрепить файл к полю file
Метод attach

Заполнить поле с нажатием кнопок-модификаторов
Все кнопки-модификаторы оборачиваются в символы {} и совпадают с константами определенными в классе Facebook\WebDriver\WebDriverKeys
$browser->keys('selector', ['{shift}', 'taylor'], 'otwell');

Еще методы
$browser->mouseover('.selector');
$browser->drag('.from-selector', '.to-selector');

Выполнить операцию, убедившись в наличии чего-либо
Методом with

Ожидание
$browser->pause(1000);

Ожидание элементов
$browser->waitFor('.selector'); // по-умолчанию ждем 5сек
$browser->waitFor('.selector', 1); // ждем 1 секунду

Ожидание скрытия элемента
$browser->waitUntilMissing('.selector');
$browser->waitUntilMissing('.selector', 1);

Ожидание элемента, и взаимодействие с ним
Метод whenAvailable

waitForText - ожидание появления текста на странице
waitForLink - ожидание появления текста-ссылки на странице

Ожидание урла
$browser->assertPathIs('/home'); // может быть неудачным если window.location.pathname обновляется асинхронно
$browser->waitForLocation('/home');

Ожидание перезагрузки
Метод waitForReload

Ожидание выполнения js-выражения
Метод waitUntil

Все wait-методы основываны waitUsing, его можно использовать напрямую, ожидая в замыкании true
Всего утверждений около 30

Страницы
Когда в тестах требуется последовательно выполнить несколько сложных действий. Страницы позволяют определять действия, которые затем выполняются на каждой странице

Создать объект страницы
php artisan dusk:page Login
это создаст класс tests/Browser/Pages/login.php

Travis CI (Continue Integration)
Для запуска Dusk-тестов на Travis CI
требуется sudo-enabled, Ubuntu

CircleCI 1.0
Для запуска Dusk-тестов

CircleCI 2.0
Для запуска Dusk-тестов



DATABASE

https://laravel.com/docs/5.5/database-testing

Тестирование БД

Проверить что в БД есть юзер с таким мылом
$this->assertDatabaseHas('users', [
    'email' => 'sally@example.com'
]);

Проверить что не существует
Метод assertDatabaseMissing

Создать фабрику
php artisan make:factory PostFactory
это создаст класс database/factories/PostFactory.php

Создать фабрику с указанием модели
php artisan make:factory PostFactory --model=Post
это создаст класс database/factories/PostFactory.php

Сбросить БД после теста
use RefreshDatabase;

Вставка записей в фабрике
$factory->define(App\User::class, function (Faker $faker) {
    static $password;
    return [
        'name' => $faker->name,
        'email' => $faker->unique()->safeEmail,
        'password' => $password ?: $password = bcrypt('secret'),
        'remember_token' => str_random(10),
    ];
});



MOCKING

https://laravel.com/docs/5.5/mocking

Мокинг - имитация

Альтернатива мокингу
Всё это будет "какбы выполнено" и можно инспектировать данные которые пришли в обратку

метод fake фасада Bus для предотвращения выполнения задач
метод fake фасада Event для предотвращения выполнения слушателей
метод fake фасада Mail для предоствращения отправки почты
метод fake фасада Notification для предоствращения отправки уведомлений
метод fake фасада Queue для предотвращения помещения задач в очередь
метод fake фасада Storage для генерации фейкового диска, плюс генерация файлов UploadedFile



CASHIER

https://laravel.com/docs/5.5/billing

Laravel Cashier - сервис биллинговых подписок Stripe и Braintree. Может работать с подписками, купонами, заменой подписок, количеством подписок, отменой льготного периода, генерировать PDF-файлы счетов. Stripe и Braintree не работают в России. Принимает банковские карты, PayPal

Добавить пакет
composer require "laravel/cashier":"~7.0"

Зарегистрировать сервис-провайдер
Laravel\Cashier\CashierServiceProvider в config/app.php

Добавить столбцы в таблицу users, создать таблицу subscriptions
Добавить трейт Billable в модель. Этот трейт предоставляет методы выполняющие стандартные биллинг-задачи
Настроить ключ Stripe в services.php. Ключи Stripe API получить в панели управления Stripe

Добавить пакет
composer require "laravel/cashier-braintree":"~2.0"

Зарегистрировать сервис-провайдер
Laravel\Cashier\CashierServiceProvider в config/app.php

Добавить столбцы в таблицу users, создать таблицу subscriptions
Добавить трейт Billable в модель
Настроить API ключи в services.php



ENVOY

https://laravel.com/docs/5.5/envoy

Laravel Envoy - настройка задач развертывания на удалённых серверах, запуск команд ОС и Artisan. Требует Mac/Linux. На основе библиотеки Elegant SSH tasks for PHP

Добавить пакет
composer global require laravel/envoy

Расположение Envoy-задач
в файле Envoy.blade.php в корне проекта

Пример задачи
@servers(['web' => ['user@192.168.1.1']])
@task('foo', ['on' => 'web'])
    ls -la
@endtask

@servers - массив серверов, ссылаться на сервера по именам в параметре on
@task - внутрь поместить Bash-код который будет исполняться

Выполнить PHP-код
@setup
    $now = new DateTime();
    $environment = isset($env) ? $env : "testing";
@endsetup

Подключить любые PHP-файлы
@include('vendor/autoload.php')

Передать переменные в файл Envoy через командную строку
envoy run deploy --branch=master

далее в скрипте
@if ($branch)
    git pull origin {{ $branch }}
@endif

Запустить Artisan-команду
php artisan migrate

Запустить Git-команду
git pull origin master

Создать историю
Они группируют набор задач под одним именем

@story('deploy')
    git
    composer
@endstory

@task('git')
    git pull origin master
@endtask

@task('composer')
    composer install
@endtask

Запустить историю
envoy run deploy

Запустить задачу на нескольких серверах
@servers(['web-1' => '192.168.1.1', 'web-2' => '192.168.1.2'])
@task('deploy', ['on' => ['web-1', 'web-2']])
    cd site
    git pull origin {{ $branch }}
    php artisan migrate
@endtask

По-умолчанию задачи будут выполняться на каждом сервере по очереди, последовательно от сервера к серверу
Выполнять задачи на нескольких серверах параллельно - добавить параметр parallel в объявление задачи

Запустить задачу с именем task из файла Envoy.blade.php
envoy run task

Запросить подтверждение на выполнение
добавить директиву @confirm

Отправить уведомление в Slack после выполнения задачи
добавить директиву @slack



HORIZON

https://laravel.com/docs/5.5/horizon

Horizon - панель для очередей Redis
Требует PHP 7.1+ потому что использует async process signals
Настройки в config/horizon.php

Добавить пакет
composer require laravel/horizon

Пройти по урлу
/horizon
работает в local среде

Опубликовать активы
php artisan vendor:publish --provider="Laravel\Horizon\HorizonServiceProvider"

Типы стратегий
simple, auto, false

Auto
регулирует количество рабочих процессов в очереди, на основе текущей рабочей нагрузки очереди

Запустить Horizon
php artisan horizon

Поставить на паузу Horizon
php artisan horizon:pause

Снять паузу с Horizon
php artisan horizon:continue

Остановить Horizon
php artisan horizon:terminate

Настроить монитор процесса Supervisor для контроля за php artisan horizon и автоматическим перезапуском
Можно назначать теги для заданий
Можно вручную определить теги для объектов в очереди с помощью метода tags
При использовании уведомлений добавить пакет Composer в проект



PASSPORT

https://laravel.com/docs/5.5/passport

Это реализация сервера OAuth2 для API-аутентификации, которая использует токены для аутентификации юзеров, не сохраняет состояние сессии между запросами

Добавить пакет
composer require laravel/passport

Зарегистрировать сервис-провайдер
Laravel\Passport\PassportServiceProvider в массиве providers в config/app.php

Запустить миграции для создания таблиц
php artisan migrate

Будут созданы
- ключи шифрования для генерации токенов доступа
- клиенты personal access (персональный доступ) и password grant (предоставление пароля)

Запустить
php artisan passport:install

Добавить трейт
Laravel\Passport\HasApiTokens в модель App\User

Зарегистрировать роуты
Вызвать метод Passport::routes из метода boot своего AuthServiceProvider. Этот метод зарегистрирует роуты для выдачи токенов доступа, отмены действия токенов, клиентов, персональных токенов доступа

public function boot() {
    $this->registerPolicies();
    Passport::routes();
}

В config/auth.php задайте значение passport параметру driver

'guards' => [
    'web' => [
        'driver' => 'session',
        'provider' => 'users',
    ],

    'api' => [
        'driver' => 'passport',
        'provider' => 'users',
    ],
],

Passport содержит встроенные компоненты Vue
Passport поставляется с JSON API который позволяет разрешать юзерам создавать клиентов и персональные токены доступа

Опубликовать Vue-компоненты
php artisan vendor:publish --tag=passport-components

Перекомпилировать ресурсы
npm run dev

Сгенерировать ключи шифрования
php artisan passport:keys

По-умолчанию Passport выдаёт длительные токены доступа, которые вообще не надо обновлять

Клиентское приложение перенаправляет юзера на ваш сервер, где разрешается или запрещается запрос на получение токена доступа. Разработчики приложений регистрируют свои приложения в вашем, создав "клиента", вбивая название и урл, на который ваше приложение сможет перенаправлять пользователей, когда они запрашивают авторизацию

Создать клиента
php artisan passport:client

После создания клиента ему будут выданы ID и секретная строка. Эти значения будут использоваться при запросе токенов доступа у вашего приложения. После создания клиента разработчики могут использовать ID и секретную строку своего клиента для запроса кода авторизации и токенов доступа у вашего приложения. Предоставление пароля OAuth2 позволяет вашим клиентам, таким как мобильное приложение, получить токен доступа с помощью e-mail/логина и пароля. Это позволяет вам безопасно выдавать токены доступа своим клиентам, не требуя от пользователя проходить через весь процесс авторизационного редиректа OAuth2. При использовании предоставления пароля вам может понадобиться авторизовать токен для всех прав, поддерживаемых в вашем приложении. Это можно сделать, запросив право *. При создании API бывает полезно иметь возможность использовать ваш API из вашего JavaScript-приложения. Такой подход к разработке API позволяет вашему приложению использовать тот же API, который вы предоставляете всем остальным. Один и тот же API может быть использован вашим веб-приложением, мобильными приложениями, сторонними приложениями и любыми SDK, которые вы можете опубликовать в различных менеджерах пакетов. Если вы хотите использовать свой API из вашего JavaScript-приложения, вам необходимо вручную послать токен доступа в приложение и передавать его с каждым запросом в ваше приложение. Однако, Passport содержит посредника, который может обработать это для вас.

События
События при создании и обновлении токенов доступа, вы можете прикрепить слушателей к этим событиям в EventServiceProvider вашего приложения



SCOUT

https://laravel.com/docs/5.5/scout

Добавление драйверов полнотекстового поиска в Eloquent-модели и автоматической синхронизации поисковых индексов с записями Eloquent

Добавить пакет
composer require laravel/scout

Зарегистрировать провайдер
добавить ScoutServiceProvider в массив providers в config/app.php

Опубликовать конфигурацию
php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider"
опубликует файл настроек scout.php в папку config

Добавить трейт
Laravel\Scout\Searchable в модель которую хотите сделать доступной для поиска
И просто сохраняйте модели обычным методом save, они автоматически добавятся в поисковый индекс. Если настроены очереди, то эта операция произойдет в фоне

Настроить очередь
Драйвер очереди необязателен, но после ее настройки можно ставить в очередь все операции синхронизации модели с поисковыми индексами, обеспечивая лучшее быстродействие
Задайте в параметру queue в config/scout.php параметр:
'queue' => true

Драйвер Algolia
Задайте учётные данные Algolia, id и secret, в config/scout.php
Добавить пакет
composer require algolia/algoliasearch-client-php

Каждая Eloquent-модель синхронизируется с заданным поисковым индексом, который содержит все записи для поиска по этой модели. Можно представить каждый индекс как таблицу MySQL. По-умолчанию для каждой модели будет назначен индекс, совпадающий с именем таблицы модели.

По-умолчанию в индексе модели будут все её данные, аналогичные результату toArray

Если устанавливаете Scout на существующий проект и в БД уже есть записи. Их надо импортировать в драйвер поиска в поисковые индексы, командой
php artisan scout:import "App\Post"

Добавить коллекцию моделей в поисковый индекс
добавить метод searchable к запросу Eloquent

Начать поиск
$orders = App\Order::search('Star Trek')->get();

Получить необработанные результаты прежде, чем они будут сконвертированы в модели Eloquent
$orders = App\Order::search('Star Trek')->raw();

Пагинация
$orders = App\Order::search('Star Trek')->paginate(100);

@foreach ($orders as $order)
    {{ $order->price }}
@endforeach
{{ $orders->links() }}



SOCIALITE

https://laravel.com/docs/5.5/socialite

Аутентификация с поставщиками OAuth, через Facebook, Twitter, LinkedIn, Google, GitHub, Bitbucket

Все адаптеры социальных сетей
https://socialiteproviders.github.io

Добавить пакет
composer require laravel/socialite

Настроить учетные данные для служб OAuth
'github' => [
    'client_id' => env('GITHUB_CLIENT_ID'),         // Your GitHub Client ID
    'client_secret' => env('GITHUB_CLIENT_SECRET'), // Your GitHub Client Secret
    'redirect' => 'http://your-callback-url',
],

Роуты
один для редиректа юзера поставщику OAuth
второй для получения обратного вызова от провайдера после аутентификации

Получить сведения о юзере
$user = Socialite::driver('github')->user();
$user->getId();
$user->getNickname();
$user->getName();
$user->getEmail();
$user->getAvatar();

Получить сведения о юзере если есть токен доступа
$user = Socialite::driver('github')->userFromToken($token);



ОСНОВНЫЕ КОМАНДЫ ARTISAN

Все команды вбиваются в папке проекта
cd projectname

Cписок всех artisan-команд
php artisan list

Показать подсказку по команде
php artisan help commandname

Создать провайдер
php artisan make:provider NameServiceProvider

Создать посредника
php artisan make:middleware AnyName

Создать контроллер
php artisan make:controller NameController

Создать контроллер ресурсов (с методами CRUD)
php artisan make:controller NameController --resource

Создать контроллер ресурсов (с методами CRUD) с экземпляром модели Eloquent\Model
php artisan make:controller NameController --resource --model=Photo

Создать валидацию FormRequest
php artisan make:request StoreBlogPost

Создать аутентификацию
php artisan make:auth
php artisan migrate

Cоздать политику
php artisan make:policy PostPolicy

Создать политику с методами CRUD
php artisan make:policy PostPolicy --model=Post

Запустить Tinker
php artisan tinker

Список всех роутов
php artisan route:list

Создать таблицу для хранения элементов кэша для драйвера Database
php artisan cache:table

Добавить слушателей и события в EventServiceProvider, и сгенерировать события и слушатели
php artisan event:generate

Создать ключи шифрования для генерирования токенов доступа для API-аутентификации
php artisan passport:install
php artisan passport:keys

Создать символическую ссылку с public/storage на storage/app/public
php artisan storage:link

Создать класс email-сообщения
php artisan make:mail OrderShipped

Создать класс Markdown email-сообщения
php artisan make:mail OrderShipped --markdown=emails.orders.shipped

Создать уведомление
php artisan make:notification InvoicePaid

Применить созданные миграции, это создаст таблицы
php artisan migrate

Создать таблицу для очередей задач для драйвера очередей Database
php artisan queue:table
php artisan migrate

Создать задачу для очереди
php artisan make:job SendReminderEmail

Запустить воркеры очереди
php artisan queue:work

Перезапустить воркеры
php artisan queue:restart

Создать таблицу проваленных задач очередей
php artisan queue:failed-table
php artisan migrate

Посмотреть все проваленные задачи в таблице failed_jobs
php artisan queue:failed

Выполнить задачу с ID=5
php artisan queue:retry 5

Повторить все проваленные задачи
php artisan queue:retry all

Удалить проваленную задачу с ID=5
php artisan queue:forget 5

Удалить все проваленные задачи
php artisan queue:flush

Экспортировать шаблоны пагинатора из папки vendor\laravel\framework\src\Illuminate\Pagination\resources\views в папку resources\views\vendor\pagination для ручного изменения
php artisan vendor:publish --tag=laravel-pagination

Создать миграцию
php artisan make:migration create_users_table

Отменить изменения, сделанные последней миграцией
php artisan migrate:rollback

Откатить нужное число миграций
php artisan migrate:rollback --step=5

Откатить изменения всех миграций
php artisan migrate:reset

Отменить изменения всех миграций, и пересоздать всю БД
php artisan migrate:refresh

Обновить БД и запустить заполнение БД начальными данными
php artisan migrate:refresh --seed

Откатить и повторно применить нужное число миграций
php artisan migrate:refresh --step=5

Добавить тестовые данные в таблицу
php artisan make:seeder UsersTableSeeder

Заполнить тестовыми данными таблицы
php artisan db:seed

Создать модель Eloquent
php artisan make:model User2

Создать модель Eloquent с миграцией
php artisan make:model User4 --migration

Создать ресурс
php artisan make:resource User123

Создать коллекцию ресурсов
php artisan make:resource Users456 --collection

Создать Feature-тест
php artisan make:test UserTest

Создать Unit-тест
php artisan make:test UserTest --unit

Установить Dusk
php artisan dusk:install

Запустить тесты Dusk
php artisan dusk

Создать тест Dusk
php artisan dusk:make LoginTest

Создать объект страницы
php artisan dusk:page Login

Создать фабрику
php artisan make:factory PostFactory

Создать фабрику с указанием модели
php artisan make:factory PostFactory --model=Post