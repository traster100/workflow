Операции с многобайтовыми строками

Длинна строки в любой кодировке

$a1 = 'абвгд';
$a2 = 'abvgd';

echo strlen($a1); // 10
echo strlen($a2); // 5

echo mb_strlen($a1); // 10
echo mb_strlen($a2); // 5

echo iconv_strlen($a1); // 10
echo iconv_strlen($a2); // 5

echo mb_strlen($a1, 'utf-8'); // 5
echo mb_strlen($a2, 'utf-8'); // 5

echo iconv_strlen($a1, 'utf-8'); // 5
echo iconv_strlen($a2, 'utf-8'); // 5

Вырезать кусок строки
iconv_substr($login, 0, 29, 'UTF-8');

Смена кодировки строки
iconv('UTF-8', 'Windows-1251', $string);
---------------------------------------------------------------------------------------------------

Замена переводов строки ['\n', '\r', '\r\n'] на <br> в textarea

- при сохранении в базу
str_replace(PHP_EOL, '<br>', $text);

- при выводе
str_replace('<br>', PHP_EOL, $text);
---------------------------------------------------------------------------------------------------

Первая буква из строки UTF-8
mb_substr($v->name, 0, 1);

Урлы подключения js и css, со сбросом кеша. В параметр ставим время изменения файла
'?filemtime=filemtime(pathtofile)'
---------------------------------------------------------------------------------------------------

Оператор Элвиса
"A ?: B" равен оператору "A ? A : B"
---------------------------------------------------------------------------------------------------

Замена запятой на точку, в цифре
$post['amount'] = str_replace(',', '.', $post['amount']);
---------------------------------------------------------------------------------------------------

Прибавление 0.5% к числу
$amount = round($amount + (($amount * 0.5) / 100), 0);
---------------------------------------------------------------------------------------------------

TIMESTAMP из БД вывести в нужном формате
date('d.m.Y H:i:s', strtotime($order->created))
date('d.m.Y H:i:s', $order->created)

Так вставит текущее время пхп date("Y-m-d H:i:s")
А так вставит текущее время mysql $this->db->set('last_visit', 'NOW()', false)
---------------------------------------------------------------------------------------------------

Вставка в базу времени 'текущее время + 3 месяца'

1 метод. генерим время из php
$expired = new DateTime('+ 3 month');
$this->model_user->update(['expired' => $expired->format('Y-m-d')], $id);

2 метод. генерим время на стороне MYSQL
$this->db->where('id', $id);
$this->db->set('expired', 'NOW() + INTERVAL 3 MONTH', false);
$this->db->update('users');

3 метод
DATE_ADD(NOW(), INTERVAL 2 HOUR) - вставит дату, прибавив 2 часа
---------------------------------------------------------------------------------------------------

Онлайн на сайте

статус онлайн/офлайн
в футере админки js скрипт раз в N минут обновляет время last_visit посылая post-ajax запрос

отображение время последнего захода
если 'NOW() > last_visit + 5мин', то считаем что админ офлайн. и выводим время 'бы в сети "NOW() - last_visit минут назад'
---------------------------------------------------------------------------------------------------

ИЗ МАССИВА ВЫБИРАЕМ IDs КАК МАССИВ
$orders_ids = array_map(function ($value) {
    return $value->id;
}, $orders);


СУММА МАССИВА ПО ОДНОМУ ИЗ ПОЛЕЙ
$sum = array_sum(array_map(function ($v) {
    return $v->sum;
}, $array));


ПОДСЧЕТ СУММЫ, В МАССИВЕ ОБЪЕКТОВ, ПО ОДНОМУ ИЗ ПОЛЕЙ
$schedules = [
  1 =>
    object(stdClass)[39]
      public 'users_id' => string '4'
      public 'anytime' => string '1'
  2 =>
    object(stdClass)[40]
      public 'users_id' => string '4'
      public 'anytime' => string '1'
];

Найдем сумму по полю anytime:
array_reduce(
    $schedules,
    function ($total, $schedule) {
        return $total + $schedule->anytime;
    },
0);
---------------------------------------------------------------------------------------------------

Защита от XSS

1. Символы -> HTML-сущности ("&" в "&amp;" , "<" в "&lt;")
htmlspecialchars - преобразует специальные символы
htmlentities - преобразует все символы (флаг ENT_NOQUOTES)

2. HTML-сущности -> символы ("&amp;" в "&" , "&lt;" в "<")
htmlspecialchars_decode - обратная к htmlspecialchars
html_entity_decode - обратная к  htmlentities (флаг ENT_NOQUOTES)

strip_tags - Удаляет HTML теги.
HTMLPurifier - библиотека безопастной очистки HTML.

Стандарт защиты
$name = strip_tags($_POST['name']);
$name = htmlentities($_POST['name'], ENT_QUOTES, "UTF-8"); // или флаг ENT_NOQUOTES?
$name = htmlspecialchars($_POST['name'], ENT_QUOTES);
---------------------------------------------------------------------------------------------------

Криптография

Случайные числа
rand($min, $max); - старая функция
mt_rand($min, $max); - новая функция
uniqid($prefix, true); - работает на основе текущего времени в микросекундах

пример
$salt = uniqid(mt_rand()); - соль
$combine = $email . $password . $salt;
$newpassword = md5($combine);

Хэширование (необратимое шифрование)
$sha1= sha1($string);
$sha1= hash('sha1', $string);

$sha256 = hash('sha256', $string);
$sha384 = hash('sha384', $string);
$sha512 = hash('sha512', $string);

HMAC
$hmac = hash_hmac('sha1', $string, 'secret');

sha1_file — 40символьный SHA1-хеш файла.
sha1 — SHA1-хеш строки.
hash — хеш-код.
password_hash — хеш пароля, является оберткой над crypt().
hash_hmac_file — хеш-код на основе ключа, используя метод HMAC и содержимое файла.

crypt($string, $salt); - на алгоритме DES, $salt делать случайным в каждой итерации. копирует $salt в начало возвращаемой строки. использует только первые 8 символов строки $string


1. Пароль+соль1, Пароль+соль2. У каждого юзера своя соль, и хранится в бд.
2. Вторая соль глобальная и одна на всех. Пароль+соль1+ГлобальнаяСоль. Хранится в конфиге.

MD5 generates a 128-bit hash value. You can use CHAR(32) or BINARY(16)
SHA-1 generates a 160-bit hash value. You can use CHAR(40) or BINARY(20)
SHA-224 generates a 224-bit hash value. You can use CHAR(56) or BINARY(28)
SHA-256 generates a 256-bit hash value. You can use CHAR(64) or BINARY(32)
SHA-384 generates a 384-bit hash value. You can use CHAR(96) or BINARY(48)
SHA-512 generates a 512-bit hash value. You can use CHAR(128) or BINARY(64)
Лучше CHAR

public function index() {

    //имя файла
    $filename = '1_1546716534';

    //соли
    var_dump(time());
    var_dump(date('U'));
    var_dump(rand());
    var_dump(mt_rand());
    var_dump(uniqid('', true));
    var_dump(uniqid(mt_rand()));

    echo '<hr>';

    //солим имя файла
    $result = $filename;

    //функции
    var_dump(md5($result));
    var_dump(hash('sha1', $result));
    var_dump(hash('sha256', $result));
    var_dump(hash('sha384', $result));
    var_dump(hash('sha512', $result));

    echo '<hr>';

    var_dump(hash_hmac('sha1', $result, 'secret'));
    var_dump(crypt($result, 'salt'));

    var_dump(password_hash($result, PASSWORD_DEFAULT));

    echo '<hr>';

    //в итоге берем
    var_dump(hash('sha256', $filename . time()));
}
---------------------------------------------------------------------------------------------------

DateTime

Установка даты
$date = new DateTime();
$date = new DateTime('2000-01-01');

Установка даты, с часовым поясом
$date = new DateTime('2000-01-01', new DateTimeZone('Europa/Moscow'));

Установка часового пояса
$date->setTimezone(new DateTimeZone('Europa/Moscow'));

Установка даты на 4 дня вперед
$date = new DateTime('+4 days');

Изменение даты
$date->modify('+4 day');
$date->modify('+1 month');

Установка даты
$date->setDate(2001, 2, 3);

Вывод форматированной даты
$date->format('d.m.Y H:i:s');

Вывод timestamp
$date->getTimestamp();

Установка времени
$date->setTime(13, 45);

Установка timestamp
$date->setTimestamp(1385665999);

Сравнение дат
$difference = $date1->diff($date2);
---------------------------------------------------------------------------------------------------

Сортировка дат по годам

$years = range(2012, 2025);
$case = array('10 September 2012', '10 September 2014', '10 September 2016', '11 September 2016');

foreach ($years as $v1) {
 echo $v1;
 foreach ($case as $v2) {
  if ($v1 == date('Y', strtotime($v2))) {
    echo '';
    echo $v2;
    echo '';
  }
 }
}
---------------------------------------------------------------------------------------------------

Трейты
Добавляют классу новое поведение. Можно использовать несколько трейтов в одном классе.

trait T1 {
 public function n1() {
  echo 'T1';
  $this->v = 1;
  echo $this->v;
 }
}

trait T2 {
 public function n2() {
  echo 'T2';
  $this->v = 2;
  echo $this->v;
 }
}


class N {

 use T1, T2; //подключение трейтов
 public $v = 3;

 public function nn() {
  echo 'N';
  echo $this->v;
 }
}

$a = new N;
$a->nn(); // N3
$a->n1(); // T11
$a->n2(); // T22
---------------------------------------------------------------------------------------------------

Пространства имен

index1.php
namespace A1;
class N {
 public function n() {
  echo __CLASS__ . ' : ' . __NAMESPACE__;
 }
}
echo __FILE__ . ' : ' . __NAMESPACE__;

index2.php
namespace A2;
class N {
 public function n() {
  echo __CLASS__ . ' : ' . __NAMESPACE__;
 }
}
echo __FILE__ . ' : ' . __NAMESPACE__;


index3.php
namespace A3;
include_once 'index1.php';
include_once 'index2.php';

$a1 = new \A1\N;
$a1->n();

$a2 = new \A2\N;
$a2->n();

echo __FILE__ . ' : ' . __NAMESPACE__ . '';

Элементы из одного пространства имён могут быть импортированы в другое, и использоваться в нём непосредственно.

use A1\N;
$a3 = new N;
$a3->n();

Вывод:
C:\YD\domains\test.loc\index1.php : A1
C:\YD\domains\test.loc\index2.php : A2
A1\N : A1
A2\N : A2
C:\YD\domains\test.loc\index3.php : A3
A1\N : A1
---------------------------------------------------------------------------------------------------

PDO

Если в запрос не передаются переменные, то юзать query().
Если в запрос передаются переменные, то юзать prepare().

exec() - для операций, которые возвращают только колво затронутых записей.
quote() - ставит кавычки в строковых данных, чтобы юзать в запросах без prepare.

fetch() - получить строку
fetchAll() - получить массив строк
fetchAll(PDO::FETCH_COLUMN) - получить одну колонку
fetchAll(PDO::FETCH_KEY_PAIR) - получить пары ключ-значение
fetchColumn() - получить одну колонку
$db->lastInsertId() - последний вставленный ид

Всегда юзать bindValue(), потому что поведение bindParam() не очевидно.


Валидация
$stm->bindValue(2, $per_page, PDO::PARAM_INT);

Транзакции 
$stmt = $db->prepare('INSERT INTO `table`(`title`, `id`) VALUES (:title, :id)');
try {
  $db->beginTransaction();
  foreach ($videos as $v) {
    $stmt->bindValue(':title', $title);
    $stmt->bindValue(':id', $id);
    $stmt->execute();
  }
  $db->commit();
} catch (PDOException $e) {
  $db->rollBack();
}
---------------------------------------------------------------------------------------------------

Исключения (Exception)

function name($v) {
 if ($v < 0) {
  throw new Exception("мессага", 123);
 }
}

try {

 name(-100);

// при срабатывании тут код не выполняется

} catch (Exception $e) {

// при срабатывании тут код выполняется

 echo 'Код' . $e->getCode();
 echo 'Сообщение' . $e->getMessage();
 echo 'Файл' . $e->getFile();
 echo 'Строка' . $e->getLine();

}
---------------------------------------------------------------------------------------------------

Процессы и потоки
У каждого процесса свое адресное пространство (переменные и функции). Один процесс не может влезть к другому в переменные и память.
У каждого потока общее адресное пространство их родительского процесса и общие переменные.

Многопоточность на файлах
1. разлок всех неразлоченных строк, вследствие ошибок и падений, которым больше N минут (установка поля лока в NULL)
2. блокировка лок-файла
3. забор незалоченой строки
4. лок этой строки в бд (установка поля лока в NOW())
5. разблокировка лок-файла
6. запись постданных в бд
7. разлок этой строки в бд (установка поля лока в NULL)
---------------------------------------------------------------------------------------------------

1. Файлы по 32к в папке

$filename = 100000; // имя файла

$folder = ''; // папка с которой работаем

$generate_folder = intval(floor($id / 32000)); // папка генерируется взависимости от имени файла

$fullpath = $folder . '/' . $generate_folder;


// ЗАПИСЬ ФАЙЛА В ПАПКУ
if (!file_exists($fullpath)) {
 mkdir($fullpath, 0777); // создаем папку
}
file_put_contents($fullpath . '/' . $filename, $filestring);


// ЧТЕНИЕ ФАЙЛА ИЗ ПАПКИ
if (file_exists($fullpath . '/' . $filename)) {
 $filestring = file_get_contents($fullpath . '/' . $filename);
}

// УДАЛЕНИЕ ФАЙЛА ИЗ ПАПКИ
if (file_exists($fullpath . '/' . $filename)) {
 unlink($fullpath . '/' . $filename);
}


2. способ разбиения на папки (когда названия файлов в виде хеша)
for ($i = 1; $i < 1000; $i++) {

    $filename = sha1($i) . '.png';

    $dir =
        substr(
            sha1(microtime()),
            mt_rand(0, 30),
            2
        ) .
        '/' .
        substr(
            sha1(microtime()),
            mt_rand(0, 30),
            2
        );

    $path = $dir . '/' . $filename; // по этому пути сохраняем файл
    echo $path . "\n"; // 9e/78/356a192b7913b04c54574d18c28d46e6395428ab.png
}


3. Рекурсивный обход папки

function scan_folder($dir, $level = 1) {

 // если не папка
 if (!is_dir($dir)) {
  return;
 }

 // если не прочиталась папка
 $files = scandir($dir);
 if ($files == false) {
  return;
 }

 foreach ($files as $file) {

  // полный путь до файла
  $full_file = $dir . '/' . $file;

  if (is_file($full_file)) {
   $GLOBALS['result'][] = [$file => $full_file];
   continue;
  }

  if ($file == '.' OR $file == '..') {
   continue;
  }

  scan_folder($full_file, $level + 1);
  echo N;

 }
}

scan_folder(CONTENT_RAW);

foreach ($GLOBALS['result'] as $v1) {
 foreach ($v1 as $k2 => $v2) {

  //приводим к виду 11000 => /home/user/folder/content/raw/0/11000
  $result1[$k2] = $v2;
 }
}

// удаляем '.' и '..' и другие подпапки из массива
$files = scandir($dir);
foreach ($files as $k => &$v) {
 if (!is_file($dir . '/' . $v)) {
  unset ($files[$k]);
 }
}


4. Построчное чтение файла

$file = fopen('ddd', 'r');
if ($file == false) {
 exit ('файл не открылся');
}
$count = 0;
while (feof($file) == false) {
 $string = fgets($file);

 // удалим концевые "\n"
 $string = trim($string);

 // посчет числа пройденных строк в файле
 echo ++$count . N;
}
fclose($file);


5. Вывод массива по N элементов в строке
$a = range(1, 25);
$i = 1;
foreach ($a as $v) {
 $bn = '';
 if (fmod($i, 5) == 0) {
  $bn = '';
 }
 $str[] = $v . $bn;
 $i++;
}
echo implode('', $str);

6. Вывод массива по N элементов в столбце

$a = range(1, 25);
$per_column = ceil(count($a) / 3); // кол-во элементов в колонке. 3 колонки
$objs_columns = array_chunk($a, $per_column); // разбиваем на подмассивы

echo '<div>';
 foreach ($objs_columns as $v1) {
 echo '<ul>';
  foreach ($v1 as $v2) {
  echo '<li>' . $v2 . '</li>';
  }
  echo '</ul>';
 }
 echo '</div>';
---------------------------------------------------------------------------------------------------

Парсинг XML

$xml = simplexml_load_string($string);
$videos = [];

foreach ($xml->video as $video) {
 $video->id;
 $video->category;
 foreach ($video->images->url as $url) {
  $images_params[$id][] = [
   'url' => $url,
  ];
 }
}
---------------------------------------------------------------------------------------------------

























