Методы PHP

preg_match("~~isu", $subj, $match) == 1
preg_match_all("~~isu", $subj, $match);
preg_replace("~()~isu", $repl.'${1}', $subj);
---------------------------------------------------------------------------------------------------

Экранировать эти символы для PHP, слешем один раз.
\^$.[]|()*+?{},-!=<>:
и символ ~, который обрамляет выражение
пример:
$word=addcslashes($word,'~\^$.[]|()*+?{},-!=<>:');

Экранировать эти символы для Mysql, слешем. И потом эти слеши еще раз.
\^$.[]|()*+?{},-!=<>:
и кавычка " которая обрамляет выражение.
пример:
$word=addcslashes($word,'\^$.[]|()*+?{},-!=<>:');
$word=addcslashes($word,'\\');
$word=addcslashes($word,'"');

Все "плохие" символы клавиатуры:
'~!,№.@#$%^&*()_+=-`?><;|:\/"
---------------------------------------------------------------------------------------------------

Метасимволы

Работают везде, кроме символьных классов (скобки []):

\ - экранирующий символ служебных символов
^ - начало данных
$ - конец данных
. - любой печатный или непечатный символ. С флагом -s соответствует и переводу строки (\n)
[] - начало и конец символьного класса (скобки [] внутри экранировать). [abc] равносильно a|b|c, [1-3] равносильно [1|2|3]
| - знак ИЛИ
() - начало и конец группы, к которой обращаться по номеру
* - равносильно {0,}
+ - равносильно {1,}
? - равносильно {0,1}
{} - количественный квантификатор, используется в виде {n}, {n,}, {n,m}

Работают внутри символьных классов (скобки []):

\ - экранирующий символ служебных символов
^ - исключение. Ставится только в начале
- - диапазон (включительно)
! - инвертирование. Ставится только в начале класса
---------------------------------------------------------------------------------------------------

Классы символов

\s - любой пробельный
\S - любой кроме пробельных
\d - любая цифра
\D - любой кроме цифры
\w - любой алфавитно-цифровой и _ (не работает с кириллицей)
\W - любой кроме алфавитно-цифровых и _
---------------------------------------------------------------------------------------------------

Классы расположения (не пишутся в символьных классах)

\b - граница слова (не работает с кириллицей)
\B - не граница слова
\A - начало данных
\Z - конец данных или позиция перед последним символом строки, если это символ перевода строки
\z - конец данных
---------------------------------------------------------------------------------------------------

Модификаторы

i (PCRE_CASELESS) - без учета регистра
m (PCRE_MULTILINE) - однострочная строка превращается в многострочную. И символы ^ и $ еще соответствуют началу и концу строки, для каждой строки
s (PCRE_DOTALL) - точка (.) соответствует переводу строки (\n) тоже
x (PCRE_EXTENDED) - пробельные символы (вне описания символьного класса []) игнорируются
U (PCRE_UNGREEDY) - делает нежадными жадные по-умолчанию квантификаторы. Инвертирует жадность квантификаторов. (.*?) или (.+?) будет означать жадность, а не наоборот
u (PCRE8) - шаблон рассматривается в кодировке UTF-8

Жадность
все модификаторы жадные по умолчанию. убирается жадность как (.*?) или (.+?)
---------------------------------------------------------------------------------------------------

Группы и переменные

В регулярке забираем что-то в скобках (). При подстановке это переменные вида '${1}'
$text = preg_replace("~<a href=(.*)>(.*)</a>~", '<a href="${1}">${2}<a>', $text);
---------------------------------------------------------------------------------------------------

Хорошая практика именования групп с помощью ?<name>

$address = 'Cupertino 95014';

1.
$regexp = '/(.+?)\s(.+?)/';
preg_match($regexp, $address, $matches);
отдаст $matches[1], $matches[2];

2.
$regexp = '/(?<city>.+?)\s(?<zip>.+?)/';
preg_match($regexp, $address, $matches);
отдаст $matches['city'], $matches['zip'];