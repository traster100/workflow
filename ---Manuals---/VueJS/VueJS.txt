УСТАНОВКА
https://ru.vuejs.org/v2/guide/installation.html

Подключение

Разработка
<script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script>
<script src='vue.js'></script>

Продакшен
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<script src='vue.min.js'></script>
---------------------------------------------------------------------------------------------------

ВВЕДЕНИЕ
https://ru.vuejs.org/v2/guide/index.html

Декларативная отрисовка
<div id='a1'>{{message}}</div>

var app = new Vue({
  el: '#a1',
  data: {
    message: 'Привет'
 }
})

Связывание атрибутов
<div id='app2'>
  <span v-bind:title='message'>
  Наведи курсор и смотри динамически связанное значение title
  </span>
</div>

var app2 = new Vue({
  el: '#app2',
  data: {
    message: 'Вы загрузили эту страницу: ' + new Date().toLocaleString()
 }
})

Условия
<div id='app3'>
  <span v-if='seen'>Сейчас меня видно</span>
</div>

var app3 = new Vue({
  el: '#app3',
  data: {
    seen: true
 }
})

Попробуйте ввести в консоли app3.seen = false и сообщение пропадёт

Vue дает возможность связывать данные с текстом, атрибутами, структурой DOM.

Циклы
<ol id='app4'>
  <li v-for='todo in todos'>
    {{todo.text}}
  </li>
</ol>

var app4 = new Vue({
  el: '#app4',
  data: {
    todos: [
      {text: 'Изучить JavaScript'},
      {text: 'Изучить Vue'},
      {text: 'Создать что-нибудь классное'}
    ]
 }
})

Добавление элемента в список
app4.todos.push({text: 'Profit'})

Работа с пользовательским вводом
<div id='app5'>
  <p>{{message}}</p>
  <button v-on:click='reverseMessage'>Перевернуть сообщение</button>
</div>

var app5 = new Vue({
  el: '#app5',
  data: {
    message: 'Привет, Vue.js!'
 },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
   }
 }
})

Связь формы и состояния приложения
<div id='app6'>
  <p>{{message}}</p>
  <input v-model='message'>
</div>

var app6 = new Vue({
  el: '#app6',
  data: {
    message: 'Привет, Vue!'
 }
})

Разбиение приложения на компоненты
Эта абстракция позволяет собирать большие приложения из маленьких «кусочков».
Компоненты представляют собой пригодные к повторному использованию объекты.
Любой интерфейс можно представить как дерево компонентов.
Компонент это экземпляр Vue с предустановленными опциями.
Компоненты Vue похожи на пользовательские элементы, являющиеся частью спецификации W3C Web Components.

Создать новый компонент
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{todo.text}}</li>'
})

<ol id='app7'>
  <todo-item
    v-for='item in groceryList'
    v-bind:todo='item'
    v-bind:key='item.id'>
  </todo-item>
</ol>

var app7 = new Vue({
  el: '#app7',
  data: {
    groceryList: [
      {id: 0, text: 'Овощи'},
      {id: 1, text: 'Сыр'},
      {id: 2, text: 'Что там ещё люди едят?'}
    ]
 }
})
---------------------------------------------------------------------------------------------------

ЭКЗЕМПЛЯР VUE
https://ru.vuejs.org/v2/guide/instance.html

Создание экземпляра Vue
var vm = new Vue({
  //опции
})

При создании экземпляра необходимо передать объект опций, чтобы получить желаемое поведение.
Список всех опций https://ru.vuejs.org/v2/api/#%D0%9E%D0%BF%D1%86%D0%B8%D0%B8-%E2%80%94-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5
Приложение Vue состоит из корневого экземпляра Vue, создаваемого с помощью new Vue, опционально организованного в дерево вложенных, повторно используемых компонентов.
Все компоненты Vue также являются экземплярами Vue, и поэтому принимают такой же объект опций (кроме некоторых специфичных для корневого).

Данные и методы экземпляра Vue
Когда экземпляр Vue создан, он добавляет все свойства, найденные в опции data, в систему реактивности Vue.
Поэтому представление будет «реагировать» на их изменения, обновляясь в соответствии с новыми значениями.

//Наш объект data
var data = {a: 1}

//Объект добавляется в экземпляр Vue
var vm = new Vue({
  data: data
})

//Получение свойства из экземпляра. возвращает то же значение из исходных данных
vm.a, data.a

//Изменение свойства экземпляра. влияет на оригинальные данные
vm.a = 2
data.a тоже станет 2

//и наоборот
data.a = 3
vm.a тоже станет 3

Когда значения изменяются, представление будет переотрисовано.
Но свойства в data будут реактивными, только если они существовали при создании экземпляра.
Если добавите новое свойство, например: vm.b = 'hi' то изменения в b не будут вызывать никаких обновлений.
Если вы знаете, что свойство вам понадобится позже, но изначально оно пустое или несуществующее, нужно просто установить начальное значение.

data: {
  a: 1,
  b: 0,
  //ниже остальные дефолтовые типы
  newTodoText: '',
  visitCount: 0,
  hideCompletedTodos: false,
  todos: [],
  error: null
}

Объект Object.freeze()
Он предотвращает изменение существующих свойств, что также означает невозможность отслеживать изменения системой реактивности.

<div id='app'>
  <p>{{foo}}</p>
  <button v-on:click='foo = 'baz''>Изменить</button>
</div>

var obj = {
  foo: 'bar'
}

Object.freeze(obj)

new Vue({
  el: '#app',
  data: obj
})

Кроме свойств объекта data, экземпляры Vue предоставляют ряд служебных свойств и методов экземпляра.
Их имена начинаются с префикса $, чтобы отличаться от пользовательских свойств.
Список всех служебных свойств и методов https://ru.vuejs.org/v2/api/#%D0%A1%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0

Служебные свойства и методы экземпляра
var data = {a: 1}

var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data
vm.$el === document.getElementById('example')
vm.$watch('a', function (newValue, oldValue) {
  //Этот коллбэк будет вызван, когда изменится 'vm.a'
})

Хуки жизненного цикла экземпляра
Каждый экземпляр Vue при создании, проходит через последовательность шагов:
-настраивает наблюдение за данными
-компилирует шаблон
-монтирует экземпляр в DOM
-обновляет DOM при изменении данных

Между этими шагами вызываются функции, называемые хуками жизненного цикла, с помощью которых можно выполнять свой код на определённых этапах.
Не используйте стрелочные функции в свойствах экземпляра и в коллбэках, потому что стрелочные функции связываются с родительским контекстом, и this не будет указывать на экземпляр Vue.

Список хуков
created, mounted, updated, destroyed

Пример хук created
new Vue({
  data: {
    a: 1
 },
  created: function () {
    //в хуках всегда this указывает на экземпляр vm
    console.log('Значение a: ' + this.a) //=> 'Значение a: 1'
 }
})

Диаграмма жизненного цикла
https://ru.vuejs.org/images/lifecycle.png
---------------------------------------------------------------------------------------------------

СИНТАКСИС ШАБЛОНОВ
https://ru.vuejs.org/v2/guide/syntax.html

Для связывания DOM, с данными экземпляра Vue, используется синтаксис основанный на HTML.
Для работы Vue компилирует шаблоны в render-функции виртуального DOM.

--Текст

<span>Сообщение: {{msg}}</span>
{{msg}} будет заменено значением свойства msg, соответствующего объекта данных, и будет обновлено при любом изменении этого свойства.

<span v-once>Это сообщение никогда не изменится: {{msg}}</span>
Тут выполнение интерполяции будет однократно, без обновления при изменении данных.

--Сырой HTML

Значение выражения в двойных фигурных скобках подставляется как простой текст, а не как HTML
<p>{{rawHtml}}</p>
тут html вставится как строка с тегами

Для HTML необходимо использовать директиву v-html:
<p v-html='rawHtml'></p>
Содержимое тега p будет заменено значением свойства rawHtml, интерпретированного как обычный HTML. все привязки данных игнорируются.

--Атрибуты

<div v-bind:id='dynamicId'></div>
Синтаксис {{}} не работает с HTML-атрибутами. Используйте вместо него директиву v-bind

<button v-bind:disabled='isButtonDisabled'>Кнопка</button>
Булевы аттрибуты. Если значением isButtonDisabled будет null, undefined или false, то атрибут disabled не добавится в элемент <button>

--Использование выражений JavaScript
Выражения будут вычислены как JavaScript-код в области видимости соответствующего экземпляра Vue

{{number + 1}}
{{ok ? 'YES' : 'NO'}}
{{message.split('').reverse().join('')}}
<div v-bind:id='list-' + id'></div>

Директивы
Директивы — это специальные атрибуты с префиксом v-, для элементов.
В качестве значения они принимают одно выражение JavaScript.

Аргумент директивы
<a v-bind:href='url'>ссылка</a>
<a v-on:click='doSomething'>ссылка</a>

Директивы могут принимать «аргумент», разделённый от названия директивы двоеточием.

Модификатор директивы
<form v-on:submit.prevent='onSubmit'></form>

Это особые постфиксы, добавляемые после точки, обозначающие что директива должна быть связана каким-то определённым образом.
Модификатор .prevent говорит директиве v-on вызвать event.preventDefault() при обработке произошедшего события.

Сокращения директив
Префикс v- служит для визуального определения Vue-специфичных атрибутов(директив) в шаблонах.

Сокращение v-bind

полный синтаксис
<a v-bind:href='url'>ссылка</a>

сокращение
<a :href='url'>ссылка</a>

Сокращение v-on

полный синтаксис
<a v-on:click='doSomething'>ссылка</a>

сокращение
<a @click='doSomething'>ссылка</a>
---------------------------------------------------------------------------------------------------

ВЫЧИСЛЯЕМЫЕ СВОЙСТВА И СЛЕЖЕНИЕ
https://ru.vuejs.org/v2/guide/computed.html

Вычисляемые свойства

<div id='example'>
  <p>Изначальное сообщение: {{message}}</p>
  <p>Перевернутое сообщение: {{reversedMessage}}. Это вычисляемое свойство</p>
</div>

var vm = new Vue({
  el: '#example',
  data: {
    message: 'Привет'
 },
  computed: {
    reversedMessage: function () {
      return this.message.split('').reverse().join(''); //this указывает на экземпляр vm
   }
 }
})

В шаблонах можно обращаться к вычисляемым свойствам как и к обычным.
Vue знает, что vm.reversedMessage зависит от vm.message, поэтому при обновлении vm.message обновятся и все вычисляемые свойства

Кеширование вычисляемых свойств

<div id='example'>
<p>Перевернутое сообщение: {{reverseMessage()}}</p>
</div>

var vm = new Vue({
  el: '#example',
  data: {
    message: 'Привет'
 },
  methods: {
    reverseMessage: function () {
      return this.message.split('').reverse().join('')
   }
}
})

Тут мы сделали тоже самое, что и в примере выше, только использовали метод.
С точки зрения конечного результата, оба подхода делают одно и то же.
Но есть важное отличие: вычисляемые свойства кешируются, основываясь на своих зависимостях.
Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его зависимостей.
Поэтому, пока message остаётся неизменным, многократное обращение к reversedMessage будет каждый раз возвращать из кеша, не вычисляя заново.
А использование метода будет запускать функцию всегда, при каждом обращении к нему.
Вообщем в тех случаях когда кеширования нужно избежать — используйте методы.

{
Методы вызываются как {{ name() }} в верстке или {{ name }} в директивах
Вычисляемые свойства вызываются как {{ name() }} в верстке или {{ name }} в директивах
Методы не кешируются (пересчет каждый раз). Вычисляемые свойства кешируются (только при изменении)
}

Вычисляемые свойства и слежение

Vue предоставляет и более общий способ наблюдения и реагирования на изменения данных в экземпляре: слежение за свойствами.
Когда есть данные, которые необходимо обновлять при изменении других данных, возникает соблазн избыточно использовать только этот подход.
Но, как правило, лучше использовать вычисляемые свойства, а не императивный коллбэк в watch.

Императивный коллбэк в watch (код избыточный):

<div id='demo'>{{fullName}}</div>

var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
 },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
   },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
   }
 }
})

Версия с использованием вычисляемого свойства (так лучше):

var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
 },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
   }
 }
})

Сеттеры вычисляемых свойств
По умолчанию вычисляемые свойства работают только на чтение, но можно также указать и сеттер:

computed: {
  fullName: {

    //геттер
    get: function () {
      return this.firstName + ' ' + this.lastName
   },

    //сеттер
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
   }

 }
}

Теперь запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.

Методы-наблюдатели
Хотя в большинстве случаев лучше использовать вычисляемые свойства, иногда необходимы пользовательские методы-наблюдатели.
Поэтому Vue предоставляет более общий способ реагирования на изменения в данных через watch.
Эта возможность полезна для «дорогих» или асинхронных операций, выполняемых в ответ на изменение данных.

<div id='app'>
   <p>Задайте вопрос, на который можно ответить 'да' или 'нет'</p>
   <input v-model='question'>
   {{answer}}
</div>

var vm = new Vue({
  el: '#app',
  data: {
    question: '',
    answer: 'Пока вы не зададите вопрос, я не могу ответить'
 },
  watch: {
    //эта функция запускается при любом изменении вопроса
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Ожидаю, когда вы закончите печатать'
      this.debouncedGetAnswer()
   }
 },
   created: function () {
   //_.debounce — это функция lodash, позволяющая ограничить то, насколько часто может выполняться определённая операция
   this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
    },
   methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Вопросы обычно заканчиваются вопросительным знаком'
        return
     }
      this.answer = 'Думаю...'
      var vm2 = this
      axios.get('https://yesno.wtf/api')
	  //если запрос успешен
        .then(function (response) {
          vm2.answer = _.capitalize(response.data.answer)
       })
	   //если ошибка
        .catch(function (error) {
          vm2.answer = 'Ошибка. Не могу связаться с API. ' + error
       })
   }
 }
})

В данном случае использование watch позволило выполнять асинхронную операцию (обращение к API),
ограничивать частоту выполнения этой операции,
и устанавливать промежуточные состояния до получения ответа от сервера.
Ничего из этого не удалось бы достичь с помощью вычисляемых свойств.
---------------------------------------------------------------------------------------------------

РАБОТА С КЛАССАМИ И СТИЛЯМИ
https://ru.vuejs.org/v2/guide/class-and-style.html

Чтобы динамически изменять CSS-классы и inline-стили элементов, в зависимости от состояния приложения.
Поскольку и то и другое это атрибуты, мы можем использовать v-bind.
Vue предоставляет дополнительные возможности директивы v-bind: class, style.

Связывание CSS-классов

--Использование объектов

<div v-bind:class='{active: isActive}'></div>
наличие класса active будет определяться истинностью параметра isActive

<div v-bind:class='{active: isActive, 'text-danger': hasError}'></div>
можно управлять несколькими классами, добавляя в объект другие поля.

data: {
  isActive: true,
  hasError: false
}

<div class='static' v-bind:class='{active: isActive}'></div>
v-bind:class можно использовать совместно с обычным атрибутом class

Используемый объект можно указывать прямо в шаблоне
<div v-bind:class='classObject'></div>

data: {
  classObject: {
    active: true,
    'text-danger': false
 }
}

Можно также использовать вычисляемые свойства, которые возвращают объект
<div v-bind:class='classObject'></div>

data: {
  isActive: true,
  error: null
},

computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
   }
 }
}

--Использование массивов

<div v-bind:class='[activeClass, errorClass]'></div>

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

Для переключения классов в массиве, в зависимости от условия, можно использовать тернарный оператор:
<div v-bind:class='[isActive ? activeClass : '', errorClass]'></div>
или
<div v-bind:class='[{active: isActive}, errorClass]'></div>
errorClass будет применён к элементу всегда, а activeClass только в случае истинности isActive

--Использование с компонентами

Vue.component('my-component', {
  template: '<p class='foo bar'>Привет</p>'
})

Если указать дополнительные классы на компоненте:
<my-component class='baz boo'></my-component>

В результате отрисовки получим:
<p class='foo bar baz boo'>Привет</p>

То же самое справедливо для связывания классов с данными:
<my-component v-bind:class='{active: isActive}'></my-component>

Если isActive истинно, результирующий HTML будет:
<p class='foo bar active'>Привет</p>

Связывание inline-стилей

--Использование объектов

<div v-bind:style='{color: activeColor, fontSize: fontSize + 'px'}'></div>

data: {
  activeColor: 'red',
  fontSize: 30
}

Можно выносить объект стилей из шаблона

<div v-bind:style='styleObject'></div>

data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
 }
}

Можно использовать и вычисляемые свойства, возвращающие объекты стилей.

--Использование массивов
<div v-bind:style='[baseStyles, overridingStyles]'></div>
позволяет применить несколько объектов стилей к одному элементу

--Автоматические префиксы
Vue автоматически добавит вендорные префиксы к применяемым стилям.

--Множественные значения
можно предоставить массив из нескольких (префиксных) значений для свойства style.
Это приведёт к отображению последнего значения в массиве, поддерживаемого браузером.
<div v-bind:style='{display: ['-webkit-box', '-ms-flexbox', 'flex']}'></div>
---------------------------------------------------------------------------------------------------

УСЛОВНАЯ ОТРИСОВКА
https://ru.vuejs.org/v2/guide/conditional.html

Директива v-if
<h1 v-if='ok'>Да</h1>

Условные группы
Чтобы управлять отображением сразу нескольких элементов, нужно применить обертку <template>

<template v-if='ok'>
  <h1>Заголовок</h1>
  <p>Абзац 1</p>
  <p>Абзац 2</p>
</template>

Директива v-else
<div v-if='Math.random() > 0.5'>
  Сейчас меня видно
</div>
<div v-else>
  А теперь — нет
</div>
Элемент с директивой v-else должен следовать сразу за элементом с директивой v-if или v-else-if, иначе он не будет распознан.

Директива v-else-if
<div v-if='type === A'>A</div>
<div v-else-if='type === B'>B</div>
<div v-else-if='type === C'>C</div>
<div v-else>Не A/B/C</div>
Элемент с директивой v-else-if должен следовать сразу за элементом с v-if или v-else-if.

Управление повторным использованием элементов при помощи key

<template v-if='loginType === 'username''>
  <label>Имя</label>
  <input placeholder='Имя'>
</template>

<template v-else>
  <label>Почта</label>
  <input placeholder='Почта'>
</template>

Vue старается управлять элементами DOM настолько эффективно, насколько это возможно, зачастую переиспользуя их вместо того чтобы создавать заново.
Например, если вы позволяете пользователю переключаться между несколькими возможными типами логина.
Изменение loginType в коде выше не сотрёт то, что пользователь ввёл в поле.
Оба шаблона используют одни и те же элементы, поэтому input не заменяется, а только его placeholder.
Иногда такое поведение нежелательно, поэтому Vue можно явно указать «эти элементы должны быть полностью независимы, не надо их переиспользовать».
Для этого нужно указать уникальное значение ключа key.
Теперь эти поля ввода будут отрисовываться заново при каждом переключении.

<template v-if='loginType === 'username''>
  <label>Имя</label>
  <input placeholder='Имя' key='username-input'>
</template>

<template v-else>
  <label>Почта</label>
  <input placeholder='Почта' key='email-input'>
</template>

Но элементы <label> всё ещё эффективно переиспользуются, поскольку для них key не указаны.

Директива v-show
<h1 v-show='ok'>Привет!</h1>

v-show похожа на v-if.
Разница в том, что элемент с v-show будет всегда оставаться в DOM, а изменяться будет лишь свойство display в его параметрах CSS.
Также v-show не работает на элементе <template> и не работает с v-else.

v-if в сравнении с v-show.

v-if производит «настоящую» условную отрисовку, удостоверяясь что подписчики событий и дочерние компоненты внутри блока должным образом уничтожаются и воссоздаются при изменении истинности управляющего условия.
v-if ленивый: если условие ложно на момент первоначальной отрисовки, — условный блок не будет отрисован, пока условие не станет истинным.
v-show, напротив, куда проще: элемент всегда присутствует в DOM, и только CSS-свойство переключается в зависимости от условия.

В целом, у v-if выше затраты на переключения, а у v-show больше затрат на первичную отрисовку.
Если вы предполагаете, что переключения будут частыми, используйте v-show, если же редкими или маловероятными — v-if.

v-if вместе с v-for
Совместное использование v-if и v-for не рекомендуется.

v-else работает с v-if и v-show.
---------------------------------------------------------------------------------------------------

ОТРИСОВКА СПИСКОВ
https://ru.vuejs.org/v2/guide/list.html

Отображение массива элементов с помощью v-for

<ul id='example1'>
  <li v-for='item in items'>
    {{item.message}}
  </li>
</ul>

var example1 = new Vue({
  el: '#example1',
  data: {
    items: [
      {message: 'Foo'},
      {message: 'Bar'}
    ]
 }
})

Внутри блока v-for нам доступны свойства из области видимости родителя.
У v-for также есть второй опциональный параметр, с индексом текущего элемента.

<ul id='example2'>
  <li v-for='(item, index) in items'>
    {{parentMessage}}
    {{index}}
    {{item.message}}
  </li>
</ul>

var example2 = new Vue({
  el: '#example2',
  data: {
    parentMessage: 'Родитель',
    items: [
      {message: 'Foo'},
      {message: 'Bar'}
    ]
 }
})

Синтаксис можно писать так
<li v-for='item in items'>
или так
<li v-for='item of items'>

v-for по свойствам объекта

<ul id='app'>
  <li v-for='value in object'>
    {{value}}
  </li>
</ul>

new Vue({
  el: '#app',
  data: {
    object: {
      firstName: 'Иван',
      lastName: 'Петров',
      age: 30
   }
 }
})

Можно использовать второй аргумент для получения ключей объекта, и третий для индексов

<div v-for='(value, key, index) in object'>
  {{value}}
  {{key}}
  {{index}}
</div>

Порядок обновления списка элементов
При обновлении Vue списка элементов, отображаемого директивой v-for, по умолчанию используется стратегия обновления «на месте».
Если порядок элементов массива или объекта изменился, Vue не станет перемещать элементы DOM, а просто обновит каждый элемент «на месте», чтобы он отображал новые данные по соответствующему индексу.
Этот режим по-умолчанию эффективен, но применим только в случаях, когда результат отрисовки вашего списка не полагается на состояние дочерних компонентов или временные состояния DOM.
Чтобы подсказать Vue, как отслеживать идентичность каждого элемента, что позволит переиспользовать и перемещать существующие элементы, укажите уникальный атрибут key для каждого элемента.
Идеальным значением key будет уникальный id сущности.
Поэтому нужно использовать v-bind для связывания с динамическими значениями (в примере ниже используется сокращение).
Рекомендуем всегда указывать key с v-for, кроме случаев когда итерируемый контент DOM прост, или вы сознательно используете стратегию обновления по умолчанию для улучшения производительности.

<div v-for='item in items' :key='item.id'>
  <!--содержимое-->
</div>

Отслеживание изменений в массивах

--Методы внесения изменений
Методы внесения изменений, изменяют оригинальный массив, на котором они вызываются.
push()
pop()
shift()
unshift()
splice()
sort()
reverse()

--Замены в массиве
Существуют и неизменяющие методы, такие как filter(), concat() и slice(), они не вносят изменений в изначальный массив, а всегда возвращают новый массив.
При работе с неизменяющими методами можно просто заменять старый массив на новый:

example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})

Vue придётся выбросить существующий DOM, и заново отрисовать список целиком.
В Vue умные эвристики для максимизации переиспользования элементов DOM.
Замена одного массива другим, в случае совпадения части элементов этих массивов, будет очень эффективной операцией.

--Предостережения
Из-за ограничений JavaScript, Vue не способен отследить следующие изменения в массиве:

1. Прямую установку элемента по индексу:
vm.items[indexOfItem] = newValue;

2. Явное изменение длины массива:
vm.items.length = newLength;

Решение проблемы 1:
//Использовать Vue.set
Vue.set(vm.items, indexOfItem, newValue);
vm.$set(vm.items, indexOfItem, newValue); //vm.$set, является псевдонимом для глобального Vue.set
//Использовать Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue);

Решение проблемы 2:
vm.items.splice(newLength);

--Предостережения об изменениях объектов
Из-за ограничений JavaScript, Vue не может обнаружить добавление или удаление свойств.

var vm = new Vue({
  data: {
    a: 1
 }
})
//свойство vm.a реактивно

vm.b = 2 //свойство vm.b НЕ реактивно

Vue не позволяет динамически добавлять новые реактивные свойства на корневом уровне уже созданного экземпляра.
Но можно добавить реактивные свойства к вложенному объекту с помощью метода Vue.set(object, key, value)

var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
   }
 }
})

Vue.set(vm.userProfile, 'age', 27)
или
vm.$set(vm.userProfile, 'age', 27)

Добавить ряд новых свойств существующему объекту, например, используя Object.assign() или _.extend():

vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})

Отображение отфильтрованных/отсортированных результатов
Иногда хочется отобразить отфильтрованную/отсортированную версию массива, не изменяя оригинальные данные.
В таком случае создайте вычисляемое свойство, возвращающее отфильтрованный или отсортированный массив.

<li v-for='n in evenNumbers'>{{n}}</li>

data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
   })
 }
}

В ситуациях, когда вычисляемые свойства невозможно использовать (например, внутри вложенных циклов v-for):

<li v-for='n in even(numbers)'>{{n}}</li>

data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
   })
 }
}

v-for и диапазоны
В v-for можно передать целое число. В этом случае шаблон будет повторён указанное число раз.

<span v-for='n in 10'>{{n}}</span>

v-for и тег template
Подобно использованию с v-if, также можно использовать тег <template> с директивой v-for для отображения блока из нескольких элементов.

<template v-for='item in items'>
  <li>{{item.msg}}</li>
  <p></p>
</template>

v-for и v-if
Когда присутствуют вместе v-for и v-if на одном элементе, v-for имеет больший приоритет, чем v-if.
Поэтому v-if будет выполняться для каждой итерации цикла. Это полезно, когда нужно отобразить только некоторые элементы списка.

<li v-for='todo in todos' v-if='!todo.isComplete'>
  {{todo}}
</li>

Если необходимо по условию пропускать выполнение всего цикла, переместите v-if на внешний элемент (или на <template>)

<ul v-if='shouldRenderTodos'>
  <li v-for='todo in todos'>
    {{todo}}
  </li>
</ul>

--Компоненты и v-for
Можно использовать v-for на компонентах, как и на обычных элементах (key обязателен):
<my-component v-for='item in items' :key='item.id'></my-component>

Однако, в компонент никакие данные не передаются автоматически, поскольку у компонентов изолированные области видимости.
Для передачи итерируемых данных в компонент, необходимо явно использовать входные параметры.

<my-component
  v-for='(item, index) in items'
  v-bind:item='item'
  v-bind:index='index'
  v-bind:key='item.id'
></my-component>

Причина, почему item не передаётся в компонент автоматически в том, что это сделает компонент жёстко связанным с логикой работы v-for
---------------------------------------------------------------------------------------------------

ОБРАБОТКА СОБЫТИЙ
https://ru.vuejs.org/v2/guide/events.html

Подписка на события

<div id='example1'>
  <button v-on:click='counter += 1'>+1</button>
  <p>Кнопка нажата {{counter}} раз</p>
</div>

var example1 = new Vue({
  el: '#example1',
  data: {
    counter: 0
 }
})

Обработчики событий
v-on может принять и название метода, который необходимо вызвать, и уже в нем написать обработчик события.

<div id='example2'>
  <button v-on:click='greet'>Поприветствовать</button>
</div>

var example2 = new Vue({
  el: '#example2',
  data: {
    name: 'Vue.js'
 },

  //определяйте методы в объекте 'methods'
  methods: {
    greet: function (event) {
      //this внутри методов указывает на экземпляр Vue
      alert('Привет, ' + this.name + '!')

      //event — нативное событие DOM
      if (event) {
        alert(event.target.tagName)
     }
   }
 }
})
example2.greet() //=> 'Привет, Vue.js!'

Методы и inline-обработчики
Кроме указания имени метода, можно использовать и JavaScript-выражения

<div id='example3'>
  <button v-on:click='say('hi')'>Скажи hi</button>
  <button v-on:click='say('what')'>Скажи what</button>
</div>

new Vue({
  el: '#example3',
  methods: {
    say: function (message) {
      alert(message)
   }
 }
})

Иногда в inline-обработчиках необходим доступ к оригинальному событию DOM.
Его можно передать в метод, используя специальную переменную $event

<button v-on:click='warn('Форма не может быть отправлена.', $event)'>
  Отправить
</button>

methods: {
  warn: function (message, event) {
    //теперь у нас есть доступ к нативному событию
    if (event) event.preventDefault()
    alert(message)
 }
}

Модификаторы событий для v-on
.stop
.prevent
.capture
.self
.once
.passive

событие click не будет всплывать дальше
<a v-on:click.stop='doThis'></a>

событие submit больше не будет перезагружать страницу
<form v-on:submit.prevent='onSubmit'></form>

модификаторы можно объединять в цепочки
<a v-on:click.stop.prevent='doThat'></a>

можно использовать без указания метода-обработчика
<form v-on:submit.prevent></form>

можно отслеживать события в режиме capture, т.е. событие, нацеленное на внутренний элемент, обрабатывается здесь до обработки этим элементом
<div v-on:click.capture='doThis'></div>

вызов обработчика только в случае наступления события непосредственно на данном элементе (то есть не на дочернем компоненте)
<div v-on:click.self='doThat'></div>

Событие click сработает только 1 раз
<a v-on:click.once='doThis'></a>

При использовании модификаторов порядок имеет значение, потому что код генерируется в том же порядке.

Модификаторы клавиш для v-on
.enter
.tab
.delete (ловит как «Delete», так и «Backspace»)
.esc
.space
.up
.down
.left
.right

вызвать 'vm.submit()' только если 'keyCode' равен 13. или через псевдоним
<input v-on:keyup.13='submit'>
<input v-on:keyup.enter='submit'>

работает также и в сокращённой записи
<input @keyup.enter='submit'>

Можно определить пользовательские псевдонимы клавиш через глобальную опцию config.keyCodes:

//позволит использовать 'v-on:keyup.f1'
Vue.config.keyCodes.f1 = 112

Автоматические модификаторы клавиш
Можно использовать любые допустимые имена клавиш, предоставляемые через KeyboardEvent.key в качестве модификаторов, именуя их в kebab-case:

<input @keyup.page-down='onPageDown'>
Тогда обработчик будет вызван только в случае, если $event.key === 'PageDown'.

Системные модификаторы клавиш
.ctrl
.alt
.shift
.meta
модификаторы для отслеживания событий мыши или клавиатуры с зажатой клавишей-модификатором. клавиши-модификаторы отличаются от обычных клавиш и при отслеживании событий keyup они должны быть нажаты, когда событие генерируется. Другими словами, keyup.ctrl сработает только тогда, когда вы отпустите клавишу, удерживая нажатой ctrl. Это не сработает, если вы отпустите только клавишу ctrl. Если вы хотите такое поведение, используйте keyCode для ctrl вместо keyup.17.

Alt+C
<input @keyup.alt.67='clear'>

Ctrl + Click
<div @click.ctrl='doSomething'>Сделать что-нибудь</div>

--Модификатор .exact

Обычный вариант, сработает даже если Alt или Shift ТОЖЕ нажаты, а не только Ctrl
<button @click.ctrl='onClick'>A</button>

сработает, когда нажат ТОЛЬКО Ctrl, и не нажаты никакие другие клавиши
<button @click.ctrl.exact='onCtrlClick'>A</button>

сработает, когда нажат ТОЛЬКО клик, и не нажаты никакие другие клавиши
<button @click.exact='onClick'>A</button>

--Модификаторы клавиш мыши
.left
.right
.middle
---------------------------------------------------------------------------------------------------

РАБОТА С ФОРМАМИ
https://ru.vuejs.org/v2/guide/forms.html

--Текст
<input v-model='message'>
<p>{{message}}</p>

--Многострочный текст
<textarea v-model='message'></textarea>
<p>{{message}}</p>

--Чекбокс
<input type='checkbox' v-model='checked'>
<label>{{checked}}</label>

--Список чекбоксов, привязанных к одному массиву:
<div id='example3'>

  <input type='checkbox' value='Джек' v-model='checkedNames'>
  <label>Джек</label>

  <input type='checkbox' value='Джон' v-model='checkedNames'>
  <label>Джон</label>

  <input type='checkbox' value='Майк' v-model='checkedNames'>
  <label>Майк</label>

  <span>Отмеченные имена: {{checkedNames}}</span>
</div>

new Vue({
  el: '#example3',
  data: {
    checkedNames: []
 }
})

--Радиокнопки
<input type='radio' value='Один' v-model='picked'>
<label>Один</label>

<input type='radio' value='Два' v-model='picked'>
<label>Два</label>

<span>Выбрано: {{picked}}</span>

--Выпадающие списки

Выбор одного варианта из списка:
<select v-model='selected'>
//рекомендуется предоставлять отключённый вариант выбора с пустым значением value
<option disabled value=''>Выберите</option>

  <option>А</option>
  <option>Б</option>
  <option>В</option>
</select>
<span>Выбрано: {{selected}}</span>

new Vue({
  el: '...',
  data: {
    selected: ''
 }
})

Выбор нескольких вариантов из списка:
<select v-model='selected' multiple>
  <option>А</option>
  <option>Б</option>
  <option>В</option>
</select>
<span>Выбрано: {{selected}}</span>

Динамическое отображение списка опций с помощью v-for:
<select v-model='selected'>
  <option v-for='option in options' v-bind:value='option.value'>
    {{option.text}}
  </option>
</select>
<span>Выбрано: {{selected}}</span>

new Vue({
  el: '...',
  data: {
    selected: 'А',
    options: [
      {text: 'Один', value: 'А'},
      {text: 'Два', value: 'Б'},
      {text: 'Три', value: 'В'}
    ]
 }
})

Связывание значений
'picked' получает строковое значение 'a' при клике
<input type='radio' v-model='picked' value='a'>

'toggle' может иметь значение true или false
<input type='checkbox' v-model='toggle'>

'selected' при выборе первого пункта становится равным строке 'abc'
<select v-model='selected'>
  <option value='abc'>ABC</option>
</select>

Для радиокнопок, чекбоксов и выпадающих списков, в качестве v-model обычно используются строки, для чекбоксов булевые значения.
Иногда необходимо связать значение с динамическим свойством экземпляра Vue.
Для этого можно использовать v-bind.
Кроме того, использование v-bind позволяет связывать поле ввода с нестроковыми значениями.

--Чекбокс
<input
  type='checkbox'
  v-model='toggle'
  true-value='да'
  false-value='нет'>

//если чекбокс выбран:
vm.toggle === 'да'
//если чекбокс сброшен:
vm.toggle === 'нет'

--Радиокнопки
<input type='radio' v-model='pick' v-bind:value='a'>

//если отмечено:
vm.pick === vm.a

--Списки выбора
<select v-model='selected'>
  <option v-bind:value='{number: 123}'>123</option>
</select>

//когда выбрано:
typeof vm.selected //=> 'object'
vm.selected.number //=> 123

Модификаторы

--.lazy
По умолчанию v-model синхронизирует ввод с данными по событию input.
Можно указать модификатор lazy, чтобы использовать для синхронизации событие change:

синхронизируется по событию 'change', а не 'input'
<input v-model.lazy='msg'>

--.number
Для автоматического приведения введённого пользователем к числу, добавьте модификатор number.
Зачастую это полезно, потому что даже при указанном атрибуте type='number' значением поля ввода всегда будет строка.

<input v-model.number='age' type='number'>

--.trim
Чтобы автоматически обрезать пробелы в начале и в конце введённой строки

<input v-model.trim='msg'>

Использование v-model с компонентами
Встроенных в HTML элементов ввода не всегда достаточно.
Компоненты Vue позволяют создавать собственные аналоги с полностью настраиваемым поведением.
Эти элементы тоже могут работать с директивой v-model.
---------------------------------------------------------------------------------------------------

ОСНОВЫ КОМПОНЕНТОВ
https://ru.vuejs.org/v2/guide/components.html

Компоненты — это переиспользуемые отдельные экземпляры Vue со своим именем.
Их можно подключать как пользовательские теги внутри корневого экземпляра Vue.
Компоненты принимают теже опции, что и корневой new Vue, такие как data, computed, watch, methods, хуки жизненного цикла.
Компоненты можно подключать сколько угодно раз.
Чтобы использовать компоненты в шаблонах, они должны быть зарегистрированы, чтобы Vue узнал о них.
Есть два типа регистрации компонентов: глобальная(Vue.component) и локальная.
Компоненты зарегистрированные глобально, могут использоваться в шаблоне любого корневого экземпляра Vue (new Vue) созданного впоследствии, и даже внутри всех компонентов, расположенных в дереве компонентов этого экземпляра Vue.

Создадим компонент
Vue.component('button-counter', {
  //свойство data должно быть функцией
  data: function () {
    return {
      count: 0
   }
 },
  template: '<button v-on:click='count++'>Кол-во кликов {{count}}</button>'
})

new Vue({el: '#components-demo'})

<div id='components-demo'>
  <button-counter></button-counter>
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>

Передача данных в дочерние компоненты
Входные параметры — это пользовательские атрибуты, которые вы можете установить на компоненте.
Когда значение передаётся в атрибут входного параметра, оно становится свойством экземпляра компонента.
Чтобы передать заголовок в компонент нашей записи блога, мы можем включить его в список входных параметров, которые принимает компонент, с помощью опции props.
Компонент может принимать столько входных параметров, сколько захотите.
Мы можем получить доступ к этому значению в экземпляре компонента, как и к любому свойству data.

Создадим компонент 'запись блога', и передадим заголовок title
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{title}}</h3>'
})

<blog-post title='Запись 1'></blog-post>
<blog-post title='Запись 2'></blog-post>
<blog-post title='Запись 3'></blog-post>

Компонент должен иметь 1 корневой элемент. обертку
так нельзя:
<h3>{{title}}</h3>
<div v-html='content'></div>

так можно:
<div class='blog-post'>
  <h3>{{title}}</h3>
  <div v-html='content'></div>
</div>

В типичном приложении у вас будет массив записей в data.
Можно использовать v-bind для динамической передачи данных во входные параметры.

new Vue({
  el: '#blog',
  data: {
    posts: [
      {id: 1, title: 'Запись 1'},
      {id: 2, title: 'Запись 2'},
      {id: 3, title: 'Запись 3'}
    ]
 }
})

<blog-post
  v-for='post in posts'
  v-bind:key='post.id'
  v-bind:title='post.title'
></blog-post>

Но компонент может расти, добавляются комментарии, дата итд
<blog-post
  v-for='post in posts'
  v-bind:key='post.id'
  v-bind:title='post.title'
  
  v-bind:content='post.content'
  v-bind:publishedAt='post.publishedAt'
  v-bind:comments='post.comments'
></blog-post>

Рефакторим.
вместо длинного списка входных параметров, передадим post
<blog-post
  v-for='post in posts'
  v-bind:key='post.id'

  v-bind:post='post'
></blog-post>

Vue.component('blog-post', {
  props: ['post'],
  template: '
    <div class='blog-post'>
      <h3>{{post.title}}</h3>
      <div v-html='post.content'></div>
    </div>
})

Многострочные шаблонные строки JavaScript работают в IE с таким хаком
https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript

Отправка сообщений родителям с помощью событий
Передадим от дочернего к родителю, размер шрифта postFontSize.
Чтобы передать событие от потомка-компонента к родительскому компоненту, можем вызвать встроенный метод $emit, передав имя события bigenlarge.

new Vue({
  el: '#blog',
  data: {
    postFontSize: 1
 }
})

<div id='blog' :style='{fontSize: postFontSize + 'em'}'>
  <blog-post
    v-on:bigenlarge='postFontSize += 0.1'
    v-for='post in posts'
    v-bind:key='post.id'
    v-bind:post='post'
  ></blog-post>
</div>

Vue.component('blog-post', {
  props: ['post'],
  template: '
    <div class='blog-post'>
      <h3>{{post.title}}</h3>
      <div v-html='post.content'></div>
      <button v-on:click='$emit('bigenlarge')'>Увеличить размер текста</button>
    </div>
})

Передача данных вместе с событием
Иногда бывает полезно отправить определённые данные вместе с событием. Можем использовать второй параметр $emit для предоставления этого значения.
<button v-on:click='$emit('bigenlarge', 0.1)'>Увеличить размер текста</button>

Когда мы прослушиваем событие в родителе, мы можем получить доступ к данным, переданным с событием, через $event:
<blog-post v-on:bigenlarge='postFontSize += $event'></blog-post>

Или, если обработчик события будет методом:
<blog-post v-on:bigenlarge='onEnlargeText'></blog-post>

Тогда значение будет передано первым аргументом:
methods: {
  onEnlargeText: function (enlargeAmount) {
    this.postFontSize += enlargeAmount
 }
}

Использование v-model на компонентах
Пользовательские события также могут использоваться для создания нестандартных элементов ввода, которые работают через v-model.

<input v-model='searchText'>

Делает то же самое, что и:
<input
  v-bind:value='searchText'
  v-on:input='searchText = $event.target.value'
>

При использовании на компоненте, v-model вместо этого, делает следующее:
<custom-input
  v-bind:value='searchText'
  v-on:input='searchText = $event'
></custom-input>

Vue.component('custom-input', {
  props: ['value'],
  template: '
    <input
      v-bind:value='value'
      v-on:input='$emit('input', $event.target.value)'
    >
})

Теперь v-model будет прекрасно работать с этим компонентом:
<custom-input v-model='searchText'></custom-input>

Распределение контента слотами
Как и с обычными HTML-элементами, часто бывает полезным передать компоненту содержимое, например:
<alert-box>
  окей
</alert-box>

Vue.component('alert-box', {
  template: '
    <div class='demo-alert-box'>
      <strong>Ошибка!</strong>
      <slot></slot>
    </div>
})

Особенности парсинга DOM-шаблона
Некоторые HTML-элементы, такие как <ul>, <ol>, <table> и <select> имеют ограничения на то, какие элементы могут отображаться внутри них.
Или например элементы, такие как <li>, <tr> и <option> могут появляться только внутри других определённых элементов.
Это приведёт к проблемам при использовании компонентов с элементами, которые имеют такие ограничения. Например:

<table>
  <blog-post-row></blog-post-row>
</table>

Пользовательский компонент <blog-post-row> будет поднят выше, так как считается недопустимым содержимым, вызывая ошибки в итоговой отрисовке. Специальный атрибут is предоставляет решение этой проблемы:

<table>
  <tr is='blog-post-row'></tr>
</table>

Такого ограничения нет для шаблонов из источников:
Строковые шаблоны (template: '...')
Однофайловые (.vue) компоненты
<script type='text/x-template'>
---------------------------------------------------------------------------------------------------

РЕГИСТРАЦИЯ КОМПОНЕНТОВ
https://ru.vuejs.org/v2/guide/components-registration.html

Именование компонентов
Все символы в нижнем регистре, должен содержать дефис.
Только имена в kebab-case являются валидными при использовании непосредственно в DOM (т.е. не строковые шаблоны).

В стиле kebab-case
Vue.component('my-component-name', {})
<my-component-name></my-component-name>

В стиле PascalCase
Vue.component('MyComponentName', {})
<my-component-name></my-component-name>
или
<MyComponentName></MyComponentName>

Глобальная регистрация
Такие компоненты регистрируются глобально.
Это означает, что они могут использоваться в шаблоне любого корневого экземпляра (new Vue), созданного ПОСЛЕ их регистрации:

Vue.component('component-a', {})
Vue.component('component-b', {})
Vue.component('component-c', {})
new Vue({el: '#app'})

<div id='app'>
  <component-a></component-a>
  <component-b></component-b>
  <component-c>
  <component-a></component-a>
  </component-c>
</div>

Это относится также ко всем дочерним компонентам, и означает что все три из этих компонентов, также будут доступны внутри каждого из них.

Локальная регистрация
Если вы используете систему сборки, такую как Webpack, глобальная регистрация всех компонентов означает, что даже если вы прекратите использовать компонент, то он всё равно будет включён в вашу сборку приложения.
Это излишне увеличит количество JavaScript.
В таких случаях вы можете определить свои компоненты как обычные объекты JavaScript.
Затем укажите компоненты которые вы хотите использовать в опции components.

var ComponentA = {}
var ComponentB = {}
var ComponentC = {}

new Vue({
  el: '#app',
  
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB,
    'component-c': ComponentC,
 },
});

Ключ будет именем пользовательского элемента, значение будет объектом, содержащим опции компонента.

Локально зарегистрированные компоненты не будут доступны в дочерних компонентах. Если вы хотите, чтобы ComponentA был доступен в ComponentB:

var ComponentA = {}

var ComponentB = {
  components: {
    'component-a': ComponentA,
 },
};

Модульные системы
import или require

--Локальная регистрация в модульной системе
Если вы используете модульную систему Babel и Webpack.
В этих случаях мы рекомендуем создать каталог components, с каждым компонентом в его собственном файле.
Затем нужно будет импортировать каждый компонент, который вы хотите использовать, прежде чем регистрировать его локально.

Файл ComponentB.js(или ComponentB.vue):

import ComponentA from './ComponentA'
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
 },
}

Теперь оба компонента ComponentA и ComponentC, могут быть использованы в шаблоне ComponentB.

--Автоматическая глобальная регистрация базовых компонентов
Многие из ваших компонентов будут относительно общими, возможно только оборачивая элемент, например input или button.
В результате многие компоненты будут содержать в себе длинные списки базовых компонентов:

import BaseButton from './BaseButton.vue'
import BaseIcon from './BaseIcon.vue'
import BaseInput from './BaseInput.vue'

export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
 }
}

Если вы используете Webpack (или Vue CLI 3+, которая использует Webpack), вы можете использовать require.context для глобальной регистрации только таких, очень общих базовых компонентов.
Глобальная регистрация должна происходить до создания корневого экземпляра Vue (с помощью new Vue).
---------------------------------------------------------------------------------------------------

ВХОДНЫЕ ПАРАМЕТРЫ
https://ru.vuejs.org/v2/guide/components-props.html

Именование входных параметров
Имена HTML-атрибутов являются регистро-независимыми, поэтому браузеры интерпретируют любые прописные символы, как строчные.
Это означает, что при использовании шаблонов в DOM, входные параметры в camelCase стиле должны использовать свои эквиваленты в стиле kebab-case (разделённые дефисами).

Vue.component('blogpost', {

  //camelCase в JavaScript
  props: ['postTitle'],
  
  template: '<h3>{{postTitle}}</h3>'
})

kebab-case в HTML
<blogpost post-title='hello'></blogpost>

Если вы используете строковые шаблоны, то это ограничение не применяется.

Указание типа входных параметров

Входные параметры, перечисленные в виде массива строк:
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']

Вы можете перечислить входные параметры объектом с типами
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object
}

Передача статических и динамических входных параметров

Статически
<blog-post title='Запись 1'></blog-post>

Динамически
<blog-post v-bind:title='post.title'></blog-post>

--Передача чисел
<blog-post v-bind:likes='42'></blog-post>

--Передача булевых значений
<blog-post is-published></blog-post> //это true
<blog-post v-bind:is-published='false'></blog-post>

--Передача массивов
<blog-post v-bind:comment-ids='[234, 266, 273]'></blog-post>

--Передача объектов
<blog-post v-bind:author='{name: 'name1', company: 'company1'}'></blog-post>

--Передача свойств объекта
Если вы хотите передать все свойства объекта в качестве входных параметров, вы можете использовать v-bind без аргументов (v-bind вместо v-bind:prop-name). 

Например, для объекта post:
post: {
  id: 1,
  title: 'Запись 1'
}

Следующий шаблон:
<blog-post v-bind='post'></blog-post>

Будет аналогичен:
<blog-post
  v-bind:id='post.id'
  v-bind:title='post.title'
></blog-post>

Однонаправленный поток данных
Все входные параметры образуют одностороннюю привязку между родительским свойством и дочерним.
Когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот.
Каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены.
Вы не должны пытаться изменять входной параметр внутри дочернего компонента.

Обычно встречаются два случая, когда возникает соблазн изменять входной параметр:

1. Входной параметр используется для передачи начального значения, а дочерний компонент хочет использовать его как локальное свойство данных в дальнейшем.
В этом случае лучше всего определить локальное свойство данных, которое использует значение входного параметра в качестве начального:

props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
 }
}

2. Входной параметр передаётся как необработанное значение, которое необходимо преобразовать.
В этом случае лучше всего определить вычисляемое свойство с использованием входного параметра:

props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim();
 }
}

Объекты и массивы в JavaScript передаются по ссылке, поэтому если входной параметр является массивом или объектом, то изменение объекта или массива внутри дочернего компонента - будет влиять на состояние родителя.

Валидация входных параметров
Чтобы указать валидации входного параметра, вы можете предоставить в props объект с валидациями для проверки значения.

Vue.component('my-component', {

  props: {

    //Проверка типа ('null' означает любой тип)
    propA: Number,
	propA: String,

    //Несколько допустимых типов
    propB: [String, Number],

    //Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
   },

    //Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
   },

    //Объект со значением по умолчанию
    propE: {
      type: Object,
      //Для объектов или массивов значения по умолчанию
      //должны возвращаться из функции
      default: function () {
        return {message: 'hello'}
     }
   },

    //Пользовательская функция для валидации
    propF: {
      validator: function (value) {
        //Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
     }
   }
 }
})

Входные параметры валидируются перед созданием экземпляра компонента, поэтому свойства экземпляра (data, computed итд) не будут доступны внутри функций default и validator.

--Проверка типа
Значением type может быть один из следующих нативных конструкторов:

String
Number
Boolean
Array
Object
Date
Function
Symbol

type также может быть пользовательской функцией-конструктором и валидация будет выполняться проверкой с помощью instanceof.

function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

Vue.component('blog-post', {
  props: {
    author: Person
 }
})
Чтобы проверить, что значение входного параметра author было создано с помощью new Person.

Передача обычных атрибутов
Обычные атрибуты — это атрибуты, передаваемые в компонент, но не имеющие определения соответствующего входного параметра в компоненте.

--Замена/Объединение существующих атрибутов
Для большинства атрибутов, значение предоставляемое компоненту, будет заменять значение заданное компонентом.
Например, передача type='text' будет заменять type='date'.
Для атрибутов class и style оба значения будут объединены.

--Отключение наследования атрибутов
Если вы не хотите, чтобы корневой элемент компонента наследовал атрибуты, вы можете установить inheritAttrs: false в опциях компонента:

Vue.component('my-component', {
  inheritAttrs: false,
})

Это может быть особенно полезно в сочетании со свойством экземпляра $attrs, которое содержит имена атрибутов и значения.
С помощью inheritAttrs: false и $attrs вы можете вручную определять к какому элементу должны применяться атрибуты.
Этот шаблон позволяет вам использовать базовые компоненты больше как обычные HTML-элементы, не беспокоясь о том, какой элемент будет у него корневым.
---------------------------------------------------------------------------------------------------

ПОЛЬЗОВАТЕЛЬСКИЕ СОБЫТИЯ
https://ru.vuejs.org/v2/guide/components-custom-events.html

Именование событий
всегда использовать kebab-case

Настройка v-model у компонента
По умолчанию v-model на компоненте использует входной параметр value и событие input.
Но некоторые типы полей, такие как чекбоксы или радиокнопки, могут использовать атрибут value для других целей и его трогать не надо.
Использование опции model позволит избежать конфликта в таких случаях:

Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
 },
  props: {
    checked: Boolean
 },
  template: '
    <input
      type='checkbox'
      v-bind:checked='checked'
      v-on:change='$emit('change', $event.target.checked)'
    >
})

Теперь, когда используем v-model на этом компоненте:
<base-checkbox v-model='lovingVue'></base-checkbox>

значение lovingVue будет передано во входном параметре checked.
А обновляться свойство lovingVue будет когда <base-checkbox> сгенерирует событие change с новым значением.
Но вам всё равно нужно объявлять входной параметр checked в опции props компонента.

Подписка на нативные события в компонентах
Иногда нужно подписаться на нативные события браузера на корневом элементе компонента.
Vue предоставляет свойство $listeners, содержащее объект всех слушателей, которые используются на компоненте.
Используя свойство $listeners, вы можете передать все слушатели событий на компоненте на определённый дочерний элемент с помощью v-on='$listeners'.

Модификатор .sync
В некоторых случаях нам может понадобиться “двусторонняя привязка” для входных параметров.
К сожалению, настоящая двусторонняя привязка может создавать проблемы с поддержкой, поскольку дочерние компоненты смогут мутировать состояние родителя без источника.
Поэтому вместо этого, мы рекомендуем генерировать события с определённым шаблоном имени update:myPropName.

Например, в гипотетическом компоненте с входным параметром title, мы можем сообщить о намерении присвоить новое значение:
this.$emit('update:title', newTitle)

Затем, родитель может прослушать это событие и обновить локальное свойство, если захочет:

<text-document
  v-bind:title='doc.title'
  v-on:update:title='doc.title = $event'
></text-document>

Для удобства мы предлагаем краткую запись для этого шаблона с помощью модификатора sync:
<text-document
  v-bind:title.sync='doc.title'
></text-document>

Модификатор sync также может использовать вместе с v-bind при использовании объектной записи, чтобы устанавливать сразу значения нескольких входных параметров:
<text-document
  v-bind.sync='doc'
></text-document>

Это передаёт каждое свойство в объекте doc (например, title) в качестве индивидуальных входных параметров, а затем добавляет слушатели событий v-on для каждого из них.
---------------------------------------------------------------------------------------------------

СЛОТЫ
https://ru.vuejs.org/v2/guide/components-slots.html

Содержимое слотов

Компонент
<navigation-link url='/profile'>
  Ваш профиль
</navigation-link>

Затем в шаблоне для <navigation-link> у вас должно быть:

<a
  v-bind:href='url'
  class='nav-link'
>
  <slot></slot>
</a>

Когда компонент будет отрисован, элемент <slot> будет заменён на “Ваш профиль”. Слоты могут содержать любой код шаблона, включая HTML. Или даже другие компоненты.

Именованные слоты
<div class='container'>
  <header>
    <slot name='header'></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name='footer'></slot>
  </footer>
</div>

Чтобы передать контент в именованные слоты, мы можем использовать атрибут slot на элементе <template> в родителе:

<base-layout>
  <template slot='header'>
    <h1>заголовок страницы</h1>
  </template>
  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>
  <template slot='footer'>
    <p>контактная информация</p>
  </template>
</base-layout>

Или атрибут slot также может использоваться непосредственно на обычном элементе:

<base-layout>
  <h1 slot='header'>заголовок страницы</h1>
  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>
  <p slot='footer'>Некая контактная информация</p>
</base-layout>

Всё ещё может оставаться один слот без имени, который будет считаться слотом по умолчанию, в который будет помещён контент без указания слота.

Определение контента по умолчанию для слота
Бывают случаи, когда полезно предоставить слот с каким-то контентом по умолчанию.
Например, для компонента <submit-button> мы можем захотеть, чтобы по умолчанию содержимое кнопки было “Отправить”, но также позволяет пользователям переопределить на “Сохранить”, “Загрузить” или что-либо ещё.
Для достижения этого необходимо указать контент по умолчанию внутри тега <slot>.
Если родитель предоставит содержимое для слота, он заменит контент по умолчанию.

<button type='submit'>
  <slot>Отправить</slot>
</button>

Область видимости при компиляции
Слот имеет доступ к тем же свойствам экземпляра (т.е. имеет такую же “область видимости”), что и остальная часть шаблона.
Всё в шаблоне родительского компонента компилируется в области видимости родителя.
Всё в шаблоне потомка компилируется в области видимости потомка.

Слоты с ограниченной областью видимости
Иногда вам может потребоваться реализовать компонент с переиспользуемым слотом, который может получить доступ к данным дочернего компонента.
---------------------------------------------------------------------------------------------------

ДИНАМИЧЕСКИЕ И АСИНХРОННЫЕ КОМПОНЕНТЫ
https://ru.vuejs.org/v2/guide/components-dynamic-async.html

keep-alive с динамическими компонентами
Например есть табы, внутри которых меню с выбором:
<component v-bind:is='currentTabComponent'></component>

Когда переключаемся между табами, то выбор меню сбрасывается, ибо происходит перерисовка. Чтобы не сбрасывался (кешировался), надо сделать так:
<keep-alive>
  <component v-bind:is='currentTabComponent'></component>
</keep-alive>

<keep-alive> требует чтобы у всех переключаемых компонентов было задано имя, либо через опцию name компонента, либо через локальную/глобальную регистрацию. Компонент останется в памяти а состояние будет сохранено. у keep-alive 2 хука жизненного цикла: activated и deactivated

Асинхронные компоненты
Иногда бывает удобно разделить крупное приложение на части и подгружать компоненты с сервера только тогда, когда в них возникнет потребность. Для этого Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и закэширует результат для дальнейшего использования.

Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    //Передаём определение компонента в коллбэк resolve
    resolve({
      template: '<div>Я — асинхронный!</div>'
   })
 }, 1000)
})

Функция-фабрика принимает параметр resolve — коллбэк, который вызывается после того, как определение компонента получено от сервера. Кроме того, можно вызвать reject(reason), если загрузка по какой-либо причине не удалась. Мы используем setTimeout исключительно в демонстрационных целях; как именно получать компонент в реальной ситуации — решать только вам самим.
---------------------------------------------------------------------------------------------------

ОБРАБОТКА КРАЙНИХ СЛУЧАЕВ
https://ru.vuejs.org/v2/guide/components-edge-cases.html

Все возможности, описанные на этой странице, описывают способы обработки крайних случаев, что означает необычные ситуации, которые иногда требуют исключений в правилах Vue.

Доступ к элементу и компоненту
В большинстве случаев лучше избегать связи с другими экземплярами компонентов или вручную манипулировать элементами DOM

--Доступ к корневому экземпляру
В каждом дочернем компоненте экземпляра new Vue, к этому корневому экземпляру можно получить доступ через свойство $root

--Доступ к экземпляру родительского компонента
Подобно $root, свойство $parent можно использовать для доступа к родительскому экземпляру из дочернего.

--Доступ к экземплярам дочерних компонентов и элементов
Несмотря на наличие входных параметров и событий, иногда вам может потребоваться прямой доступ к дочернему компоненту в JavaScript. Для этого вы можете назначить ссылочный ID дочернему компоненту с помощью атрибута ref.

--Внедрение зависимостей

--Программное добавление прослушивателей событий
До сих пор вы видели использование $emit, и прослушивание с помощью v-on, но экземпляры Vue также предоставляют другие методы для интерфейса событий.

Циклические ссылки

--Рекурсивные компоненты
Компоненты могут рекурсивно вызывать себя в своём собственном шаблоне.

--Циклические ссылки между компонентами

Альтернативные определения шаблонов

--Inline-шаблоны
Если у компонента-потомка присутствует специальный атрибут inline-template, то содержимое элемента будет использовано не для распределения контента, а в качестве шаблона этого компонента.

--X-Templates
Другой способ определения шаблонов — указывать их внутри тега script с типом text/x-template, а затем ссылаться на шаблон по id.

Контролирование обновлений
Благодаря системе реактивности Vue, она всегда знает, когда нужно выполнять обновления (если вы используете её правильно).

--Принудительное обновление
$forceUpdate

--“Дешёвые” статические компоненты с помощью v-once
Отрисовка простых элементов HTML во Vue происходит очень быстро, но иногда встречаются компоненты, в которых очень много статического контента. В таких случаях, вы можете убедиться что он будет выполнен один раз и затем закэширован, добавив директиву v-once на корневой элемент
---------------------------------------------------------------------------------------------------

АНИМИРОВАНИЕ СПИСКОВ И ПОЯВЛЕНИЯ/ИСЧЕЗНОВЕНИЯ
https://ru.vuejs.org/v2/guide/transitions.html

Vue даёт возможность разным образом анимировать переходы при добавлении-обновлении-удалении объектов DOM.

Анимирование одиночного элемента/компонента
Vue располагает компонентом-обёрткой transition, позволяющим анимировать появление и исчезновение элемента/компонента в следующих случаях:
Условная отрисовка (используя v-if)
Условное отображение (используя v-show)
Динамические компоненты
Корневые элементы компонентов

<div id='demo'>

  <button v-on:click='show1 = !show1'>
    Переключить
  </button>

  <transition name='myfade'>
    <p v-if='show1'>привет</p>
  </transition>

</div>

new Vue({
  el: '#demo',
  data: {
    show1: true
 }
})

.myfade-enter-active, .myfade-leave-active {
  transition: opacity .5s;
}
.myfade-enter, .myfade-leave-to {
  opacity: 0;
}

--Классы переходов

v-enter: начало анимации появления элемента.
v-enter-active: анимация появления элемента активна.
v-enter-to: анимация появления элемента завершается.

v-leave: начало анимации исчезновения элемента.
v-leave-active: анимация исчезновения элемента активна.
v-leave-to: анимация исчезновения элемента завершается.

--CSS-переходы

<div id='example-1'>

  <button @click='show = !show'>
    Переключить отрисовку
  </button>

  <transition name='slide-fade'>
    <p v-if='show'>привет</p>
  </transition>

</div>
new Vue({
  el: '#example-1',
  data: {
    show: true
 }
})

/* Анимации появления и исчезновения могут иметь различные продолжительности и динамику. */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateX(10px);
  opacity: 0;
}

--CSS-анимации

<div id='example-2'>

  <button @click='show = !show'>
  Переключить отображение
  </button>

  <transition name='bounce'>
    <p v-if='show'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.</p>
  </transition>

</div>

new Vue({
  el: '#example-2',
  data: {
    show: true
 }
})

.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
 }
  50% {
    transform: scale(1.5);
 }
  100% {
    transform: scale(1);
 }
}

--Пользовательские классы переходов
Полезно для комбинирования системы анимированных переходов Vue с возможностями сторонних библиотек CSS-анимаций, таких как Animate.css.

enter-class
enter-active-class
enter-to-class

leave-class
leave-active-class
leave-to-class

<link href='https://cdn.jsdelivr.net/npm/animate.css@3.5.1' rel='stylesheet' type='text/css'>
<div id='example-3'>

  <button @click='show = !show'>
    Переключить отрисовку
  </button>

  <transition
    name='custom-classes-transition'
    enter-active-class='animated tada'
    leave-active-class='animated bounceOutRight'>
    <p v-if='show'>привет</p>
  </transition>

</div>

new Vue({
  el: '#example-3',
  data: {
    show: true
 }
})

--Совместное использование переходов и анимаций
Для того чтобы Vue знал о завершении анимации, ему требуется установка подписчиков на события.
В зависимости от используемых правил CSS, таким событием будет либо transitionend, либо animationend.
Если вы используете только один из подходов, Vue определит правильный тип автоматически.

--Указание длительности перехода
В большинстве случаев Vue может автоматически определить когда переход завершён.
По умолчанию Vue дожидается первого события transitionend или animationend на корневом элементе.
Тем не менее, это не всегда может быть нужным — например, мы можем иметь хореографическую последовательность переходов, где некоторые внутренние элементы могут иметь задержку перед переходом или более длинный по времени переход, чем у корневого элемента.
В таких случаях вы можете явно указать продолжительность перехода (в миллисекундах) с помощью опции duration на компоненте <transition>:
<transition :duration='1000'>...</transition>

Можно также указать отдельные значения продолжительностей начала и окончания перехода:
<transition :duration='{enter: 500, leave: 800}'>...</transition>

--JavaScript-хуки
<transition

  v-on:before-enter='beforeEnter'
  v-on:enter='enter'
  v-on:after-enter='afterEnter'
  v-on:enter-cancelled='enterCancelled'

  v-on:before-leave='beforeLeave'
  v-on:leave='leave'
  v-on:after-leave='afterLeave'
  v-on:leave-cancelled='leaveCancelled'
>
</transition>


methods: {

  //ПОЯВЛЕНИЕ
  beforeEnter: function (el) {},
  enter: function (el, done) {},
  afterEnter: function (el) {},
  enterCancelled: function (el) {},

  //ИСЧЕЗНОВЕНИЕ
  beforeLeave: function (el) {},
  leave: function (el, done) {},
  afterLeave: function (el) {},
  leaveCancelled: function (el) {},
}

Эти хуки могут применяться как самостоятельно, так и в сочетании с CSS-переходами и анимациями.
Если ваш переход основан только на JavaScript, обязательно вызывайте коллбэки done в хуках enter и leave.
Если вы этого не сделаете, хуки будут вызваны синхронно, и переход закончится раньше, чем отработает ваш код.
Лучше явным образом указывать v-bind:css='false' для переходов, основанных только на JavaScript.
Это позволит Vue не тратить время на определение параметров CSS.

Переходы при первичной отрисовке
Если вы хотите, чтобы пользователь увидел анимацию перехода и при изначальной отрисовке, добавьте атрибут appear:
<transition appear></transition>

По умолчанию будут задействованы переходы, указанные для появления и исчезновения. Можно, впрочем, указать и отдельные:
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class" (в версии 2.1.8+)
  appear-active-class="custom-appear-active-class"
></transition>

То же справедливо и для хуков:
<transition
  appear
  v-on:before-appear="customBeforeAppearHook"
  v-on:appear="customAppearHook"
  v-on:after-appear="customAfterAppearHook"
  v-on:appear-cancelled="customAppearCancelledHook"
></transition>

Переходы между элементами
Переходы с помощью v-if/v-else.
Один из наиболее частых случаев — переход от списка к сообщению, что список пуст:

<transition>
  <table v-if='items.length > 0'></table>
  <p v-else>Жаль, но ничего не найдено.</p>
</transition>

При переключении между элементами, использующими одноимённые теги, нужно указать Vue, что это различные элементы, установив уникальные значения атрибута key. В противном случае компилятор Vue из соображений эффективности только поменяет содержимое элемента. Несмотря на отсутствие технической необходимости, считается хорошим тоном всегда оборачивать множественные теги в компонент <transition>.

<transition>
  <button v-if="isEditing" key="save">Сохранить</button>
  <button v-else key="edit">Редактировать</button>
</transition>

Для перехода между разными состояниями элемента Вместо использования v-if и v-else, можно переписать пример выше вот так:

<transition>
  <button v-bind:key="isEditing">
    {{isEditing ? 'Сохранить' : 'Редактировать'}}
  </button>
</transition>

Организовать переходы между любым количеством элементов, можно многократно используя v-if, либо привязывая единственный элемент к динамическому свойству. Например:

<transition>
  <button v-if="docState === 'saved'" key="saved">Редактировать</button>
  <button v-if="docState === 'edited'" key="edited">Сохранить</button>
  <button v-if="docState === 'editing'" key="editing">Отмена</button>
</transition>

Что можно также записать в таком виде:

<transition>
  <button v-bind:key="docState">{{buttonMessage}}</button>
</transition>

computed: {
  buttonMessage: function () {
    switch (this.docState) {
      case 'saved': return 'Редактировать'
      case 'edited': return 'Сохранить'
      case 'editing': return 'Отмена'
    }
  }
}

--Режимы переходов
Во время перехода от кнопки “on” к кнопке “off” одновременно отображаются обе кнопки: одна — исчезая, другая — появляясь.
Так transition ведёт себя по умолчанию.
Тем не менее, одновременное сокрытие и появление элементов — это не всегда то, чего хочется.
Поэтому Vue предоставляет альтернативные режимы перехода:
in-out - сначала появляется новый элемент, и только после этого исчезает старый.
out-in - сначала исчезает старый элемент, и только после этого появляется новый.

Переходы между компонентами
Переходы между компонентами — ещё проще, нам даже не нужен атрибут key.
Всё, что нужно — завернуть динамический компонент в <transition>:

<transition name='component-fade' mode='out-in'>
  <component v-bind:is='view'></component>
</transition>

new Vue({
  el: '#demo',
  data: {
    view: 'v-a'
 },
  components: {
    'v-a': {
      template: '<div>Компонент А</div>'
   },
    'v-b': {
      template: '<div>Компонент Б</div>'
   }
 }
})

.component-fade-enter-active, .component-fade-leave-active {
  transition: opacity .3s ease;
}
.component-fade-enter, .component-fade-leave-to {
  opacity: 0;
}

Переходы в списках
В этом случае, мы используем компонент <transition-group>. В отличие от <transition>, он создаёт реальный элемент. По умолчанию это <span>, но можно изменить на любой другой, указав атрибут tag. Режимы переходов недоступны, так как мы больше не переключаемся туда-сюда между взаимоисключающими элементами. У каждого элемента внутри <transition-group> всегда обязательно должно быть уникальное значение атрибута key.

--Анимация вставки и удаления элементов списка

--Анимация перемещения элементов списка
<transition-group> способен анимировать не только появление и удаление элементов, но также и их перемещение. Происходит это путём добавления класса v-move, который указывается при изменении позиции элементов.

--Упругая анимация элементов списка
Повторное использование анимированных переходов
Анимация переходов может быть переиспользована благодаря компонентной системе Vue. Всё, что необходимо сделать — это поместить компонент <transition> или <transition-group> в корне компонента, а затем передать в этот компонент потомков.

Динамические переходы
Да, даже анимационные переходы в Vue управляются данными!
Простейший пример — связывание атрибута name с динамическим свойством.
<transition v-bind:name='transitionName'>
</transition>

Может пригодиться, если вы определили CSS-переходы или анимации, используя принятые в Vue соглашения об именовании классов, и просто хотите переключаться между ними.
На самом деле, любой атрибут может быть динамически связан.
И речь не только об атрибутах.
Поскольку хуки — это просто методы, у них есть доступ ко всем данным в текущем контексте, а значит и JavaScript-анимации могут зависеть от состояния компонента.
---------------------------------------------------------------------------------------------------

АНИМИРОВАНИЕ ПЕРЕХОДОВ МЕЖДУ СОСТОЯНИЯМИ
https://ru.vuejs.org/v2/guide/transitioning-state.html

Анимация состояния при помощи наблюдателей
Наблюдатели позволяют нам анимировать изменения любых числовых свойств как бегущие переключающиеся цифры с помощью либы GreenSock.
Свойства которые напрямую как числа не хранятся, можно анимировать с помощью Tween.js и Color.js

Динамические переходы между состояниями
Как и для анимированных компонентов, данные, на которых основываются переходы, могут обновляться в режиме реального времени.

Представление переходов как компонентов
Управление множеством переходов может быстро переусложнить экземпляр или компонент.
К счастью, многие анимации могут быть выделены в специализированные дочерние компоненты.

Оживление проектов
Когда есть 3-4 файла SVG то Vue автоматически их сливает в аннимацию.
---------------------------------------------------------------------------------------------------

ПРИМЕСИ
https://ru.vuejs.org/v2/guide/mixins.html

Примеси (mixins) — это гибкий инструмент повторного использования кода в компонентах Vue.
Объект примеси может содержать любые опции компонентов.
При использовании компонентом примеси, все опции примеси подмешиваются к собственным опциям компонента.

Примесь
var myMixin = {

  created: function () {
    this.hello()
 },

  methods: {
    hello: function () {
      console.log('привет из примеси!')
   }
 }

}

В компонент внедряем примесь
var Component = Vue.extend({
  mixins: [myMixin]
})
var component = new Component() //=> 'привет из примеси!'

Слияние опций
Если примесь и компонент содержат пересекающиеся опции, они будут объединены.

-Объект data претерпевает поверхностное слияние (на 1 свойство в глубину) с объектом data компонента, который имеет приоритет в случаях конфликтов.

-Функции хуков с одинаковыми именами объединяются в массив, чтобы все они вызывались. Хуки примеси будут вызываться перед собственными хуками компонента.

-Опции, ожидающие значения в форме объектов, такие как methods, components и directives будут объединены. В случае конфликта, приоритет имеют опции компонента.

Обратите внимание, что те же самые стратегии слияния используются и в Vue.extend().

Глобальные примеси
Примесь может быть применена и глобально.
Но используйте данную возможность осторожно.
После применения, примесь окажет влияние на все экземпляры Vue, создаваемые в дальнейшем.

Пользовательские стратегии слияния опций
При слиянии пользовательских опций применяется стратегия по умолчанию, которая просто заменяет одни значения другими. Если вы хотите использовать пользовательскую логику при слиянии пользовательских опций, добавьте функцию в Vue.config.optionMergeStrategies
---------------------------------------------------------------------------------------------------

ПОЛЬЗОВАТЕЛЬСКИЕ ДИРЕКТИВЫ
https://ru.vuejs.org/v2/guide/custom-directive.html

Помимо встроенных директив (таких как v-model и v-show), Vue позволяет использовать ваши собственные.
При этом важно понимать, что основным механизмом создания повторно используемого кода всё-таки являются компоненты.

Регистрируем глобальную пользовательскую директиву 'v-focus'
Vue.directive('focus', {
  //Когда привязанный элемент вставлен в DOM...
  inserted: function (el) {
    //Переключаем фокус на элемент
    el.focus()
 }
})

Чтобы зарегистрировать директиву локально, можно передать опцию directives при определении компонента:
directives: {
  focus: {
    //определение директивы
    inserted: function (el) {
      el.focus()
   }
 }
}

<input v-focus>

Хуки
Для жизненного цикла директивы можно указать следующие хуки
bind
inserted
update
componentUpdated
unbind

Аргументы хуков
В хуки передаются следующие параметры:
el
binding
vnode
oldVnode

Все аргументы, кроме el, следует понимать как только для чтения и никогда не изменять их. В случае необходимости передать информацию между хуками рекомендуем воспользоваться dataset.

Передача объекта данных в директиву
В случае, если директива должна принимать несколько параметров, можно указать объект JavaScript — годится любое валидное выражение

<div v-demo='{color: 'белый', text: 'привет!'}'></div>

Vue.directive('demo', function (el, binding) {
  console.log(binding.value.color) //=> 'белый'
  console.log(binding.value.text)  //=> 'привет!'
})
---------------------------------------------------------------------------------------------------

RENDER-ФУНКЦИИ И JSX
https://ru.vuejs.org/v2/guide/render-function.html

В большинстве случаев для формирования HTML с помощью Vue рекомендуется использовать шаблоны.
Впрочем, иногда возникает необходимость в использовании всех алгоритмических возможностей JavaScript.
В таких случаях можно применить render-функции — более низкоуровневую альтернативу шаблонам.

Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   //имя тега
      this.$slots.default //массив дочерних элементов
    )
 },

  props: {
    level: {
      type: Number,
      required: true
   }
 }
})

когда дочерние элементы передаются без указания атрибута slot, они сохраняются в экземпляре компонента как $slots.default

Это:
<h1>{{blogTitle}}</h1>
Аналогично этому:
render: function (createElement) {
  return createElement('h1', this.blogTitle)
}

А этот код:
<ul v-if='items.length'>
  <li v-for='item in items'>{{item.name}}</li>
</ul>
<p v-else>пусто</p>

Аналогичен этому:
props: ['items'],
render: function (createElement) {
  if (this.items.length) {
    return createElement('ul', this.items.map(function (item) {
      return createElement('li', item.name)
   }))
 } else {
    return createElement('p', 'пусто')
 }
}

В render-функции нет прямого аналога v-model, вы должны реализовать эту логику самостоятельно.

--События и модификаторы клавиш
Модификаторы	Префикс
.passive	&
.capture	!
.once	~
.capture.once или .once.capture	~!

Для всех остальных событий и модификаторов клавиш нет необходимости в префиксе, потому что вы можете просто использовать методы события в обработчике
.stop	event.stopPropagation()
.prevent	event.preventDefault()
.self	if (event.target !== event.currentTarget) return
Клавиши:
.enter, .13	if (event.keyCode !== 13) return (измените 13 на любой другой код клавиши для модификаторов других клавиш)
Модификаторы клавиш:
.ctrl, .alt, .shift, .meta	if (!event.ctrlKey) return (измените ctrlKey на altKey, shiftKey или metaKey соответственно)

--Слоты
Вы можете получить доступ к статическому содержимому слотов в виде массивов VNode используя this.$slots:

render: function (createElement) {
  //`<div><slot></slot></div>`
  return createElement('div', this.$slots.default)
}

И получить доступ к слотам со своей областью видимости как к функциям, возвращающим VNode, используя this.$scopedSlots:

props: ['message'],
render: function (createElement) {
  //`<div><slot :text='message'></slot></div>`
  return createElement('div', [
    this.$scopedSlots.default({
      text: this.message
   })
  ])
}

Чтобы передать слоты со своей областью видимости в дочерний компонент используя render-функцию, применяйте свойство scopedSlots в данных VNode


JSX
Есть плагин для Babel, позволяющий использовать JSX в Vue

Функциональные компоненты
Компонент который мы создали выше, довольно прост.
У него нет какого-либо состояния, хуков или требующих наблюдения данных.
По сути это всего лишь функция с параметром.
В подобных случаях мы можем пометить компоненты как функциональные (опция functional), что означает отсутствие у них состояния (нет реактивных данных) и экземпляра (нет переменной контекста this).

Функциональный компонент выглядит так:
Vue.component('my-component', {
  functional: true,
  //входные параметры опциональны
  props: {
    //...
 },

  //чтобы компенсировать отсутствие экземпляра мы передаём контекст вторым аргументом
  render: function (createElement, context) {
    //...
 }
})

Если вы используете однофайловые компоненты, вы можете объявить функциональные компоненты основанные на шаблоне таким образом:
<template functional></template>

Всё необходимое компоненту передаётся через context — объект, содержащий следующие поля:
props
children
slots
data
parent
listeners
injections

Поскольку функциональные компоненты — это просто функции, их отрисовка обходится значительно дешевле.
Однако отсутствие постоянного экземпляра означает, что они не будут отображаться в дереве компонентов в Vue Devtools.

--Передача атрибутов и событий дочерним элементам/компонентам
В обычных компонентах, атрибуты не определённые как входные параметры, автоматически добавляются к корневому элементу компонента, заменяя или правильно объединяя любые существующие атрибуты с тем же именем.
Однако функциональные компоненты требуют явного определения этого поведения.
---------------------------------------------------------------------------------------------------

ПЛАГИНЫ
https://ru.vuejs.org/v2/guide/plugins.html

Плагины позволяют добавить в Vue некоторую глобальную функциональность.
Область применения плагинов явно не определена.

Можно разделить плагины на нескольких типов:
-Добавляют глобальные методы/свойства, например vue-custom-element
-Добавляют глобальные директивы/фильтры/переходы, например vue-touch
-Добавляют опции компонентам через глобальную примесь, например vue-router
-Добавляют методы экземпляра Vue, через Vue.prototype
-Библиотеки, предоставляющие собственные API и комбинирующие вышеперечисленные возможности, например vue-router

Использование плагинов
Vue.use(MyPlugin, {someOption: true})
new Vue({
});

Некоторые официальные плагины Vue.js, такие как vue-router, автоматически вызывают Vue.use(), если обнаружат глобальную переменную Vue.

Создание плагина
MyPlugin.install = function (Vue, options) {

  //добавление глобального метода или свойства
  Vue.myGlobalMethod = function () {}

  //добавление глобального объекта
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {}
 })

  //добавление опций компонентов
  Vue.mixin({
    created: function () {}
 })

  //добавление метода экземпляра
  Vue.prototype.$myMethod = function (methodOptions) {}
}
---------------------------------------------------------------------------------------------------

ФИЛЬТРЫ
https://ru.vuejs.org/v2/guide/filters.html

Для распространённых задач форматирования текста во Vue используются фильтры.

mustache стиль
{{message | capitalize}}

через v-bind
<div v-bind:id='rawId | formatId'></div>

Вы можете определить локальные фильтры в опциях компонента:

filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
 }
}

Или определить фильтр глобально перед созданием экземпляра Vue:

Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({});

Фильтры можно объединять в цепочки:
{{message | filterA | filterB}}

Функция фильтра всегда принимает значение выражения (результат предыдущей цепочки) в качестве первого аргумента.
filterA, определённый с одним аргументом, получит значение message, а затем функция filterB будет вызвана с результатом filterA, переданным единственным аргументом в filterB.

Фильтры являются JavaScript-функциями, и потому могут принимать параметры:

{{message | filterA('arg1', arg2)}}

filterA определяется как функция с тремя аргументами.
Значение message будет передано 1 аргументом.
Простая строка 'arg1' будет передана в filterA 2 аргументом.
А значение выражения arg2, — 3 аргументом.
---------------------------------------------------------------------------------------------------

РАЗВЁРТЫВАНИЕ НА PRODUCTION
https://ru.vuejs.org/v2/guide/deployment.html

Включение режима production

--Без использования систем сборки
<script src='vue.min.js'></script>

--С использованием систем сборки
Режим production определяется по значению process.env.NODE_ENV внутри исходного кода Vue.
Все шаблоны vue-cli уже настроены.

Webpack:
module.exports = {
  mode: 'production'
}

Прекомпиляция шаблонов
При использовании DOM в качестве шаблона или строковых шаблонов в JavaScript, компиляция в render-функцию будет выполняться на лету.
Это достаточно быстро для большинства случаев, но если ваше приложение нуждается в максимальной производительности стоит этого избегать.
Самый простой способ предварительной компиляции шаблонов — использовать однофайловые компоненты.
На этапе сборки проекта будет выполнена предварительная компиляция, поэтому результирующий код будет содержать только render-функции вместо необработанных строковых шаблонов.

Если вы используете Webpack и предпочитаете разделять JavaScript и файлы шаблонов, вы можете воспользоваться vue-template-loader, который также преобразует файлы шаблонов в render-функции на JavaScript на этапе сборки.

Извлечение CSS из компонентов
При использовании однофайловых компонентов, CSS из компонента будет динамически добавлен как тег <style> через JavaScript.
Это немного увеличивает затраты времени выполнения, поэтому при использовании отрисовки на стороне сервера может привести к мельканию неоформленного содержимого (flash of unstyled content — FOUC).
Извлечение CSS из всех компонентов в один файл позволит избежать этой проблемы, а также добиться лучших результатов в минификации и кешировании CSS:
Webpack + vue-loader (в vue-cli с шаблоном webpack это уже настроено)

Отслеживание ошибок времени выполнения
Если при отрисовке компонента произойдёт ошибка, она будет передана в глобальную функцию Vue.config.errorHandler, если таковая была указана.


Старт проекта с vue-cli
C:\>npm install -g @vue/cli-init
C:\>npm ls -g --depth=0
C:\>cd C:\Users\u\Desktop\1

C:\Users\u\Desktop\1>vue init webpack-simple C:\Users\u\Desktop\1
или 
C:\Users\u\Desktop\1>vue init webpack-simple projectname1

C:\Users\u\Desktop\1>npm install //скачивает папку node_modules
C:\Users\u\Desktop\1>npm ls --depth=0
C:\Users\u\Desktop\1>npm run dev

Запускается при разработке:
npm run dev
и какбы на лету генерит итоговый файл build.js

Запускается в конце. генерит файлы проекта в папку dist в продакшен:
npm run build

в папку assets картинки и скрипты типа бутстрапа
бутстрап можно установить и с помощью npm как пакет
---------------------------------------------------------------------------------------------------

ОДНОФАЙЛОВЫЕ КОМПОНЕНТЫ
https://ru.vuejs.org/v2/guide/single-file-components.html

Во многих проектах, глобальные компоненты определяются посредством Vue.component, с последующим new Vue({el: '#container'}) для указания элемента-контейнера в теле каждой страницы.

Для проектов малого и среднего размера, в которых JavaScript используется лишь для некоторых страниц, этот подход может прекрасно работать.
В более сложных проектах или в случаях, когда весь ваш фронтенд управляется JavaScript, явными становятся следующие недостатки:

-Глобальное определение заставляет давать уникальное имя каждому компоненту.
-Строковым шаблонам не хватает подсветки синтаксиса. Кроме того, приходится использовать слэши для многострочного HTML.
-Нет модульной поддержки CSS, в то время как HTML и JavaScript разбиваются на модули-компоненты, CSS оказывается за бортом.
-Отсутствие шага сборки ограничивает нас только HTML и ES5 JavaScript, не позволяя использовать препроцессоры вроде Pug (бывший Jade) и Babel.

Все эти недостатки решаются однофайловыми компонентами с расширением .vue, использование которых позволяют такие инструменты как Webpack.
Пример https://gist.github.com/chrisvfritz/e2b6a6110e0829d78fa4aedf7cf6b235

Мы получили:
-полную подсветку синтаксиса
-модули CommonJS
-модульный CSS
-можем использовать препроцессоры Pug, Babel (с модулями ES2015), Stylus, Buble, TypeScript, SCSS, PostCSS
-при использовании Webpack вместе с vue-loader, получаете прекрасную поддержку CSS-модулей

--Что насчёт разделения ответственности?
Внутри компонента, его шаблон, логика и стили неразрывно связаны между собой, что позволяет сделать компонент более сплочённым и удобным в поддержке.

Если вам не нравится идея однофайловых компонентов, вы можете воспользоваться возможностями горячей замены модулей и прекомпиляцией, выделив JavaScript и CSS в отдельные файлы:

<!--my-component.vue-->
<template>
  <div>Это будет предварительно скомпилировано</div>
</template>

<script src='./my-component.js'></script>
<style src='./my-component.css'></style>

Стили можно писать так:
<style scoped>
  @media (min-width: 250px) {
    .list-container:hover {
      background: orange;
   }
 }
</style>

Опциональный атрибут scoped автоматически ограничивает область видимости CSS текущим компонентом, добавляя элементам уникальные атрибуты.

--Песочница с примером
https://codesandbox.io/s/o29j95wx9

--Для новичков в модульных системах сборки JavaScript

Node Package Manager (NPM)
https://docs.npmjs.com/getting-started/what-is-npm

JavaScript стандартов ES2015/16
https://babeljs.io/docs/learn-es2015

Шаблон webpack
https://vuejs-templates.github.io/webpack

Доки webpack
https://webpack.js.org/configuration

Шаблоны
https://github.com/vuejs-templates

Vue-cli
https://github.com/vuejs/vue-cli
---------------------------------------------------------------------------------------------------

МОДУЛЬНОЕ ТЕСТИРОВАНИЕ
https://ru.vuejs.org/v2/guide/unit-testing.html

Выбор инструментов и предварительная настройка

Тест-раннер Karma
http://karma-runner.github.io

Плагин Webpack
https://github.com/webpack/karma-webpack

Примеры конфигурации Karma для Webpack
https://github.com/vuejs-templates/webpack/blob/master/template/test/unit/karma.conf.js

Создание тестируемых компонентов
Результат отрисовки компонента по большей части определяется входными параметрами, которые он принимает.
В действительности, если вывод отрисовки зависит только от входных параметров компонента, тестирование становится крайне прямолинейным и похожим на контроль возвращаемого значения чистой функции в зависимости от разных аргументов.

Контроль асинхронных обновлений
Поскольку Vue выполняет обновления DOM асинхронно, контроль результатов обновления DOM в зависимости от изменений состояния компонента должен выполняться в переданном в Vue.nextTick коллбэке.

О модульном тестировании в Vue
https://vue-test-utils.vuejs.org

Книга рецептов
https://ru.vuejs.org/v2/cookbook/unit-testing-vue-components.html
---------------------------------------------------------------------------------------------------

ПОДДЕРЖКА TYPESCRIPT
https://ru.vuejs.org/v2/guide/typescript.html

Vue поставляется с официальными файлами объявлений TypeScript, причём не только для ядра Vue, но также для Vue Router и Vuex.

Инструменты разработки

--Создание проекта

Vue CLI 3 позволяет генерировать новые проекты, которые используют TypeScript.

Чтобы начать:
1. Установите Vue CLI
npm install --global @vue/cli

2. Создайте новый проект, затем выберите опцию 'Manually select features'
vue create my-project-name

Использование
Чтобы позволить TypeScript правильно выводить типы внутри опций компонента Vue, вам необходимо определять компоненты с помощью Vue.component или Vue.extend
---------------------------------------------------------------------------------------------------

РОУТИНГ
https://ru.vuejs.org/v2/guide/routing.html

Для большинства одностраничных приложений (SPA) рекомендуется использовать официально поддерживаемую библиотеку Vue-router

Простой роутер
Если вам достаточно простейшего роутера и вы не хотите задействовать полновесную внешнюю библиотеку, может оказаться достаточно просто динамической отрисовки компонента уровня страницы:

const NotFound = {template: '<p>Страница не найдена</p>'}
const Home = {template: '<p>главная</p>'}
const About = {template: '<p>о нас</p>'}

const routes = {
  '/': Home,
  '/about': About
}

new Vue({
  el: '#app',
  data: {
    currentRoute: window.location.pathname
 },
  computed: {
    ViewComponent () {
      return routes[this.currentRoute] || NotFound
   }
 },
  render (h) {return h(this.ViewComponent)}
})

Интеграция сторонних роутеров

https://github.com/visionmedia/page.js
https://github.com/flatiron/director
https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs
https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs
---------------------------------------------------------------------------------------------------

УПРАВЛЕНИЕ СОСТОЯНИЕМ ПРИЛОЖЕНИЯ
https://ru.vuejs.org/v2/guide/state-management.html

Официальная Flux-подобная библиотека - Vuex

Контейнер состояния
Источником истины в Vue-приложениях является исходный объект data.
Экземпляры Vue лишь проксируют доступ к нему.
Состояние, которым должны совместно владеть несколько экземпляров, можно передать по ссылке:

const sourceOfTruth = {};

const vmA = new Vue({
  data: sourceOfTruth
});

const vmB = new Vue({
  data: sourceOfTruth
});

Теперь при любых изменениях sourceOfTruth, обновится и vmA и vmB.
Подкомпоненты этих экземпляров также имеют доступ к нему (через this.$root.$data).
Эффект единого источника достигнут.

Но отладка превратится в сущее мучение: любая часть данных может быть изменена любой частью приложения в любой момент и без каких-либо следов.
Для решения этой проблемы, мы можем использовать простое хранилище:

var store = {
  debug: true,
  
  state: {
    message: 'Привет!'
 },
  
  setMessageAction(newValue) {
    if (this.debug) console.log('setMessageAction вызвано с ', newValue);
    this.state.message = newValue;
 },
  
  clearMessageAction() {
    if (this.debug) console.log('clearMessageAction вызвано');
    this.state.message = '';
 }
  
};

Каждый экземпляр/компонент по-прежнему может иметь собственное, частное состояние:

var vmA = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
 }
});

var vmB = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
 }
});

Если мы продолжим развивать концепцию, при которой компонентам запрещается прямое изменение состояния хранилища, а вместо этого предполагается обработка событий, указывающих хранилищу на необходимость выполнения тех или иных действий, мы можем прийти к архитектуре Flux.
---------------------------------------------------------------------------------------------------

SSR. ОТРИСОВКА НА СТОРОНЕ СЕРВЕРА
https://ru.vuejs.org/v2/guide/ssr.html

Полное руководство по SSR
https://ssr.vuejs.org/ru

Nuxt.js
Правильно настроить все аспекты приложения с отрисовкой на стороне сервера и готовое к развёртыванию на production может быть сложной задачей.
К счастью, есть отличный проект сообщества, который стремится сделать всё проще: Nuxt.js — это высокоуровневый фреймворк, построенный на экосистеме Vue, что обеспечит быстрое получение опыта разработки универсальных приложений на Vue.
---------------------------------------------------------------------------------------------------

ПОДРОБНО О РЕАКТИВНОСТИ
https://ru.vuejs.org/v2/guide/reactivity.html

Одна из наиболее примечательных возможностей Vue — это ненавязчивая реактивность.
Модели представляют собой простые JavaScript-объекты.
По мере их изменения обновляется и представление данных, благодаря чему управление состоянием приложения становится простым и очевидным.

Как отслеживаются изменения
Когда простой JavaScript-объект передаётся в экземпляр Vue в качестве опции data, Vue обходит все его поля и превращает их в пары геттер/сеттер.
Геттеры и сеттеры не видны пользователю, но именно они являются тем внутренним механизмом, который позволяет Vue отслеживать зависимости и изменения данных.
К каждому экземпляру компонента приставлен связанный с ним экземпляр наблюдателя, который помечает все поля, затронутые при отрисовке компонента, как зависимости.
В дальнейшем, когда вызывается сеттер поля, помеченного как зависимость, этот сеттер уведомляет наблюдателя, который, в свою очередь, инициирует повторную отрисовку компонента.

Особенности отслеживания изменений
Vue не может отследить добавление или удаление свойства объекта.
Чтобы поле стало реактивным, Vue превращает его в пару геттер/сеттер в ходе инициализации экземпляра.
Поэтому все поля должны изначально быть заданы в объекте data.

var vm = new Vue({
  data: {
    a: 1
 }
})
теперь `vm.a` — реактивное поле

vm.b = 2
`vm.b` НЕ реактивно

В Vue нельзя динамически добавлять новые корневые реактивные свойства в уже существующий экземпляр.
Тем не менее, можно добавить реактивное свойство во вложенные объекты, используя метод:

Vue.set(vm.someObject, 'b', 2)
или
this.$set(this.someObject, 'b', 2)

Если добавить несколько свойств в существующий объект, например, с помощью Object.assign() или _.extend(), то добавленные свойства не станут реактивными.
Для решения этой задачи придётся создать новый объект, содержащий поля как оригинального объекта, так и объекта-примеси:
this.someObject = Object.assign({}, this.someObject, {a: 1, b: 2})

Объявление реактивных свойств
Все корневые поля необходимо инициализировать изначально, хотя бы пустыми значениями:

var vm = new Vue({
  data: {
    //объявляем поле message, содержащее пустую строку
    message: ''
 },
  template: '<div>{{message}}</div>'
})

//впоследствии задаём значение `message`
vm.message = 'Привет!'

Если не задать поле message в опции data, Vue выведет предупреждение, что функция отрисовки пытается получить доступ к несуществующему свойству.
Теперь объект data можно рассматривать как схему состояния компонента.
Код, в котором реактивные свойства компонента перечислены заранее, намного проще для понимания.

Асинхронная очередь обновлений
В Vue обновление DOM выполняется асинхронно.
Каждый раз, когда обнаруживается изменение в данных, создаётся очередь, которая используется в качестве буфера для этого и последующих изменений, происходящих в текущей итерации (“tick”) цикла событий.
Если один и тот же наблюдатель срабатывает несколько раз, в очередь он попадёт всё равно лишь единожды.
Благодаря использованию буфера и устранению дубликатов, вычисления и манипуляции DOM сводятся к минимуму.
В следующей итерации цикла событий Vue разбирает очередь и выполняет актуальные (уже не содержащие дубликатов) обновления.
На низком уровне для асинхронной постановки задач в очередь используются Promise.then и MessageChannel, а если они недоступны, то setTimeout(fn, 0).

Если выполнить код vm.someData = 'новое значение', компонент не будет отрисован сразу же.
Он обновится в следующей итерации при разборе очереди.
Чаще всего эту особенность можно не принимать в расчёт.

Но иногда бывает нужно дождаться состояния, в которое DOM перейдёт после обновления данных.
Хотя прямая манипуляция DOM нежелательна, а системы в целом предпочтительнее проектировать так, чтобы в них были первичные данные, - иногда всё же её не избежать.
Чтобы выполнить какой-нибудь код только после того, как завершится обновление DOM, можно передать коллбэк в метод Vue.nextTick(callback) после изменения данных.
Он будет вызван после обновления DOM.
Существует также метод экземпляра vm.$nextTick(), особенно подходящий для использования внутри компонентов, поскольку он не требует обращения к глобальной переменной Vue, а также автоматически связывает контекст this коллбэка с текущим экземпляром Vue.
---------------------------------------------------------------------------------------------------

ССЫЛКИ

Чат
https://chat.vuejs.org

GitHub
https://github.com/vuejs

Awesome
https://github.com/vuejs/awesome-vue

Дополнительные библиотеки
https://github.com/vuejs/awesome-vue#components--libraries

API
https://ru.vuejs.org/v2/api

Шпаргалка по API
https://vuejs-tips.github.io/cheatsheet

Рекомендации
https://ru.vuejs.org/v2/style-guide

Примеры
https://ru.vuejs.org/v2/examples

Cookbook
https://ru.vuejs.org/v2/cookbook

Плагин для браузера
https://github.com/vuejs/vue-devtools#vue-devtools

Vue CLI 3
https://cli.vuejs.org/ru

Vue Loader
https://vue-loader.vuejs.org/ru

Vue Template Loader
https://github.com/ktsn/vue-template-loader

Webpack + Vue Loader
https://vue-loader.vuejs.org/ru/configurations/extract-css.html

Vue Router
https://router.vuejs.org/ru
https://github.com/vuejs/vue-router
http://vuejs.github.io/vue-router

Vuex
https://vuex.vuejs.org/ru
https://github.com/vuejs/vuex

SSR
https://ssr.vuejs.org/ru

Nuxt.js
https://nuxtjs.org

Старый ман
https://metanit.com/web/vuejs

Готовые решения
https://vuejsexamples.com
---------------------------------------------------------------------------------------------------

VUEX

УСТАНОВКА
https://vuex.vuejs.org/ru/installation.html

CDN
<script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script>
<script src='https://cdn.jsdelivr.net/npm/vuex/dist/vuex.js'></script>

NPM
npm install vuex --save

Система сборки
import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);

В IE нет Promise, использовать es6-promise
<script src="https://cdn.jsdelivr.net/npm/es6-promise/dist/es6-promise.auto.js"></script>
NPM:
npm install es6-promise --save
import 'es6-promise/auto';
---------------------------------------------------------------------------------------------------

ЧТО ТАКОЕ VUEX
https://vuex.vuejs.org/ru

Центральное хранилище данных для всех компонентов.

--Паттерн управления состоянием

new Vue({

  //состояние
  data() {
    return {
      count: 0
    };
  },
  
  //представление
  template: "<div>{{ count }}</div>",
  
  //действия
  methods: {
    increment() {
      this.count++;
    }
  }
});

Состояние - данные.
Представление - отображение состояния.
Действия — методы изменения состояния, когда юзер взаимодействует с представлением.

Однонаправленный поток данных:
Состояние->Представление->Действия->Состояние

Дерево компонентов - это одно большое представление.
Каждый компонент - получает доступ к состоянию, и действиям.

Схема:
Действия сообщаются с серверным API.
Действия инициируют мутации.
Мутации изменяют состояние.
Изменившееся состояние перерисовывает представление.
Представление вызывает диспетчеризацию(вызов) действий.
Действия, Мутации, Состояние - это Vuex. Представление - Vue.
---------------------------------------------------------------------------------------------------

ВВЕДЕНИЕ
https://vuex.vuejs.org/ru/guide

Хранилище хранит состояние.
Хранилище реактивно. Изменяется хранилище - изменяется представление.
Чтобы изменить хранилище - надо вызвать мутацию.
---------------------------------------------------------------------------------------------------

СОСТОЯНИЕ
https://vuex.vuejs.org/ru/guide/state.html

Единое дерево состояния — один объект содержит всё глобальное состояние приложения.
Для каждого приложения существует только одно хранилище.

--Передача состояния в компоненты
1. через вычисляемые свойства
2. через инъекцию хранилища в корневом экземпляре new Vue({}), что даст доступ и во всех дочерних компонентах. Или в любом компоненте, что тоже даст доступ во всех его дочерних. (предпочтительнее этот вариант)

--Вспомогательная функция mapState (НЕ ПРОТЕСТИЛ. ТРЕБУЕТ МОДУЛЕЙ)
Для случая когда компонент использует МНОГО свойств и геттеров хранилища.
mapState автоматически генерирует вычисляемые свойства, проксирующие доступ к состоянию и геттерам хранилища.

--Оператор распространения объектов (НЕ ПРОТЕСТИЛ. ТРЕБУЕТ МОДУЛЕЙ)
Для слияния объекта который возвращает mapState, и локальных вычисляемых свойств.

--Компоненты всё ещё могут иметь локальное состояние
Если состояние компонента полностью локально, выносить его в Vuex не надо.
---------------------------------------------------------------------------------------------------

ГЕТТЕРЫ
https://vuex.vuejs.org/ru/guide/getters.html

Геттеры обеспечивают доступ к производным данным, основывающимся на состоянии хранилища.
Это аналог вычисляемых свойств у компонентов, только для хранилища.
Геттеры применяются, когда вычисляемый результат нужен во многих компонентах.

--Стиль обращения как к свойствам
кешируются

--Стиль обращения как к методам
можно передавать аргументы как в функцию
не кешируются

--Вспомогательная функция mapGetters (НЕ ПРОТЕСТИЛ. ТРЕБУЕТ МОДУЛЕЙ)
mapGetters проксирует геттеры хранилища, через локальные вычисляемые свойства компонента.
---------------------------------------------------------------------------------------------------

МУТАЦИИ
https://vuex.vuejs.org/ru/guide/mutations.html

Мутации это то, через что изменяют состояние.
Мутации похожи на события. Мутации тоже вызывают.
Обработчик мутации и изменяет состояние.

Мутация->Изменение состояния->Автообновление компонентов

1.Надо инициализировать начальное состояние хранилища, указав все поля.
2. Добавление новых свойств объекту:
Vue.set(obj, 'newProp', 123);
или
state.obj = { ...state.obj, newProp: 123 };

--Использование констант для обозначения типов мутаций (НЕ ПРОТЕСТИЛ. ТРЕБУЕТ МОДУЛЕЙ)
Можно вынести константы с типами мутаций и действий, - в отдельный файл.

//mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION';

//store.js
import { SOME_MUTATION } from './mutation-types'
const store = new Vuex.Store({
  mutations: {
    [SOME_MUTATION] (state) {
    }
  }
})

--Мутации должны быть синхронными
Обработчики мутаций обязаны быть синхронными

--Вызов мутаций в компонентах
1. this.$store.commit('matation_name');
2. применяя хелпер mapMutations
---------------------------------------------------------------------------------------------------

ДЕЙСТВИЯ
https://vuex.vuejs.org/ru/guide/actions.html

Действия НЕ МЕНЯЮТ состояние.
Действия вызывают мутации, а уже они меняют состояние.
Действия подходят для асинхронных операций.

actions: {
	action1(context) {}
}

context - содержит все методы и свойства хранилища
context.commit - вызвать мутацию
context.state - состояние
context.getters - геттеры

store.dispatch - вызвать действие (это называется диспетчеризация действий)

Действия, как и Мутации, поддерживают тот же формат для передачи нагрузки, и объектный синтаксис.

--Диспетчеризация(вызов) действий в компонентах
1. this.$store.dispatch('action_name');
2. применяя хелпер mapActions

--Композиция действий
Когда действия асинхронны, связать их можно через Promise.
Каждый store.dispatch возвращает Promise, и может обрабатывать Promise.
---------------------------------------------------------------------------------------------------

МОДУЛИ
https://vuex.vuejs.org/ru/guide/modules.html

Можно разделить хранилище на модули.
Каждый модуль содержит своё состояние, мутации, действия, геттеры.
Модули могут содержать подмодули.

--Локальное состояние модулей
Внутри модуля:
Мутации и Геттеры, - первым аргументом (state) получают локальное состояние модуля.
Действия, - первый аргумент (context.state) указывает на локальное состояние, третий аргумент (context.rootState) на корневое.
В геттеры корневое состояние передаётся третьим аргументом.

--Пространства имён
По-умолчанию: действия, мутации, геттеры внутри модулей - регистрируются в глобальном пространстве имён.
Это позволяет взаимодействие между модулями.

Когда в модуле используется пространство имен, то:
Геттеры и Действия будут получать свои локальные getters, dispatch, commit, state. Но глобальные rootState, rootGetters тоже передаются в параметрах.
Вызов глобального действия или мутации, - с аргументом {root: true}

--Регистрация глобального действия в модуле с собственным пространством имён
В модуле можно зарегистрировать Действие с видимостью в глобальном пространстве имен

--Подключение с помощью вспомогательных функций к пространству имён
Подключение модуля со своим пространством имён, к компонентам, с помощью вспомогательных функций mapState, mapGetters, mapActions, mapMutations

--Динамическая регистрация модулей
Создание и регистрация модулей и вложенных модулей, на лету.

--Повторное использование модулей

Случаи:
Если требуется несколько экземпляров модуля.
Или создание нескольких хранилищ, которые используются одним модулем.
Или регистрация модуля несколько раз в одном хранилище.

Проблема:
Тогда объект состояния будет использоваться по ссылке, и вызывать загрязнение состояния хранилища/модуля, при его мутациях.

Решение:
Это таже проблема, что и с data внутри компонентов. Решение будет использовать функцию для объявления состояния модуля:

const MyReusableModule = {
  state() {
    return {
      foo: 'bar'
    };
  }
  //мутации, действия, геттеры...
};
---------------------------------------------------------------------------------------------------

СТРУКТУРА ПРИЛОЖЕНИЯ
https://vuex.vuejs.org/ru/guide/structure.html

Если файл хранилища становится слишком большим, надо выносить действия, мутации, геттеры - в отдельные файлы.

├── index.html
├── main.js
├── api
│   └── #абстракции для выполнения запросов к API
├── components
│   ├── App.vue
│   └── итд
└── store
    ├── index.js #здесь собираем модули и экспортируем хранилище
    ├── actions.js   #корневые действия
    ├── mutations.js #корневые мутации
    └── modules
        ├── cart.js     #модуль корзины
        └── products.js #модуль товаров
---------------------------------------------------------------------------------------------------

ПЛАГИНЫ
https://vuex.vuejs.org/ru/guide/plugins.html

Vuex-плагин — это функция внутри которой возможны хуки для мутаций.

--Вызов мутаций из плагинов
Плагины как и компоненты, для изменения состояния - должны вызывать мутации.

--Снятие слепков состояния
Состояние хранилище ДО и ПОСЛЕ мутации.

--Встроенный плагин логирования (НЕ ПРОТЕСТИЛ. ТРЕБУЕТ МОДУЛЕЙ)
Идет в комплекте с Vuex.
---------------------------------------------------------------------------------------------------

СТРОГИЙ РЕЖИМ (STRICT MODE)
https://vuex.vuejs.org/ru/guide/strict.html

В таком режиме, любые изменения состояния хранилища в обход мутаций, - выбрасывают ошибку.
Использовать строгий режим только при разработке, не в продакшене.
---------------------------------------------------------------------------------------------------

РАБОТА С ФОРМАМИ
https://vuex.vuejs.org/ru/guide/forms.html

<input v-model='message'>

Когда Vuex в strict mode.
message это вычисляемое свойство, возвращающее ссылку на объект из хранилища.
В ответ на действия пользователя, v-model будет пытаться напрямую изменить значение message.
В strict mode это вызовет ошибку, поскольку это изменение происходит вне обработчика мутации Vuex.

Решение:
использовать двунаправленное вычисляемое свойство с сеттером
---------------------------------------------------------------------------------------------------

ТЕСТИРОВАНИЕ
https://vuex.vuejs.org/ru/guide/testing.html

тестируются Мутации, Геттеры, Действия
---------------------------------------------------------------------------------------------------

ГОРЯЧАЯ ПЕРЕЗАГРУЗКА
https://vuex.vuejs.org/ru/guide/hot-reload.html

Vuex поддерживает горячую замену Мутаций, Модулей, Действий, Геттеров, в момент разработки с помощью webpack Hot Module Replacement API.
---------------------------------------------------------------------------------------------------

ССЫЛКИ

VUE ROUTER
https://router.vuejs.org/ru/

VUE LOADER
https://vue-loader.vuejs.org/ru/

VUE CLI 3
https://cli.vuejs.org/ru/guide/

VUE SSR
https://ssr.vuejs.org/ru/

NUXT.JS
https://ru.nuxtjs.org/guide/
---------------------------------------------------------------------------------------------------

РЕКОМЕНДАЦИИ
https://ru.vuejs.org/v2/style-guide/

Имена компонентов из нескольких слов.
Свойство data компонента должно быть функцией.
Определение входных параметров компонентов с типами данных.
Используйте уникальные ключи key для v-for.
Не используйте v-if на том же элементе, что и v-for.
В стилях для компонентов использовать локальные стили (style scoped, или css-модули).
Используйте префикс $_ для пользовательских приватных свойств в плагине, примеси ($_myGreatMixin_update).
Каждый компонент должен быть в собственном файле.
components/TodoList.js
components/TodoItem.js
Имена файлов однофайловых компонентов должны быть всегда в PascalCase или всегда в kebab-case.
components/MyComponent.vue
components/my-component.vue
Базовые компоненты должны начинаться с префикса, типа такого как Base, App или V.
components/BaseButton.vue
components/BaseTable.vue
components/BaseIcon.vue
Компоненты, которые должны иметь только один активный экземпляр на странице, следует начинать именовать с префикса The.
components/TheHeading.vue
components/TheSidebar.vue
Дочерние компоненты, тесно связанные с родителями, должны включать имя родительского компонента в качестве префикса.
components/TodoList.vue
components/TodoListItem.vue
components/TodoListItemButton.vue
Компоненты должны именоваться с высшего уровня и заканчиваться описательными дополняющими словами.
components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
Компоненты без содержимого должны быть самозакрывающимися тегами в однофайловых компонентах, строковых шаблонах и JSX — но никогда в DOM-шаблонах.
В однофайловых компонентах, строковых шаблонах и JSX
<MyComponent/>
В DOM-шаблонах
<my-component></my-component>
Имена компонентов в шаблонах должны быть в PascalCase в однофайловых компонентах и строковых шаблонах — но в kebab-case в случае DOM-шаблонов.
В однофайловых компонентах и строковых шаблонах:
<MyComponent/>
В DOM-шаблонах:
<my-component></my-component>
ИЛИ Везде:
<my-component></my-component>
Стиль именования компонентов в JS/JSX всегда должен быть PascalCase, хотя они могут быть в kebab-case внутри строк для простых приложений, которые используют только глобальную регистрацию компонентов через Vue.component.
Vue.component('MyComponent', {})
Vue.component('my-component', {})
import MyComponent from './MyComponent.vue'
export default {name: 'MyComponent'}
Имена компонентов должны состоять из полных слов, а не аббревиатур.
Входные параметры должны всегда использовать camelCase при определении, но kebab-case в шаблонах и JSX.
props: {greetingText: String}
<WelcomeMessage greeting-text="hi"/>
Элементы с несколькими атрибутами должны располагаться на нескольких строках, по одному атрибуту на строку.
Шаблоны компонентов должны содержать только простые выражения, а более комплексные должны быть вынесены в вычисляемые свойства или методы.
Комплексные вычисляемые свойства должны быть разделены на максимально простые вычисляемые свойства.
Непустые значения HTML-атрибутов должны быть обрамлены кавычками (одинарными или двойными).
<input type="text">
<AppSidebar :style="{width: sidebarWidth + 'px'}">
Сокращённую запись директив (: для v-bind: и @ для v-on:) следует использовать всегда или никогда.
Порядок секций в однофайловых компонентах.
<script></script>
<template></template>
<style></style>
Лучше использовать key вместе с v-if, v-else, если они являются одним и тем же типом элемента (например, когда оба элемента <div>).
В стилях <style scoped> компонента, лучше использовать классы, а не просто вешать стили на теги.
Входные параметры и события должны быть предпочтительным способом коммуникации между родительским и дочерними компонентами, вместо использования this.$parent или изменения входных параметров, в идеальном приложении входные параметры передаются вниз, события всплывают наверх.
Vuex должен быть предпочтительным способом для глобального управления состоянием приложения, вместо использования this.$root или глобальной шины событий.
---------------------------------------------------------------------------------------------------

COOKBOOK
https://ru.vuejs.org/v2/cookbook/index.html

$ — это соглашение, которое Vue использует для свойств, доступных во всех экземплярах.

axios:
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js"></script>
Vue.prototype.$http = axios;
this.$http
    .get('https://jsonplaceholder.typicode.com/users')
    .then(function (response) {
        vm.users = response.data;
    });
еще есть некие встроенные функции fetch()	


либы для валидации форм
https://baianat.github.io/vee-validate/
https://github.com/monterail/vuelidate

аналог бутстрап
https://bulma.io/

либа для тестирования компонентов
https://github.com/vuejs/vue-test-utils
Vue Test Utils https://vue-test-utils.vuejs.org/ru/

либа для скроллов
http://scrollmagic.io/

для отладки есть:
выражение debugger в коде
VS Code + https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome
https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd
http://vuetron.io/

Axios
https://github.com/axios/axios

получение данных

new Vue({
  el: '#app',
  data() {
    return {
      info: null,
      loading: true,
      errored: false
    };
  },
  filters: {
    currencydecimal(value) {
      return value.toFixed(2);
    }
  },
  mounted() {
    axios
      .get('https://api.coindesk.com/v1/bpi/currentprice.json')
	  //если запрос успешен
      .then(response => {
        this.info = response.data.bpi;
      })
	  //если ошибка
      .catch(error => {
        console.log(error);
        this.errored = true;
      })
      .finally(() => (this.loading = false));
  }
});

<div id="app">
  <section v-if="errored">
    <p>не можем получить данные</p>
  </section>

  <section v-else>
    <div v-if="loading">Loading...</div>

    <div
      v-else
      v-for="currency in info"
      class="currency">
      {{currency.description}}:
        <span v-html="currency.symbol"></span>{{ currency.rate_float | currencydecimal }}
    </div>
  </section>
</div>

аналог axios - Fetch API, но пока он не поддерживается всеми браузерами.
vue-resource - альтернатива axios

API для отладки https://jsonplaceholder.typicode.com/
node-пакет jsonp
node.js пакеты импортируются как
import jsonp from 'jsonp'


Хранение данных на стороне клиента
1. Local Storage (технически Web Storage) https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API
2. IndexedDB https://developer.mozilla.org/ru/docs/IndexedDB

Обертка для Local Storage
https://github.com/pinguinjkeke/vue-local-storage

шаблон для вебпак
https://github.com/vuejs-templates/webpack
---------------------------------------------------------------------------------------------------

РАЗНОЕ

где писать код
https://codesandbox.io/s/vue
https://codesandbox.io/search?refinementList%5Btemplate%5D%5B0%5D=vue-cli

какой-то шаблон
https://github.com/vue-land/create-vue-app

В ядре data/computed/methods, в тег компонента передаются как параметры через v-bind, а внутри компонента доступны в props
---------------------------------------------------------------------------------------------------

AXIOS

установка
npm install axios

подключение
в main.js

1 способ подключения:
import axios from 'axios';
window.axios = axios;
axios.get(url)
  .then(response=>{console.log(response);})
  .catch(error=>{console.log(error);})

2 способ подключения:
import axios from 'axios';
Vue.prototype.$http = axios;
this.$http.get(url)
  .then(response=>{console.log(response);})
  .catch(error=>{console.log(error);})

3 способ подключения:
npm install vue-axios
import VueAxios from 'vue-axios';
Vue.use(VueAxios, axios);
this.$http.get(url)
  .then(response=>{console.log(response);})
  .catch(error=>{console.log(error);})
---------------------------------------------------------------------------------------------------  

VUEX

установка
npm install vuex

создание в /src/store/store.js:
import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
export default new Vuex.Store({
  state: {
  products: []
  }
})

подключение в /src/main.js:
import store from './store/store'
new Vue({
  store:store
})

использование свойства:
this.$store.state.products

В actions вся сложная и асинхронная логика
В mutations простая синхронная логика
На все свойства в state писать свои getters, а не брать напрямую

вызов геттера:
this.$store.getters.getProducts

Хелпер mapGetters
в компоненте делаем так:
import {mapGetters} from 'Vuex';
computed: {
  ...mapGetters({
    products: 'getProducts'
  }),
  any() {
  //еще что-то
  }
}

Вообщем mapGetters заливает геттеры из Vuex в computed компонента.
3 точки это какбы вынос объекта на уровень вверх, чтобы рядом можно было писать еще методы computed и чтобы mapGetters не занимал всю область computed, всё что внутри, вообщем чтобы не перезаписывал.

Хелпер mapActions
заливает методы из Vuex. в компоненте пишем так:
methods: {
  ...mapActions(['loadProducts'])
}
и его можно вызывать так:
this.$store.dispatch('loadProducts'); // без хелпера
this.loadProducts(); // когда подключен хелпер

Можно импортировать сразу все хелперы
import {mapGetters, mapActions, mapMutations, mapState} from 'Vuex';

Ручная реализация Vuex
/src/service.js:
import Vue from 'vue'
export default new Vue({
  data: {
    products: []
  }
})
Использование:
import Service from './service.js'
created() {
  this.products = Service.products
}

Создание модулей в Store

Модуль /src/store/task.js:
import Vue from 'vue'
import Vuex from 'vuex'
import task from './task'
Vue.use(Vuex)
export default new Vuex.Store({
  modules: {
    task
  }
})

В main.js:
import store from './store'
new Vue({
  store
})

Сам модуль task.js
export default {
  state: {},
  mutations: {},
  actions: {},
  getters: {},
}
---------------------------------------------------------------------------------------------------

VUE-ROUTER

установка
npm install vue-router

создание в /src/routes.js:
import Component1 from './Component1.vue';
import Component2 from './Component2.vue';
import Component3 from './Component3.vue';
export const routes = [
  {path: '/url1', component: Component1},
  {path: '/url2/:id', component: Component2}, //роут с параметрами
  {path: '/url3', component: Component3, name: 'home3'}, //именованный роут
  {path: '*',component: Component404}, // заглушка 404

  //именованный роут с параметрами
  {
    path: '/url5/:id',
    component: Component5,
    name: 'home5'
  },

    //проброс GET-параметра (id) не только в $route.params, но и в props компонента
    {
      path: '/url6/:id',
      component: Component6,
      name: 'home6',
      props: true
    },

    //дочерний роут
    {
      path: '/url7',
      component: Component7,
      children: [
        {
          path: '/url8',
          component: Component8,
        }
      ]
    },
]

подключение routes в /src/router.js:
import Vue from 'vue';
import VueRouter from 'vue-router';
import {routes} from './routes'
Vue.use(VueRouter);
export const router = new VueRouter({
  routes:routes,
  mode: 'history'
})

подключение router в main.js:
import Vue from 'vue';
import {router} from './router'
new Vue({
  router:router
})

Контейнер, куда генерятся компоненты, взависимости от урла
<router-viev></router-viev>

Создание ссылок навигации
<router-link to='/url1'></router-link>
<router-link :to='{name: 'home3'}'></router-link> //именованный роут

Передача query string
<router-link to='/url?text1=hi'></router-link>
а в компоненте {{$route.query.text1}}

Ссылки навигации в обертке
<router-link tag='li' class='class1' to='/url1'>
  <a>Cars</a>
</router-link>

Список ссылок
<router-link tag='li' v-for='car in 5' :to="'/url1/' + car" :key='car'>
  <a>{{car}}</a>
</router-link>

Ссылка с передачей объекта
<router-link tag='li' :to="{name: 'carFull', params: {id:id}}"></router-link>

Редирект
this.$router.push('/url2');
this.$router.push('/url2/'+id);
this.$router.push({name: 'home5', params: {id:100}}) //именованный роут с параметрами

Доступ к GET-параметрам в компонентах
в this.$route.params['id'] все get-параметры, с которыми компонент был вызван
---------------------------------------------------------------------------------------------------

MIXINS

Решают проблему дублирования кода в компонентах
Миксин это обычный объект Vue, как new Vue({})
Миксин присоединяется к компоненту, и делается merge его свойств, методов, хуков итд, к компоненту. Т.е. компонент+миксин
У компонента data, methods, итд - сливается с data, methods, итд - у миксина
Миксин примешивается в компонент, внутри себя получая все data, methods,итд компонента
Если одинаковые названия чего-либо, то компонент перезатирает миксин. Кроме хуков
Сначала выполнятся хуки из миксина, потом из компонента
Инстанс миксина создается каждый раз новый, на каждый компонент
Глобальный миксин автоматически ставится всем компонентам

Создание миксина /mixins/list.js
import...чего-либо
export default {
  data() {
    return {
      items: []
    }
  }
}

Импорт миксина в компонент
import list from '../mixins/list';
export default {
  mixins: [list] //регистрируем миксин локально в компоненте
}
Всё что было в миксине в data - появляется в data компонента, как его родные свойства
Всё что было в компоненте в data - доступно в миксине, как его родные свойства

Создание глобального миксина
Vue.mixin({})
---------------------------------------------------------------------------------------------------

HOOKS
Хук created - для извлечения данных, и подписки на события
Если компонент обернут в <keep-alive>, то у него появляется еще 2 хука: activated, deactivated
---------------------------------------------------------------------------------------------------

FILTERS

Использование
{{text | reverse1}}
{{text | reverse2('*')}}

Создание
filters: {
  'reverse1' : function (value) {
    return value + 'тратата';
  }
}

Глобальный фильтр
Vue.filter('reverse1', function(value) {
  return value + 'тратата';
})

Фильтр с параметром
filters: {
  'reverse2' : function (value, param1) {
    return value + param1;
  }
}

Computed кешируются.
Filters не кешируются.
---------------------------------------------------------------------------------------------------

COMPONENTS

тут data объект
new Vue({
  data: {}
})

тут data функция
Vue.component('name', {
  data: function() {
    return {}
  }
})

Регистрация глобального компонента
Vue.component({})

Локальный компонент
new Vue({
  components: {
    'name': {}
  }
})

Если название компонента myComponent
То применять как <my-component></my-component> или <myComponent></myComponent>

Подключение:
есть рутовый компонент App.vue
в нем применяем компоненты как <my-component></my-component>
импортируем как import myComponent from './myComponent.vue'
подключаем как export defaults {components: {myComponent}}

Передача параметров в компонент
<my-component :product='product'></my-component>

Ловим параметры в компоненте
export defaults {
  props: ['product']
}
теперь product стал таким, будто находится в массиве data, поведение аналогично

Props с указанием типа
props: {
  product: Object
  или
  product: [Object, String] //если 2 типа
  required: true //обязательность
  default: function() {} //дефолтное значение
}

Передача события вверх (через событие)
дочерний компонент:
<button @click='method1'></button>
methods: {
  method1() {
    this.$emit('event1', param)
  }
}
родительский компонент:
<my-component @event1='method2'></my-component>
methods: {
  method2(param) {
    console.log(param);
    //или можно передать дальше наверх this.$emit('event2', param)
  }
}

Передача события вверх (через колбек)
родительский компонент:
<my-component :method2='method2'></my-component> //передаем в props дочернего компонента функцию параметр method2 как функцию method2
дочерний компонент:
props: {
  method2: Function //в дочернем ее ловим
}
methods: {
  method2() {
    this.method2(param) //и далее из дочернего вызываем функцию в родительском
  }
}

Как переключать компоненты на одном месте
<my-component :is='name1'></my-component>
computed: {
  name1() {
  return this.mode == 1 ? 'details' : 'add';
  }
}
если компонент обернут в <keep-alive> то компонент не перерендеривается при переключении

В родительском есть 2 компонента:
<component1></component1>
<component2></component2>
import component1 from './component1'
import component2 from './component2'
export default {
  components: {
    component1,
    component2
  }
}

Переключать компоненты можно так:
<component1 v-if='toggle1'></component1>
<component2 v-else></component2>

Но лучше так:
<component :is='toggle2'></component>
computed: {
 toggle1() {
   return this.toggle2 == 1 ? 'component1' : 'component2';
 }
}

Но лучше и импорты убрать, и импортировать тоже динамически
<component :is='toggle3'></component>
computed: {
 toggle3() {
   let nameComp = this.toggle2 == 1 ? 'component1' : 'component2';
   return () => import('./${nameComp}')
 }
}
---------------------------------------------------------------------------------------------------

DIRECTIVES

<div v-name1></div>

Создадим директиву глобально
Vue.directive('name1', {
  //bind это хук директивы, вешаем на него
  bind: function(el, binding, vnode) {
    console.log(el); //сам элемент
    console.log(binding); //переданный параметр
    console.log(binding.arg[0]); //именованный параметр
    console.log(binding.modifiers['mod1']); //модификатор
    console.log(binding.value.property1); //объект
  }
})

директива с параметрами
<div v-name1='100'></div>

директива с именованным параметром
<div v-name1:param1='100'></div>

директива с модификаторами
<div v-name1:param1.mod1.mod2='100'></div>

директива с объектом
<div v-name1='{property1:1, property2:2}'></div>

Создание локальной директивы
new Vue({
  directives: {
    'name1': {

    }
  }
})
---------------------------------------------------------------------------------------------------

SLOTS

Есть компонент, а внутри контент
<component><h1>Привет</h1></component>
чтобы его вывести, надо сделать так:
<template>
  <div>
    <slot></slot>
  </div>
</template>
контент вставится вместо <slot>

Именованный слот
<component>
  <h1>Привет1</h1>
  <h1 slot='name1'>Привет2</h1>
</component>
Выводим:
<template>
  <div>
    <slot></slot>
    <slot name='name1'></slot>
  </div>
</template>

Дефолтовый контент, если в слот не будет ничего передано, или его не будет вообще
<template>
  <div>
    <slot name='name1'>default string</slot>
  </div>
</template>

Внутри слота работают переменные, как обычно
<component>
  <h1>Привет1</h1>
  <h1 slot='name1'>{{message}}</h1>
</component>
---------------------------------------------------------------------------------------------------

Привязка аттрибутов
<h1>{{name}}</h1>
<h1 v-bind:title='name'></h1>
data: {
  name: 'тратата'
}

Прослушивание событий
<button @click='method1'></button>
methods: {
  method1: function() {}
}

Наблюдатель
data: {
  name1: 'тратата'
}
watch: {
  name1: function() {
    console.log(this.name1);
  },
  name2: function(val) {
      console.log(val); //тут val это то, на что изменилось свойство name2
    }
}
watch асинхронны
watch наблюдает за свойством name1 и срабатывает при каждом изменении

Двустороннее связывание (2 way binding)
<input v-model='message'>
data: {
  message: 'тратата'
}

Динамически вычисляемое свойство
data: {
  message: 'тратата'
}
computed: {
  fullmessage: function() {
    return this.message+100;
  }
}
computed синхронны

Вывод html в тег
<p v-html='message'></p>

Условная отрисовка
<div v-if='true'></div>

Доступ к данным
this.name1
this.$data.name1

Создание экземпляра Vue
var vm1 = new Vue({el: '#app'})
Но el можно прицепить потом:
var vm1 = new Vue({})
vm1.$mount('#app')

Работа напрямую с реальным DOM. Что такое ref
<h1 ref='btn'></h1>
vm1.$refs.btn.innerText = 'тратата'

Подключение сторонних библиотек
в хуке created()

Проверка на залогиненность
в массиве роутов, у каждого роута есть хук beforeEnter(to,from,next), там и писать

Разобраться что за запись
export default class Task {}
import Task from './task'

Оператор 3 точки
const newTask = new Task(title, desc, time)
commit('newTask', {...newTask, id, tags}) //оператор ... развертывает сюда все поля, плюс еще можно указать

Ленивая загрузка (lazy)
вместо этого:
import Car from './Car'
писать так:
const Car = resolve => {
  require.ensure(['./Car.vue'], ()=> {
    resolve(
      require('./Car.vue')
    )
  })
}

v-bind динамически связывает аттрибуты тега или входные параметры компонента, с выражением

Это одно и тоже
<h1 v-text="message"></h1>
<h1>{{message}}</h1>

v-model для 2направленного связывания данных

в компоненте - data это функция
в экземпляре Vue - data это объект

main.js собирает все vue-файлы и помещает их в index.html
---------------------------------------------------------------------------------------------------

VUE-CLI 3

установка vue-cli
npm install -g @vue/cli

создать проект
vue create projectname

запуск графического интерфейса
vue ui

быстрое прототипирование
npm install -g @vue/cli-service-global
нужно для того, чтобы создать 1 компонент (1 vue-файл) и работать с ним без папки и всей обвязки

добавить плагин
vue add vuex

скачивание зависимостей в проект (из package.json в папку node_modules)
npm install

запуск сервера в режиме разработки с горячей перезагрузкой (хост localhost:8080)
npm run dev

создание сборки для продакшена (минификация)
npm run build
---------------------------------------------------------------------------------------------------

Готовые компоненты UI

http://element.eleme.io
https://vuematerial.io
https://vuetifyjs.com/ru
https://quasar-framework.org
https://muse-ui.org
https://www.iviewui.com
---------------------------------------------------------------------------------------------------

На одной странице может быть два дива #app1 и #app2 и два Vue({})
И можно из одного, вызывать методы другого, и получать доступ к свойствам

данные в компонент передаются также, как и биндинг параметров. через v-bind
для операций с массивами использовать lodash. lodash включена как часть стандартного проекта

Нужны ли мне эти данные в более чем 2-х компонентах, не связанных отношениями родитель-дочерний компонент? Да—храните это во Vuex, нет—храните локально, в компоненте.

Ленивая загрузка изображений.
npm install vue-lazyload
вместо атрибута src используйте директиву v-lazy

Используйте динамический импорт для роутов.
Использование динамических импортов позволяет загружать код для каждой страницы только тогда, когда пользователь переходит на неё.
Вместо этого:
import Profile from ‘@/views/Profile’;
Сделайте так:
const Profile = () => import(‘@/views/Profile’);

UX полоса загрузки как на Youtube
npm install nprogress